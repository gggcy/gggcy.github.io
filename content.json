{"pages":[{"title":"","text":"4eY21qjSD7","link":"/baidu_verify_4eY21qjSD7.html"},{"title":"关于我","text":"江苏昆山人矿大计算机硕士在读爱游山玩水，坐不住的码农喜欢结交朋友聊旅游，聊技术，聊人生欢迎通过扫描二维码加我好友 联系我Email:gaocunyuan@qq.com","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"手推SVM及常见面试问题","text":"面试必备 1、手推SVM差不多这个程度应该够了。 2、SVM为什么叫支持向量机这个名字是强调了此类学习器的关键是如何从支持向量构建出解；同时也暗示了其复杂度主要与支持向量的数目有关。 3、SVM的损失函数（求导省略了） 4、核函数了解哪些，为什么要用核函数当样本在原始空间线性不可分时，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。 线性核，主要用于线性可分的情况，我们可以看到特征空间到输入空间的维度是一样的，其参数少速度快，对于线性可分数据，其分类效果很理想，因此我们通常首先尝试用线性核函数来做分类，看看效果如何，如果不行再换别的。 多项式核函数可以实现将低维的输入空间映射到高纬的特征空间，但是多项式核函数的参数多，当多项式的阶数比较高的时候，核矩阵的元素值将趋于无穷大或者无穷小，计算复杂度会大到无法计算。 高斯（RBF）核函数 是一种局部性强的核函数，其可以将一个样本映射到一个更高维的空间内，该核函数是应用最广的一个，无论大样本还是小样本都有比较好的性能，而且其相对于多项式核函数参数要少，因此大多数情况下在不知道用什么核函数的时候，优先使用高斯核函数。 采用sigmoid核函数，支持向量机实现的就是一种多层神经网络。因此，在选用核函数的时候，如果我们对我们的数据有一定的先验知识，就利用先验来选择符合数据分布的核函数；如果不知道的话，通常使用交叉验证的方法，来试用不同的核函数，误差最下的即为效果最好的核函数，或者也可以将多个核函数结合起来，形成混合核函数。在吴恩达的课上，也曾经给出过一系列的选择核函数的方法. 如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况。 5、为什么要将求解SVM的原始问题转换为其对偶问题？ 是对偶问题往往更易求解（当我们寻找约束存在时的最优点的时候，约束的存在虽然减小了需要搜寻的范围，但是却使问题变得更加复杂。为了使问题变得易于处理，把目标函数和约束全部融入一个新的函数，即拉格朗日函数，再通过这个函数来寻找最优点。） 自然引入核函数，进而推广到非线性分类问题。 6、SVM为什么可以处理非线性问题非线性的话通过核函数将其隐射到高维空间，在高维空间非线性问题转化为线性问题。 参考周志华的《机器学习》","link":"/2019/09/07/svm/"},{"title":"K-means原理及常见问题","text":"主要关注伪代码，k怎么选择，初始点怎么选择，原理及优缺点。 原理和流程原理 对给定的无标记的样本数据集，事先确定聚类簇数K，让簇内的样本尽可能紧密分布在一起，使簇间的距离尽可能大。K-Means作为无监督的聚类算法，其类似于全自动分类，簇内越相似，聚类效果越好，实现较简单，聚类效果好，因此被广泛使用。用以下的效果图更能直观地看出其过程： 流程 随即确定K个初始点作为质心（这里如何确定k将在下面给出解释） 将数据集中的每个点分配到一个簇中，即为每个点找距离其最近的质心，并将其分配给之心所对应的簇 簇分好后，计算每个簇所有点的平均值，将平均值作为对应簇新的质心 循环2、3步骤，直到质心不变 伪代码是： 1234567创建k个点作为起始质心（经常是随机选择）当任意一个点的簇分配结果发生改变时 对数据集中的每个数据点 对每个质心 计算质心和数据点之间的距离 将数据点分配到距离其最近的簇 对每一个簇，计算簇中所有点的均值并将均值作为质心 上面“最近”质心，意味着需要进行某种距离的计算，即下文要介绍的K-means中常用的到中心距离的度量有哪些？ K-means中常用的到中心距离的度量 这里最常用的有以下两种 1、曼哈顿距离 2、欧几里得距离（别称“欧式距离”） K-means中的k值如何选取(了解一下) 手肘法 轮廓系数法 面试常见问题回答1、K-means算法中初始点的选择对最终结果有影响吗？ 会有影响的，不同的初始值结果可能不一样 2、K-means聚类中每个类别中心的初始点如何选择？ （1）这k个点的距离尽可能远 （2）可以对数据先进行层次聚类，得到K个簇之后，从每个类簇中选择一个点，该点可以是该类簇的中心点，或者是距离类簇中心点最近的那个点。 3、K-means中空聚类的处理（1）选择一个距离当前任何质心最远的点。这将消除当前对总平方误差影响最大的点。 （2）从具有最大SSE的簇中选择一个替补的质心，这将分裂簇并降低聚类的总SSE。如果有多个空簇，则该过程重复多次。 （3）如果噪点或者孤立点过多，考虑更换算法，如密度聚类。 4、K-means是否会一直陷入选择质心的循环停不下来？ （1）迭代次数设置 （2）设定收敛判断距离 5、如何快速收敛数据量超大的K-means？ 相关解释可以去这个博客稍做了解 https://blog.csdn.net/sunnyxidian/article/details/89630815 6、K-means算法的优点和缺点是什么？ K-Means的主要优点： （1）原理简单，容易实现 （2）可解释度较强 7、 K-Means的主要缺点： （1）K值很难确定 （2）局部最优 （3）对噪音和异常点敏感 （4）需样本存在均值（限定数据种类） （5）聚类效果依赖于聚类中心的初始化 （6）对于非凸数据集或类别规模差异太大的数据效果不好 参考 https://blog.csdn.net/WangZixuan1111/article/details/98970139","link":"/2019/09/06/kmeans/"},{"title":"L1正则&L2正则常见问题","text":"L1正则&amp;L2正则常考题目及解答。 过拟合的解决方式有哪些，l1和l2正则化都有哪些不同，各自有什么优缺点(爱奇艺) L1和L2正则化来避免过拟合是大家都知道的事情，而且我们都知道L1正则化可以得到稀疏解，L2正则化可以得到平滑解，这是为什么呢？ L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。（美团） L1和L2的区别，以及各自的使用场景（头条） 什么是L1正则&amp;L2正则？L1正则即将参数的绝对值之和加入到损失函数中，以二元线性回归为例，损失函数变为： L2正则即将参数的平方之和加入到损失函数中，以二元线性回归为例，损失函数变为： L1正则&amp;L2正则的区别是什么？ L1正则化是指在损失函数中加入权值向量w的绝对值之和，即各个元素的绝对值之和，L2正则化指在损失函数中加入权值向量w的平方和。 L1的功能是使权重稀疏，而L2的功能是使权重平滑。 L1正则为什么可以得到稀疏解？解空间形状L2正则化相当于为参数定义了一个圆形的解空间，而L1正则化相当于为参数定义了一个菱形的解空间。L1“棱角分明”的解空间显然更容易与目标函数等高线在脚点碰撞。从而产生稀疏解。 其中变量 w 是动态参数，如果我们调节 w 就会得到一系列的圆，这也是你在上图中看到这么多圆线的原因，上图中其实假设了 w 参数只有二维，这样方便在图中表示，与此同时 L 的图像是一个旋转 90 度的矩形，图像中二者交点的位置就是可能出现最优解的地方，你会发现二者相交出现极大可能的位置就是顶点处，矩形顶点的地方肯定是由其中一个 w 为 0 的，w 为 0 则表示其中一个特征并不是我们需要的特征可以忽略不计，这就说明了 L1 会产生稀疏解的原因。 L2为什么可以解决过拟合拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数 w 都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。若某个 w 参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果 w 参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。L2正则化就是可以使权重平滑。 L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验","link":"/2019/09/05/l1l2/"},{"title":"简单粗暴的BP图示及公式","text":"来源是Introduction to Deep Learning MIT 6.S191。","link":"/2019/09/05/bp/"},{"title":"主成分分析PCA原理和执行步骤","text":"主成分分析（PCA）特征选择算法简介，包含适用场景。 简介PCA全称Principal Component Analysis，即主成分分析，是一种常用的数据降维方法。它可以通过线性变换将原始数据变换为一组各维度线性无关的表示，以此来提取数据的主要线性分量。 适用场景我们在处理实际问题的时候，进行特征提取过程中，提取的特征维数太多经常会导致特征匹配时过于复杂，消耗计算资源。 重点 线性变换=&gt;新特征轴可由原始特征轴线性变换表征 线性无关=&gt;构建的特征轴是正交的 主要线性分量（或者说是主成分）=&gt;方差加大的方向 PCA算法的求解就是找到主要线性分量及其表征方式的过程 步骤假设有m个样例，n维特征 对每一维特征进行零均值化，即减去均值 再求特征协方差矩阵 求改协方差矩阵的特征值和特征向量 将特征值按照从大到小的顺序排序，并选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。 将样本点投影到选取的特征向量上，假设有m个样例，n维特征，零均值化后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为:","link":"/2019/09/05/pca/"},{"title":"NMS算法（NonMaximumSuppression）","text":"NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。 原理介绍 非极大值抑制（NMS）顾名思义就是抑制不是极大值的元素，搜索局部的极大值。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。这里不讨论通用的NMS算法，而是用于在目标检测中用于提取分数最高的窗口的。例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。 算法流程给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si , 1&lt;=i&lt;=N。 建造一个存放待处理候选框的集合H，初始化为包含全部N个框；建造一个存放最优框的集合M，初始化为空集。 将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M； 遍历集合 H 中的框，分别与框m计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m重叠，将此框从集合 H 中去除。 回到第2步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。 需要优化的参数IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。 python实现123456789101112131415161718192021222324252627282930313233343536def py_cpu_nms(dets, thresh): \"\"\"Pure Python NMS baseline.\"\"\" #x1、y1、x2、y2、以及score赋值 x1 = dets[:, 0] y1 = dets[:, 1] x2 = dets[:, 2] y2 = dets[:, 3] scores = dets[:, 4] #每一个检测框的面积 areas = (x2 - x1 + 1) * (y2 - y1 + 1) #按照score置信度降序排序 order = scores.argsort()[::-1] keep = [] #保留的结果框集合 while order.size &gt; 0: i = order[0] keep.append(i) #保留该类剩余box中得分最高的一个 #得到相交区域,左上及右下 xx1 = np.maximum(x1[i], x1[order[1:]]) yy1 = np.maximum(y1[i], y1[order[1:]]) xx2 = np.minimum(x2[i], x2[order[1:]]) yy2 = np.minimum(y2[i], y2[order[1:]]) #计算相交的面积,不重叠时面积为0 w = np.maximum(0.0, xx2 - xx1 + 1) h = np.maximum(0.0, yy2 - yy1 + 1) inter = w * h #计算IoU：重叠面积 /（面积1+面积2-重叠面积） ovr = inter / (areas[i] + areas[order[1:]] - inter) #保留IoU小于阈值的box inds = np.where(ovr &lt;= thresh)[0] order = order[inds + 1] #因为ovr数组的长度比order数组少一个,所以这里要将所有下标后移一位 return keep`","link":"/2019/09/05/nms/"},{"title":"算法面试通关40讲总结","text":"知识图谱的形式总结极客时间的算法面试通关40讲课程 转载自链接：https://blog.csdn.net/xushuanglu_csdn/article/details/87165984","link":"/2019/08/22/algorithm40/"},{"title":"【python】冒泡，选择，插入，希尔，快速，归并排序的实现及图解","text":"总结基本的排序算法。 冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示： 12345678910def bubble_sort(alist): for j in range(n-1): count = 0 #利用count进行优化，如果中间有一次不交换了，则证明已经排序完毕 # j表示每次遍历需要比较的次数，是逐渐减小的 for i in range(n-1-j): if alist[i] &gt; alist[i+1]: alist[i], alist[i+1] = alist[i+1], alist[i] count+=1 if count == 0: return 时间复杂度 最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）需要加上count进行判断。 最坏时间复杂度：O(n2) 稳定性：稳定冒泡排序的演示 选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 123456789101112def selection_sort(alist): n = len(alist) # 需要进行n-1次选择操作 for i in range(n-1): # 记录最小位置 min_index = i # 从i+1位置到末尾选择出最小数据 for j in range(i+1, n): if alist[j] &lt; alist[min_index]: min_index = j # 如果选择出的数据不在正确位置，进行交换 alist[i], alist[min_index] = alist[min_index], alist[i] 时间复杂度 最优时间复杂度：O(n2) 最坏时间复杂度：O(n2) 稳定性：不稳定（考虑升序每次选择最大的情况） 选择排序的演示红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 1234567891011def insert_sort(alist): # 从第二个位置，即下标为1的元素开始向前插入 for i in range(1, len(alist)): # 从第i个元素开始向前比较，如果小于前一个元素，交换位置 j = i while j &gt; 0: if alist[j] &lt; alist[j-1]: alist[j], alist[j-1] = alist[j-1], alist[j] j -= 1 else: break 时间复杂度 最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）每次都直接break，跳出循环 最坏时间复杂度：O(n2) 稳定性：稳定 插入排序的演示 希尔排序希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 python2和python3里的整除分别对应 / 和 //。 1234567891011121314151617def shell_sort(alist): n = len(alist) # 初始步长 gap = n // 2 while gap &gt; 0: # 按步长进行插入排序 for i in range(gap, n): j = i # 插入排序 while j &gt; 0: if alist[j-gap] &gt; alist[j]: alist[j-gap], alist[j] = alist[j], alist[j-gap] j -= gap else: break # 得到新的步长 gap = gap // 2 时间复杂度 最优时间复杂度：根据步长序列的不同而不同 最坏时间复杂度：O(n2) 稳定想：不稳定 希尔排序的图示 快速排序快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤为： 从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 123456789101112131415161718192021222324252627282930313233343536373839404142def quick_sort(alist, start, end): \"\"\"快速排序\"\"\" # 递归的退出条件 if start &gt;= end: return # 设定起始元素为要寻找位置的基准元素 mid = alist[start] # low为序列左边的由左向右移动的游标 low = start # high为序列右边的由右向左移动的游标 high = end while low &lt; high: # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动 while low &lt; high and alist[high] &gt;= mid: high -= 1 # 将high指向的元素放到low的位置上 alist[low] = alist[high] # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动 while low &lt; high and alist[low] &lt; mid: low += 1 # 将low指向的元素放到high的位置上 alist[high] = alist[low] # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置 # 将基准元素放到该位置 alist[low] = mid # 对基准元素左边的子序列进行快速排序 quick_sort(alist, start, low-1) # 对基准元素右边的子序列进行快速排序 quick_sort(alist, low+1, end)alist = [54,26,93,17,77,31,44,55,20]quick_sort(alist,0,len(alist)-1)print(alist) 时间复杂度 最优时间复杂度：O(nlogn) 最坏时间复杂度：O(n2) 稳定性：不稳定 从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。 在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。 快速排序的图示 归并排序归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。 将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。 1234567891011121314151617181920212223242526272829def merge_sort(alist): if len(alist) &lt;= 1: return alist # 二分分解 num = len(alist)/2 left = merge_sort(alist[:num]) right = merge_sort(alist[num:]) # 合并 return merge(left,right)def merge(left, right): '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组''' #left与right的下标指针 l, r = 0, 0 result = [] while l&lt;len(left) and r&lt;len(right): if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return resultalist = [54,26,93,17,77,31,44,55,20]sorted_alist = mergeSort(alist)print(sorted_alist) 时间复杂度 最优时间复杂度：O(nlogn) 最坏时间复杂度：O(nlogn) 稳定性：稳定 归并排序的图示 常见排序算法效率比较 搜索搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找 二分法查找二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 非递归实现123456789101112131415def binary_search(alist, item): first = 0 last = len(alist)-1 while first&lt;=last: midpoint = (first + last)/2 if alist[midpoint] == item: return True elif item &lt; alist[midpoint]: last = midpoint-1 else: first = midpoint+1 return Falsetestlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]print(binary_search(testlist, 3))print(binary_search(testlist, 13)) 递归实现12345678910111213141516def binary_search(alist, item): if len(alist) == 0: return False else: midpoint = len(alist)//2 if alist[midpoint]==item: return True else: if item&lt;alist[midpoint]: return binary_search(alist[:midpoint],item) else: return binary_search(alist[midpoint+1:],item)testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]print(binary_search(testlist, 3))print(binary_search(testlist, 13)) 时间复杂度 最优时间复杂度：O(1) 最坏时间复杂度：O(logn)","link":"/2019/08/13/sort/"},{"title":"【python】 多种链表的实现及python中“=”的解读","text":"python中“=”的正确、简单好记的理解以及python链表的实现。 python中“=”的理解python并不像是c/c++，c++中新建一个变量，比如int a = 3，此时必须申明变量的类型，找一块内存空间存储3，这个内存空间的别名是a，占4个字节且a只能存整数。 python中并不需要申明类型，a = 10这种隐式申明的的原因是，a是另外一个内存，保存的是一个地址，地址指向什么就代表a是什么。123def C(): passa = C a可以重新指向一个方法，类或是对象中的元素都行。所以 = 只能代表把指向更改，指向了什么。 节点实现1234567class SingleNode(object): \"\"\"单链表的结点\"\"\" def __init__(self,item): # _item存放数据元素 self.item = item # _next是下一个节点的标识 self.next = None 单链表的实现及部分操作123456789101112131415161718192021222324252627282930313233343536373839class SingleLinkList(object): \"\"\"单链表\"\"\" def __init__(self): self.__head = None #__双下划线代表私有变量/方法 #_但下划线代表保护变量/方法 def is_empty(self): \"\"\"判断链表是否为空\"\"\" return self.__head == None def length(self): \"\"\"链表长度\"\"\" # cur初始时指向头节点 cur = self.__head count = 0 # 尾节点指向None，当未到达尾部时 while cur != None: count += 1 # 将cur后移一个节点 cur = cur.next return count def travel(self): \"\"\"遍历链表\"\"\" cur = self.__head while cur != None: print(cur.item,end=\" \") cur = cur.next ``` ## 头部添加元素 ```python def add(self, item): \"\"\"头部添加元素\"\"\" # 先创建一个保存item值的节点 node = SingleNode(item) # 将新节点的链接域next指向头节点，即_head指向的位置 node.next = self.__head # 将链表的头_head指向新节点 self.__head = node 尾部添加元素123456789101112def append(self, item): \"\"\"尾部添加元素\"\"\" node = SingleNode(item) # 先判断链表是否为空，若是空链表，则将_head指向新节点 if self.is_empty(): self.__head = node # 若不为空，则找到尾部，将尾节点的next指向新节点 else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node 指定位置添加元素 123456789101112131415161718192021def insert(self, pos, item): \"\"\"指定位置添加元素\"\"\" # 若指定位置pos为第一个元素之前，则执行头部插入 if pos &lt;= 0: self.add(item) # 若指定位置超过链表尾部，则执行尾部插入 elif pos &gt; (self.length()-1): self.append(item) # 找到指定位置 else: node = SingleNode(item) count = 0 # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置 pre = self.__head while count &lt; (pos-1): count += 1 pre = pre.next # 先将新节点node的next指向插入位置的节点 node.next = pre.next # 将插入位置的前一个节点的next指向新节点 pre.next = node 删除节点 12345678910111213141516171819def remove(self,item): \"\"\"删除节点\"\"\" cur = self.__head pre = None while cur != None: # 找到了指定元素 if cur.item == item: # 如果第一个就是删除的节点 if not pre: # 将头指针指向头节点的后一个节点 self.__head = cur.next else: # 将删除位置前一个节点的next指向删除位置的后一个节点 pre.next = cur.next break else: # 继续按链表后移节点 pre = cur cur = cur.next 查找节点是否存在12345678def search(self,item): \"\"\"链表查找节点是否存在，并返回True或者False\"\"\" cur = self.__head while cur != None: if cur.item == item: return True cur = cur.next return False 链表与顺序表的对比链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。链表与顺序表的各种操作复杂度如下所示： 注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。 单向循环链表单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156class Node(object): \"\"\"节点\"\"\" def __init__(self, item): self.item = item self.next = Noneclass SinCycLinkedlist(object): \"\"\"单向循环链表\"\"\" def __init__(self): self._head = None def is_empty(self): \"\"\"判断链表是否为空\"\"\" return self._head == None def length(self): \"\"\"返回链表的长度\"\"\" # 如果链表为空，返回长度0 if self.is_empty(): return 0 count = 1 cur = self._head while cur.next != self._head: count += 1 cur = cur.next return count def travel(self): \"\"\"遍历链表\"\"\" if self.is_empty(): return cur = self._head print cur.item, while cur.next != self._head: cur = cur.next print cur.item, print \"\" def add(self, item): \"\"\"头部添加节点\"\"\" node = Node(item) if self.is_empty(): self._head = node node.next = self._head else: #添加的节点指向_head node.next = self._head # 移到链表尾部，将尾部节点的next指向node cur = self._head while cur.next != self._head: cur = cur.next cur.next = node #_head指向添加node的 self._head = node def append(self, item): \"\"\"尾部添加节点\"\"\" node = Node(item) if self.is_empty(): self._head = node node.next = self._head else: # 移到链表尾部 cur = self._head while cur.next != self._head: cur = cur.next # 将尾节点指向node cur.next = node # 将node指向头节点_head node.next = self._head def insert(self, pos, item): \"\"\"在指定位置添加节点\"\"\" if pos &lt;= 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: node = Node(item) cur = self._head count = 0 # 移动到指定位置的前一个位置 while count &lt; (pos-1): count += 1 cur = cur.next node.next = cur.next cur.next = node def remove(self, item): \"\"\"删除一个节点\"\"\" # 若链表为空，则直接返回 if self.is_empty(): return # 将cur指向头节点 cur = self._head pre = None # 若头节点的元素就是要查找的元素item if cur.item == item: # 如果链表不止一个节点 if cur.next != self._head: # 先找到尾节点，将尾节点的next指向第二个节点 while cur.next != self._head: cur = cur.next # cur指向了尾节点 cur.next = self._head.next self._head = self._head.next else: # 链表只有一个节点 self._head = None else: pre = self._head # 第一个节点不是要删除的 while cur.next != self._head: # 找到了要删除的元素 if cur.item == item: # 删除 pre.next = cur.next return else: pre = cur cur = cur.next # cur 指向尾节点 if cur.item == item: # 尾部删除 pre.next = cur.next def search(self, item): \"\"\"查找节点是否存在\"\"\" if self.is_empty(): return False cur = self._head if cur.item == item: return True while cur.next != self._head: cur = cur.next if cur.item == item: return True return Falseif __name__ == \"__main__\": ll = SinCycLinkedlist() ll.add(1) ll.add(2) ll.append(3) ll.insert(2, 4) ll.insert(4, 5) ll.insert(0, 6) print \"length:\",ll.length() ll.travel() print ll.search(3) print ll.search(7) ll.remove(1) print \"length:\",ll.length() ll.travel() 双向链表一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136class Node(object): \"\"\"双向链表节点\"\"\" def __init__(self, item): self.item = item self.next = None self.prev = Noneclass DLinkList(object): \"\"\"双向链表\"\"\" def __init__(self): self._head = None def is_empty(self): \"\"\"判断链表是否为空\"\"\" return self._head == None def length(self): \"\"\"返回链表的长度\"\"\" cur = self._head count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): \"\"\"遍历链表\"\"\" cur = self._head while cur != None: print cur.item, cur = cur.next print \"\" def add(self, item): \"\"\"头部插入元素\"\"\" node = Node(item) if self.is_empty(): # 如果是空链表，将_head指向node self._head = node else: # 将node的next指向_head的头节点 node.next = self._head # 将_head的头节点的prev指向node self._head.prev = node # 将_head 指向node self._head = node def append(self, item): \"\"\"尾部插入元素\"\"\" node = Node(item) if self.is_empty(): # 如果是空链表，将_head指向node self._head = node else: # 移动到链表尾部 cur = self._head while cur.next != None: cur = cur.next # 将尾节点cur的next指向node cur.next = node # 将node的prev指向cur node.prev = cur def search(self, item): \"\"\"查找元素是否存在\"\"\" cur = self._head while cur != None: if cur.item == item: return True cur = cur.next return False def insert(self, pos, item): \"\"\"在指定位置添加节点\"\"\" if pos &lt;= 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: node = Node(item) cur = self._head count = 0 # 移动到指定位置的前一个位置 while count &lt; (pos-1): count += 1 cur = cur.next # 将node的prev指向cur node.prev = cur # 将node的next指向cur的下一个节点 node.next = cur.next # 将cur的下一个节点的prev指向node cur.next.prev = node # 将cur的next指向node cur.next = node def remove(self, item): \"\"\"删除元素\"\"\" if self.is_empty(): return else: cur = self._head if cur.item == item: # 如果首节点的元素即是要删除的元素 if cur.next == None: # 如果链表只有这一个节点 self._head = None else: # 将第二个节点的prev设置为None cur.next.prev = None # 将_head指向第二个节点 self._head = cur.next return while cur != None: if cur.item == item: # 将cur的前一个节点的next指向cur的后一个节点 cur.prev.next = cur.next # 将cur的后一个节点的prev指向cur的前一个节点 cur.next.prev = cur.prev break cur = cur.nextif __name__ == \"__main__\": ll = DLinkList() ll.add(1) ll.add(2) ll.append(3) ll.insert(2, 4) ll.insert(4, 5) ll.insert(0, 6) print \"length:\",ll.length() ll.travel() print ll.search(3) print ll.search(4) ll.remove(1) print \"length:\",ll.length() ll.travel()","link":"/2019/08/12/linked list/"},{"title":"【python】 list的基本实现","text":"总结python在list中的原理和实现。 python中list的基本实现技术元素外置的顺序表python中的list可以存放不同类型的数据，比如int，char，float等等，这些数据元素大小不同，所以得用到外置顺序表。1list1 = [1,\"abc\",2.2] Loc(li) = Loc(l0) + c*i 元素的大小不统一，则须采用如图的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。如图这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。 顺序表的结构一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。 python中的list主要采用分离式结构，如图 表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。这样在进行扩充的时候，数据的迁移，不用迁徙表头，指针指向的地址改变就行。 list的数据扩充在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。","link":"/2019/08/12/list/"},{"title":"栈的应用，括号匹配问题，中缀、后缀表达式","text":"主要是中缀、后缀表达式的转换。 栈的应用使用场景1.符号匹配2.计算机表达式的转换3.CPU内部栈主要是用来进行子程序调用和返回4.进制转换 1.括号匹配问题大多数计算机语言中都需要检测括号是否匹配，那么如何实现符号成对检测？ 算法思路： 从第一个字符开始扫描 当遇见普通字符时忽略， 当遇见左符号时压入栈中 当遇见右符号时从栈中弹出栈顶符号，并进行匹配 匹配成功：继续读入下一个字符 匹配失败：立即停止，并报错 结束：成功: 所有字符扫描完毕，且栈为空失败：匹配失败或所有字符扫描完毕但栈非空 2.计算机表达式转换计算机的本质工作就是做数学运算，那计算机可以读入字符串“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？ 中缀表达式和后缀表达式后缀表达式（由波兰科学家在20世纪50年代提出）将运算符放在数字后面 ===》 符合计算机运算我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯实例1235 + 4 =&gt; 5 4 + 1 + 2 * 3 =&gt; 1 2 3 * + 8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * + 算法思路中缀转后缀：遍历中缀表达式中的数字和符号 对于数字：直接输出 对于符号： （1）左括号：进栈（2）运算符号：与栈顶符号进行优先级比较若栈顶符号优先级低：此符号进栈（默认栈顶若是左括号，左括号优先级最低）若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈（3）右括号：将栈顶符号弹出并输出，直到匹配左括号 遍历结束：将栈中的所有符号弹出并输出 计算机如何基于后缀表达式结算结果例如：8 3 1 – 5 * + 计算规则： 遍历后缀表达式中的数字和符号 对于数字：进栈 对于符号：（1）从栈中弹出右操作数（2）从栈中弹出左操作数根据符号进行运算将运算结果压入栈中遍历结束：栈中的唯一数字为计算结果","link":"/2019/08/12/stack/"},{"title":"【python】 timeit模块,list及dict操作复杂度","text":"简单减少一个性能分析的模块timeit，以及利用该模块测试list及dict的一些基本操作。 Python内置类型性能分析timeit模块timeit模块可以用来测试一小段Python代码的执行速度。 class timeit.Timer(stmt=’pass’, setup=’pass’ timer=)Timer是测量小段代码执行速度的类。 stmt参数是要测试的代码语句（statment）； setup参数是运行代码时需要的设置； timer参数是一个定时器函数，与平台有关。 timeit.Timer.timeit(number=1000000)Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。 比较list的操作复杂度123456789101112131415161718192021222324252627282930313233def test1(): l = [] for i in range(1000): l = l + [i] #会先创建一个新的列表l + [i]再赋值到新的l上，效率很差。尽量使用l+=[i]，已在python内部优化了。 def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000))def test5(): l =[] for i in range(1000): l.extend([i]) # 类似于 l+=[i]，是直接在列表l上操作from timeit import Timert1 = Timer(\"test1()\", \"from __main__ import test1\")print(\"concat \",t1.timeit(number=1000), \"seconds\")t2 = Timer(\"test2()\", \"from __main__ import test2\")print(\"append \",t2.timeit(number=1000), \"seconds\")t3 = Timer(\"test3()\", \"from __main__ import test3\")print(\"comprehension \",t3.timeit(number=1000), \"seconds\")t4 = Timer(\"test4()\", \"from __main__ import test4\")print(\"list range \",t4.timeit(number=1000), \"seconds\")t4 = Timer(\"test5()\", \"from __main__ import test5\")print(\"extend \",t5.timeit(number=1000), \"seconds\")# ('concat ', 1.7890608310699463, 'seconds')# ('append ', 0.13796091079711914, 'seconds')# ('comprehension ', 0.05671119689941406, 'seconds')# ('list range ', 0.014147043228149414, 'seconds')# ('extend ', 0.12147043228149414, 'seconds') list range(迭代转化) &lt; comprehension(包含) &lt; extend &lt; append &lt; concat pop操作比较123456789x = range(2000000)pop_zero = Timer(\"x.pop(0)\",\"from __main__ import x\")print(\"pop_zero \",pop_zero.timeit(number=1000), \"seconds\")x = range(2000000)pop_end = Timer(\"x.pop()\",\"from __main__ import x\")print(\"pop_end \",pop_end.timeit(number=1000), \"seconds\")# ('pop_zero ', 1.9101738929748535, 'seconds')# ('pop_end ', 0.00023603439331054688, 'seconds') 测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素 切片赋值123l1 = [1,2,3,4,5,6]l1[0:2] = [7,8,9,10,11] #可以是任意长度&gt;&gt; l1 = [7, 8, 9, 10, 11, 3, 4, 5, 6] !","link":"/2019/08/12/python timeit/"},{"title":"python实现剑指offer1-31题","text":"详细地分析剑指offer1-31题的解题思路，代码及代码注释。 队列队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 对列的添加 insert append 队列的取值 列表[-1] 列表[0] 队列的删除 pop() pop(0) 栈栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 只允许在栈的栈顶来操作。 添加元素用append(push)，称作是进栈，入栈或者压栈 取值列表[-1]，因为它只能从栈顶来取值，相当于取列表的最后一个值，所以用索引-1. 删除元素pop()从后端开始删除。称作是出栈或者退栈。 1. 两个栈实现一个队列：[^本题考点 队列 栈]用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 ……解析： 定义一个类，首先这个类要具备两个属性，一个是压栈，一个是出栈。 因为要两个栈来实现一个队列：进行插入操作的端称为队尾，进行删除操作的端称为队头。 那么如何用：两个栈实现一个队列？ 栈： 先进后出 队列：先进先出 如图所示：队列从一头添加数据，从一头删除数据。 所以我们需要让两个栈 一个栈实现添加数据 ​ 即：self.acceptStack=[]它拥有一个push的方法，用来作为队列的一端的添加数据 功能 用append来实现 ​ self.acceptStack.append(node) 另一个栈实现删除数据： ​ 即：self.outputStack = []它拥有pop 的方法，用来作为队列的另一端的删除数据的功能 用pop 来实现 ​ 但是我们要实现的是队列的先进先出，也就意味着 如果说我们添加数据的栈中添加了一个数据，那么我们另一个删除数据的栈中，也要相应的删除这个数据，所以说这两个栈中的数据的顺序是相反的。 以上的需求我们通过，删除acceptStack栈中的数据，在outputStack中添加这个数据，那么先在acceptStack中删除的数据，就会进入到outputStack的栈底，后在acceptStack中删除的数据，会后进入outputStack，那么它就会先出来。 那么两个栈，这样来合作，就会实现队列的先进先出，如图：1 是先进的（栈1） 那么1 就会先出来（栈2）。 进而实现了 题目的需求。 在pop 的方法中，如果说 self.outputStack是空 没有数据，那么 就给它 while 循环我们的 作为添加数据的栈 acceptStack，删除这个栈中的内容，它会弹出，然后把它添加到 栈2 outputStack 中，它就会有数据，有数据的话就返回 （如果 调用了 删除 数据的这个方法的话）。如果说 做了循环，我们的栈2 outputStack 中还没有数据，就明 acceptStack中，没有数据压入，也就说明这个 队列 没有添加数据，也就不会有删除的数据，所以返回一个None。 1234567891011121314151617181920class Solution: def init(self): #添加数据栈 self.acceptStack=[] #删除数据栈 self.outputStack = [] def push(self, node): #向添加数据的栈中添加数据 self.acceptStack.append(node) def pop(self): #判断删除数据的栈中是否有数据，没有的话，就添加数据，添加数据时，要添加栈1 中删除的数据 if not self.outputStack: while self.acceptStack: self.outputStack.append(self.acceptStack.pop()) #如果有数据的话，就返回 if self.outputStack: return self.outputStack.pop() #如果没有数据，说明没有数据添加进去，也就不需要删除数据，所以返回none else: return None 二分查找法分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？1二分查找法什么情况下用。有序的数组中。首先 肯定是在有序的 数组中的！！！！！ 算法：二分法查找适用于数据量较大时，但是数据需要先排好顺序。主要思想是：（设查找的数组区间为array[low, high]） （1）确定该区间的中间位置K（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：a.array[k]&gt;T 由数组的有序性可知array[k,k+1,……,high]&gt;T;故新的区间为array[low,……，K-1]b.array[k]&lt;T 类似上面查找区间为array[k+1,……，high]。每一次查找与中间值比较，可以确定是否查找成功，不成功当前查找区间将缩小一半，递归查找即可。 时间复杂度为:O(log2n)。 时间复杂度1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)所以T(n)=O(log2n) 2.最好情况查找中间元素O(1)查找的元素即为中间元素（奇数长度数列的正中间，偶数长度数列的中间靠左的元素） 空间复杂度 S(n)=n 二分法代码实现：123456789101112131415161718192021def BinarySearch(array,target): left= 0 right= len(array)-1 while left &lt;= right : #除法没有移位的快 # mid = (left + right)//2 # 101 = 5 =&gt; 10 = 2 #1100 = 12 =&gt; 110 = 6 #一下用了 向右 移一位， 那么上面是解释，它就相当于 除以2 。 mid = (left + right) &gt;&gt; 1 #如果中间的数等于我们要找的数，那么就返回。 if array[mid] == target: return mid #如果说中间的数 &lt; 目标的数，那么就说明，我们要找的数在右侧，所以左侧取值的索引需要改变为中间的索引+1； elif array[mid]&lt; target: left = mid + 1 #如果说中间的数 &gt; 目标的数，那么就说明，我们要找的数在左侧，所以左侧取值的索引需要改变为中间的索引-1； 因为越往左索引值越小 else: right = mid-1 return None 把数组内的数据一分为二，然后计算出中间数据的 索引值。 数组中 最左侧的 索引为 0 ；最右侧的索引为 len(array)-1，数组的长度 减 1 就是 最后一个数的索引。 先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，如果相等那么就返回，如果不相等，那么就继续判断。如果说我们找到的 array[mid] 小于 target 这个数; 那么 就说明 我们要查找的数在右侧的一半数据中，那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。如果说我们找到的 array[mid] 大于 target 这个数 ，那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。 以上为二分法的原理。 2. 旋转数组的最小数字 [^本题考点 查找]把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415161718192021class Solution: def minNumberInRotateArray(self, rotateArray): #最小值 一定比前面的要小 # 二分法查找数据 找左右的方法是： #右边的值大于中值，就说明最小值在左边 if not rotateArray: return 0 left = 0 right = len(rotateArray) - 1 while left &lt;= right: mid = (left + right) &gt;&gt; 1 #如果说中间的数的上一个数 &gt; 中间数，那么就说明，我们要找的数就是这个中间的数，返回这个数。 if rotateArray[mid - 1] &gt; rotateArray[mid]: return rotateArray[mid] #如果说中间的数 &lt; 中间数的上一个数，那么就说明，我们要找的数在二分法的左侧，所以右侧取值的索引需要改变为中间的索引-1；因为越往左索引值越小 elif rotateArray[mid] &lt; rotateArray[right]: right = mid - 1 #否则就说明，我们要找的数在二分法的右侧，所以左侧取值的索引需要改变为中间的索引+1；因为越往右索引值越小 else: left = mid + 1 return 0 什么叫做数组？所谓数组，是有序的元素序列。 [1] 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。 [1] 这些无序排列的同类数据元素的集合称为数组。 例如： int (32 位) int int 这三个就会组成一个数组，类型相同的变量。a(0) a(1) a(2) 数组与python中的 列表比较相似， 用索引去查找。数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。数组还和元组比较像，元组是初始化后，长度指定了就不可以变。但是元组在初始化时给的值，确定了以后就不可以变了。所以可以理解为数组与list 列表很相似。 3.在二维数组中的查找[^本题考点 查找]在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: # array 二维列表 def Find(self, target, array): # write code here # 1 2 3 4 # 3 4 5 6 # 4 6 8 10 # 9 11 13 15 #时间复杂度 o(n**n) # for i in range(len(array)): # for j in range(len(array[i])): # if target == array[i][j]: # return True # return False #时间复杂度 #O（n) #这个二维数组的长度是多少，也就是说这个数组有几行； row_count = len(array) i = 0 #这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列 column_count = len(array[0]) #给j 一个值，就是数组列数的值-1，即为j 的最大值。 j = len(array[0])-1 #循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。 #我们要取到每行的最后一个数，即对应的那一列的第一个数，来与我们的目标数来对比，这个数是这一行的最大数，是这一列的最小数。 while i &lt; row_count and j &gt;= 0: #根据两个索引下标可以取到 对应的在数组中的值 value = array[i][j] #如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回就好。 if value == target: return True #如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，给它减-1，找前一列的数做比较 elif target &lt; value: j -= 1 #如果说取到的值 &lt; 我们的目标值。那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较 else: i += 1 return False 4.包含min 函数的栈[^本题考点 栈]定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#第一种方法：考虑两个栈的长度相同，添加一个，另一个栈也会删除一个class Solution: #给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈 def __init__(self): self.stack = [] self.minValue = [] #给栈中推进去数值，推进去元素node，添加函数 def push(self, node): self.stack.append(node) #如果最小值列表里有值 if self.minValue: #如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小， # 那么就放进最小值列表中； if self.minValue[-1] &gt; node: self.minValue.append(node) #如果列表里面的最后一个值，小于node值，那么就说明node这个值大；那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致； else: self.minValue.append(self.minValue[-1]) #如果最小值列表里面没有值，就在最小值列表里添加node else: self.minValue.append(node) #给栈中做删除操作 def pop(self): #如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值 if self.stack == []: return None #栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个 self.minValue.pop() #有值得话，就需要删除一个，删除做pop 操作；返回我们删除的那个数 return self.stack.pop() #栈顶 def top(self): #如果栈里没有数值的话，就返回一个空 if not self.stack: return None #否则栈里有数，那么就返回栈顶的那个数 return self.stack[-1] #取出最小值，那么就是我们minvalue 中的最后一个值为最小值 def min(self): #如果为空的话，就说明没有值，返回none if self.minValue == []: return None return self.minValue[-1] #第二种方法：不考虑两个栈的长度必须要保持一致，那么在栈删除值的时候，判断一下删除的值，是不是与装最小值的栈里的最后一个最小值相同，如果相同就删掉，如果不同，就不删除。 class Solution: def __init__(self): self.stack = [] self.minValue = [] def push(self, node): # write code here self.stack.append(node) if self.minValue: #如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小， # 那么就放进最小值列表中； if self.minValue[-1] &gt; node: self.minValue.append(node) #最后一个值不大于node这个值得话；不做操作，不需要把它两个做的长度一致 else: self.minValue.append(node) def pop(self): if self.stack == []: return None # write code here #删除的时候，做个判断，它是不是与栈里面的最后一个值，与我们最小值栈里的最后一个值相等，那么就删除双方的这个值 if self.stack[-1] == self.minValue[-1]: self.minValue.pop() return self.stack.pop() #如果不等的话，就只要删除栈 里最后一个值就可以 else: return self.stack.pop() def top(self): if self.stack == []: return None return self.stack[-1] # write code here def min(self): if self.minValue == []: return None return self.minValue[-1] 5.替换空格[^本题考点 字符串]请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): #第一种：python中自带的一个替换的函数 # return s.replace(' ','%20') #第二种遍历来替换字符串中的空格 strlen = len(s) #借助第三方的列表来实现时间的节省。 aaa = [] for i in range(strlen): #如果是空格的话那就替换为%20. if s[i] == \" \": #if s[i] isspace: aaa.append(\"%\") aaa.append(\"2\") aaa.append(\"0\") else: aaa.append(s[i]) return \"\".join(aaa) 6.斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#第一种方法：下面是使用了for循环，class Solution: def Fibonacci(self, n): # 如果是按照递归来写的话， 时间复杂度就是随着n的变化 增长率是 2^n ''' 递归实现 # n = 0 f(0) = 0 if n == 0: return 0 # n = 1 f(1) = 1 if n == 1: return 1 # if n &gt; 1 f(n) = f(n-1) + f(n-2) if n &gt; 1: num = self.Fibonacci(n-1) + self.Fibonacci(n-2) return num return None ''' # n = 0 f(0) = 0 if n == 0: return 0 # n = 1 f(1) = 1 if n == 1: return 1 a = 1 b = 0 # if n &gt; 1 f(n) = f(n-1) + f(n-2) # h = a + b # 当 n = 2 h = 0 + 1 ret = 0 #三个变量，互相转换 来实现 for i in range(0, n - 1): ret = a + b b = a a = ret return ret#第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n class Solution: def Fibonacci(self, n): #初始列表值 为 0 1 第三项为 0+1 = 1； res = [0, 1, 1] #临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。 while len(res) &lt;= n: #取出列表的最后两项，然后求和，并添加到列表中。 res.append(res[-1] + res[-2]) return res[n] 7.青蛙跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 1234567891011121314151617181920212223242526272829303132333435363738394041\"\"\"1 (1)2 (11,2)3 (12,21,111)4 (1111,22,112,121,211)5 (11111,221,212,122,1121,2111,1112,1211)6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)\"\"\"class Solution: def jumpFloor(self, number): # write code here #第一种方法： res = [1, 1, 2] while len(res) &lt;= number: res.append(res[-1] + res[-2]) return res[number] a = 1 b = 1 for i in range(0,number): a,b = b,a+b return a if number &lt; 1: return 0 if number ==1: return 1 if number == 2: return 2 ret = 0 a = 1 b = 2 for i in range(3,number+1): ret = a+b a = b b = ret return ret 8.变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1234567891011121314151617181920212223242526272829303132333435\"\"\"1 (1)2 (11,2)3 (111,21,3,12)4 (1111,22,13,31,211,112,121,4)n 2^(n-1)f(n) = f(n-1) + f(n-2) + .... + f(1)f(n-1) = f(n-2) + .... + f(1)f(n) = 2f(n-1) n &gt; 1f(1) = 1 n = 1\"\"\"# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here #第一种方法： # return pow(2,number-1) #第二种方法： # return 2 ** (number - 1) #第三种方法： if number == 0: return 0 if number ==1 : return 1 a = 1 ret = 1 for i in range(2,number+1): a,ret = ret,2*ret return ret 9. 调整数组顺序使奇数位于偶数前面 [^本题知识点 数组]输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516171819class Solution: def reOrderArray(self, array): # write code here #时间复杂度是o(n) #空间复杂度o(n) # ret = [] # for i in array: # if i % 2 == 1: # ret.append(i) # for i in array: # if i % 2 == 0: # ret.append(i) # return ret #用了冒泡排序的原理，判断奇偶数，如果一个是偶数而且下一个是奇数，那么两个就互换位置。 for i in range(len(array)): for j in range(len(array) - i - 1): if array[j] % 2 == 0 and array[j + 1] % 2 == 1: array[j], array[j + 1] = array[j + 1], array[j] return array 知识点：冒泡排序法12345678910def bubbleSort(array): #一共 需要 n 次 的循环，每一个都要找到没排好序的最大值。 for i in range(len(array)): #将没有排好序的数组 找最大值，并一直将最大值换到最顶端。 for j in range(len(array)-i-1): #判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。 if array[j] &gt; array[j+1]: array[j],array[j+1] = array[j+1],array[j] return array 10.栈的压入，弹出序列 [^本题考点 栈]输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 12345678910111213141516171819202122232425262728293031323334class Solution: def IsPopOrder(self, pushV, popV): # write code here #首先要先有一个栈，列表 #按照 pushV 的方式去压入栈， # 弹出的时候是需要循环判断是否需要弹出 #判断是否需要弹出的时机，刚刚压入过后就判断 #判断需要弹出的情况的条件，压入栈的顶部和弹出栈的顶部数据相等 #先判断pushV 这个栈里是否为空，如果是空的话返回none，或者说这两个序列的长度不相同。那也返回none。 if pushV == [] or len(pushV ) != len(popV): return None #首先有个栈 stack = [] #定义一个变量，它作为弹出序列的索引存在。 index = 0 #遍历 pushV 的这个列表里的元素，并把它每个都添加进stack 这个列表中 for item in pushV: stack.append(item) #做判断 1，stack 里有元素 并且 stack里的最后一个元素 等于 popV 这个序列里 第一个元素，那么就进去这个循环，然后把stack里的这个元素删掉，这样下次还会添加新的元素，然后再和 popV 里的下一个元素 做判断，所以这个时候 index 这个索引值就要发生变化了，这个时候比较的是 它的下一个值。往右移动一位。 while stack and stack[-1] == popV[index]: stack.pop() index += 1 \"\"\" if stack == []: return True else: return False \"\"\" #最后 直到 把 pushV 里的元素都遍历完，然后stack内的元素都比较完，并都删除完，就返回True，如果说 它不为空：说明 pushV 里有的元素 是popV 中所没有的，这个时候就说明他们不相等，那么这个情况，就需要返回 False。 #以下代码与以上代码 共同实现的相同的功能，但是下面的代码相对来说等 “装B” 一点。节省代码空间。 return True if stack == [] else False 知识点链表：链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 数组 就是连续的 同一个类型的 元素，而且必须是固定的长度。 如果我们想要非固定的长度来存储数据。这个时候就出现了链表。 11. 从栈尾到栈头打印链表 [^本题知识点 链表]输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here # pointer 指针 temporary临时数据;node 结点 #给一个 arraylist 空列表，然后向这个里面压入数据，来输出 这个链表值 的一个从尾到头 的顺序值。 ret = [] #把 listNode 这个链表 传给一个 变量 pTemp = listNode #当这个变量 存在时 有值时： while pTemp: #使用 insert 的原因是：insert 可以在指定位置之前插入元素，列表.insert(索引，值) #在空列表中起始位置，插入 pTemp的第一个值，然后 给pTemp 赋值 为 pTemp.next （下一个值） ret.insert(0, pTemp.val) #更改 指针，使指针指向下一个 元素 pTemp = pTemp.next #最后返回我们 这个 插入值的 列表 return ret 如图所示：打印出 3 2 1 即为我们的目标。 12.链表中的倒数第k个结点[^本题考点 链表]输入一个链表，输出该链表中倒数第k个结点。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): # write code here # k 如果 比我们的链表的长度还要大的话，我们直接返回None # k 如果小于链表的长度，我们可以定义两个变量，这两个变量中间间隔k #用两个指针做一个尺子，然后让尺子在跳跳，然后就会找到 第k 个结点 #起始位置 第一个和第二个指针 都是从头开始的。 firstPoint = head secondPoint = head #首先让一个指针先开始移动，那么就是遍历我们的k 值，让我们的 第一个指针移动 k 步。 for i in range(k): #如果第一个指针为空的话，那么说明我们的k值为空，那么我们的这个链表就为空。 if firstPoint == None: return None #第一个指针 移动一步 firstPoint = firstPoint.next #当 第一个指针不为空的时候， while firstPoint != None: #移动尺子，移动距离为 k 的长度， 直到 第一个指针点 为空的时候 ，就到了 这个链表的结尾，此时就返回 第二个指针 那么就为 倒数第 k 个结点。 firstPoint = firstPoint.next secondPoint = secondPoint.next return secondPoint 如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。 13.反转链表[^本题考点 链表]输入一个链表，反转链表后，输出新链表的表头。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#第一种方法：\"\"\" pHead始终指向要反转的结点last 指向反转后的首结点每反转一个结点，把pHead结点的下一个结点指向last,last指向pHead成为反转后首结点,再把pHead向前移动一个结点直至None结束\"\"\"# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): #首先判断这个链表里是否只有一个结点，只有一个结点那么它就不需要发生变化，它第一个结点指向的指针就为 none # 这个时候就直接返回这个 pHead if not pHead or not pHead.next: return pHead #首先要明白 反转过后，第一个数值的指针的结点指向的是none 也就是一个指向反转后的首结点 为none last = None #当 要反转的结点 pHead 存在的时候 while pHead: #先找到第一个元素的结点指向的元素，赋值给一个临时变量 temp = pHead.next \"\"\" 本来一个元素的结点 是要指向它的下一个 元素的 . 反转后 就是 这个元素 要指向它的 上一个 元素 . \"\"\" #然后第一次循环 把这第一个元素的结点 改为 none last 第一个值 是 none (此时还没有发生改变的last) # 之后循环 就是 每 反转一个结点 把pHead结点的下一个结点指向last, pHead.next = last #下一步 是把 pHead 这个 元素的 赋值给last # last指向pHead成为反转后首结点, last = pHead # 再把pHead向前移动一个结点直至None结束 pHead = temp return last\"\"\"反转需要两步 ，第一步找到它的 结点，第二步改变结点就可以了；之后需要 把结点 赋值为 这个元素的 本身 ；循环： 找到 元素结点指向的元素，目标是 让元素结点指向的元素 改为 自己本身。\"\"\"#第二种方法：\"\"\"1 将现有的头换成尾，尾部的next为空2 将从第二个node开始，循环将next指向前一个3 需要一直有一个指针指向还没有反转的链表的头部\"\"\"class Solution2: # 返回ListNode def ReverseList(self, pHead): #判断是否为空值，没有元素 if pHead == None: return None #判断是否只有一个元素 if pHead.next == None: return pHead #左边指针为 头 第一个 指针 leftPointer = pHead #中间 的指针 为 第二个指针 midPointer = pHead.next #右边的指针 为 指向 中间 指针后的 所有的元素 rightPointer = midPointer.next #左边的指针为 起始 的 元素， 反转后 它的next 为 None； leftPointer.next = None #循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。 while rightPointer: #中间指针指向的为上一个 元素 即 leftPointer midPointer.next = leftPointer #三个指针开始往右移。每次移一个。 #左边指针 往右移一个 就是中间指针的位置 leftPointer = midPointer #中间指针 往 右 移 一个，就时 右边指针的位置 midPointer = rightPointer #右边指针往右移 一个 ，就时 右边指针的下一个。 rightPointer = rightPointer.next #当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。 midPointer.next = leftPointer #最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。 return midPointer 如图所示： 14.复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#第一种方法：# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here #判断当pHead 为空值的时候 返回的是none if pHead == None: return None # 复制一个一样的node， 并且添加到之前的链表的每一个node后面 pTmp = pHead while pTmp: #把第一个 A 的值 赋给 node 为A‘ node = RandomListNode(pTmp.label) #此时 node A' 的结点指向的是 原来A 的结点指向的 值 node.next = pTmp.next #将原来A 的结点指向的值 改为 A’ pTmp.next = node #将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素 pTmp = node.next # 实现新建的node的random的指向 pTmp = pHead while pTmp: #如果现在操作的这个指针的元素，存在一个 random 的结点 if pTmp.random: #那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。 pTmp.next.random = pTmp.random.next #建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。 #当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。 pTmp = pTmp.next.next # 断开原来的node 和 新的node 之间的链接 #最后 为断开 链接 的操作 pTmp = pHead #复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘ newHead = pHead.next #复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘ pNewTmp = pHead.next while pTmp: #print(pTmp.label) #将旧链表 A 的指向结点 改为 A‘ 的指向的下一个 的B。 pTmp.next = pTmp.next.next #如果新的 链表 的元素有指向的下一个的指针 if pNewTmp.next: #那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’ pNewTmp.next = pNewTmp.next.next #然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘ pNewTmp = pNewTmp.next #上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B pTmp = pTmp.next #如此循环下去，改变所有的 新链表，旧链表的指向。 #最后返回这个复制好的新链表。 return newHead #第二种方法： import copy chead=copy.deepcopy(pHead) return chead 15.两个链表之间的第一个公共结点输入两个链表，找出它们的第一个公共结点 如图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here pTmp1 = pHead1 pTmp2 = pHead2 #当链表1 和链表2 同时存在的时候 while pTmp1 and pTmp2: #当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2 if pTmp1 == pTmp2: return pTmp1 #移动指针的位置，两个同时移动， pTmp1 = pTmp1.next pTmp2 = pTmp2.next #第一个参数给比较短的那个链表的值 #第二个参数给比较长的链表的值 #第三个参数是比较短的那个链表头 #第四个参数是比较长的那个链表头 def findEqual(longPointer, shorPointer, longHead, shortHead): k = 0 # 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。 while longPointer: longPointer = longPointer.next k += 1 #然后： # 先让长的那个去走k步 longPointer = longHead shortPointer = shortHead for i in range(k): longPointer = longPointer.next #长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。 while longPointer != shortPointer: longPointer = longPointer.next shortPointer = shortPointer.next return shortPointer #如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。 if pTmp1: return findEqual(pTmp1,pTmp2,pHead1,pHead2) # k = 0 # #寻找出链表长度之间的差值 # while pTmp1: # pTmp1 = pTmp1.next # k += 1 # #先让长的那个去走k步 # pTmp2 = pHead2 # pTmp1 = pHead1 # for i in range(k): # pTmp1=pTmp1.next #长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。 # while pTmp1 != pTmp2: # pTmp1 = pTmp1.next # pTmp2 = pTmp2.next # return pTmp1 if pTmp2: return findEqual(pTmp1, pTmp2, pHead1, pHead2) # k = 0 # # 寻找出链表长度之间的差值 # while pTmp2: # pTmp2 = pTmp2.next # k += 1 # # 先让长的那个去走k步 # pTmp2 = pHead2 # pTmp1 = pHead1 # for i in range(k): # pTmp2 = pTmp2.next #长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。 # while pTmp1 != pTmp2: # pTmp1 = pTmp1.next # pTmp2 = pTmp2.next # return pTmp2 16.合并两个排序的链表 [^本题考点 链表]输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 如图：为两个递增的链表 如下图，合并成一个单调不减链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#第一种方法：\"\"\"比较两个链表的首结点，哪个小的的结点则合并到第三个链表尾结点，并向前移动一个结点。步骤一结果会有一个链表先遍历结束，或者没有第三个链表尾结点指向剩余未遍历结束的链表返回第三个链表首结点\"\"\"# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here head = ListNode(0) tmp = head while pHead1 is not None and pHead2 is not None: if pHead1.val &lt;= pHead2.val: tmp.next = pHead1 pHead1 = pHead1.next else: tmp.next = pHead2 pHead2 = pHead2.next tmp = tmp.next if pHead1 is None: tmp.next = pHead2 elif pHead2 is None: tmp.next = pHead1 return head.next #第二种方法：class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here #首先判断两个链表是不是为空。 if pHead1 == None: return pHead2 if pHead2 == None: return pHead1 #比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。 newHead = pHead1 if pHead1.val &lt; pHead2.val else pHead2 pTmp1 = pHead1 pTmp2 = pHead2 #判断 如果新表头 是 表1 的头的话 那么 新表头 if newHead == pTmp1: pTmp1 = pTmp1.next else: pTmp2 = pTmp2.next # previousPointer = newHead while pTmp1 and pTmp2: if pTmp1.val &lt; pTmp2.val: previousPointer.next = pTmp1 previousPointer = pTmp1 pTmp1 = pTmp1.next else: previousPointer.next = pTmp2 previousPointer = pTmp2 pTmp2 = pTmp2.next if pTmp1 == None: previousPointer.next = pTmp2 else: previousPointer.next = pTmp1 return newHead 17.圆圈中最后剩下的数 [^本题考点 模拟]每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 思路分析： 这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。 链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n). 链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序 (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头 开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1). 这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第 m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。 链表3：这个图 是 以 m 为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1) 如果说我们想由 链表3 得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 + m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。 但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余： (iii+m)%n 我们一共是 n 个值，从0-(n-1); f(n-1) = iii 所以 f(n) = f `(n-1) = (iii+m)%n 所以 f(n) = (f(n-1)+m) 那么这个通项表达式我们就找到了，再去编写代码。 123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here #通过推导公式可得 f(n) = (f(n-1)+m)%n #首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1. if n &lt; 1 or m &lt; 1: return -1 #只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。 if n==1: return 0 value = 0 #时间复杂度 o(n) #从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 for index in range(2,n+1): #现在数到的 m-1 这个值 的索引。对应上上面的公式。 currentValue = (value+m) % index #把找到的这个下标值 赋值给 value value = currentValue #返回编号 return value 18.链表中环的入口点 [^本题知识点 链表]给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def EntryNodeOfLoop(self, pHead): # write code here #首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。 #循环跳 #要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。 if pHead == None: return None #定义两个指针，一个快的一个慢的。 fastPointer = pHead slowPointer = pHead #当快指针存在时，而且快指针的结点指向的下一个也存在 while fastPointer and fastPointer.next : #那么让快指针走两步 fastPointer = fastPointer.next.next #让慢指针走一步 slowPointer = slowPointer.next #如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break if fastPointer == slowPointer: break #如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。 if fastPointer == None or fastPointer.next == None: return None #如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度 #假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d # 那么 L = s + d #假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少 # fast 走的长度 就是 ( m + d ) * n + d + s = 2 L #带入 ( m + d ) * n + d + s = 2 （s + d ） # s = m + (n-1)(m+d) #有环的话，那么就让快指针从头开始走，这次一次走一步， fastPointer = pHead #此时慢指针还在环里走着，没有走到结点 while fastPointer != slowPointer: fastPointer = fastPointer.next slowPointer = slowPointer.next #当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。 return fastPointer 定义： 假设 slow 走了 L 步，那么 fast 就走了 2L 步。 我们 链表的头部 到 链表的环的入口结点处 的距离是 S 那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 链表的环中，慢指针走过的距离是d，那么没走过的距离是M。 我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。 那么 L = s + d 2L = 2(s+d) = n*(m + d) + d + s 由上面公式 推导出 n(m+d) = s + d 得到：s = n(m+d) -d； s = nm + (n-1)(d)s = m + (n-1)(m+d) 19.二进制中的1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示 知识点:补码特性： 1、一个负整数（或原码）与其补数（或补码）相加，和为模。 2、对一个整数的补码再求补码，等于该整数自身。 3、补码的正零与负零表示方法相同 按位取反 ~~，用法只有一个那就是按位取反，需要注意的是： ~的按位取反，包括符号位 正数各位取反变为负数，显示时转化为其补码 负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位去反 1. ~55 的二进制为 0101， ~5 （1）各位取反，1010 （2）变为负数，转化为其补码形式（符号位保持不变），各位取反 1（1101），再加1（1110），也即 -6 12&gt;&gt; ~5&gt;&gt; -6 2. ~(-5)-5 因为是负数，存储时存储的是其补码： -5 的补码是：1011， ~(-5)将其各位取反（包括符号位），也即 0100（4） 12&gt;&gt; ~(-5)&gt;&gt; 4 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-#第一种：class Solution: def NumberOf1(self, n): # write code here #补码：正数不变，负数是它的正数的反码 + 1 # -2 补码： -2 的 1 0000.。。000010， # 1 1111.。。111101 + 1 #-2 的补码就是 1 1111.。。111110 #把输入的正数n转化为二进制的数，并把0b 替换掉，计算1的数量，如果输入的值不是正数的话 #一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。 #那么就是 2 的32 次方 然后 + n 这是在取一个负数的补码 就相当于 n &amp; 0xffffffff #然后计算 这个数里面 1 的 数量 return bin(n).replace(\"0b\", \"\").count(\"1\") if n &gt;= 0 else bin(2 ** 32 + n).replace(\"0b\", \"\").count(\"1\") #第二种：# -*- coding:utf-8 -*-class Solution2: def NumberOf1(self, n): # write code here # 1 出现的次数为0 次 count = 0 #判断 这个数 n 是不是负数，如果是负数的话 求其补码： if n &lt; 0: n = n &amp; 0xffffffff #如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1. while n: count += 1 #把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。 n = (n - 1) &amp; n return count \"\"\" 例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011. 那把 这个整数 和它 减去1 的结果 做一个按位 与运算，相当于 把 最右边的 1 变成 0,。 1011 和 1100 做 按位与 运算 1100 &amp; 1011 结果为 1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果 1000. \"\"\" 20.不用加减乘除做加法[^本题考点 按位运算]写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 分析： 对于数字运算，如果说四则运算不能用的话，那么我们只能用位运算来做了。 我们以 5 + 17 为例 结果为 22，那么 22 的计算结果，我们可以分为三步 来进行： ​ 第一步： 只做各位相加不进位 也就是说 没一位上的数字 相应的来相加 但是不进位，那么 5 + 7 为 12 ​ 个位数 5 和 7 相加 不进位 是2 十位是0 和1 相加 为 1 ​ 第二步： 5 + 7 中有进位，进位值 是10 ; ​ 第三步： 把前面两个结果 加起来： 12 + 10 = 22 以上为我们用十进制计算的 策略，那么 我们用于位运算中是不是也合适，我们来举个栗子： 还是以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001； 第一步：各位相加 但不进位： 101 + 10001 = 10110 不进位的话 结果为 10100 （最后一位两个数都是1，相加的结果需要进位，但是这一位不进位，意味着结果仍然是0） 第二步： 记下进位，它只在最后一位相加时产生了一个进位。 第三步： 把前面两个结果相加，得到的结果是 10110. 那么现在我们把前面的 二进制的加法用位运算来替代的话 第一步的 求 和 运算就是 不考虑 进位的话，对每一位来相加，0 和0 1 和1 的结果都是0,0+1，或者1+0 的结果 都是1；那么我们会看出它与我们学过的异或运算相同，就是相同为假，不同为真，所以叫 异 或 XOR 。 第二步： 对0 加 0、1加0、0加1 而言，都不会产生进位，只有1+1 的时候，会产生一个进位。此时 我们可以想象成两个数 先做了一个 位 与 &amp; 运算，然后再向 左移 一位。只有两个数是1 的时候，位与 &amp; 得到的结果是 1，其余的都是0。 第三步：把前面两个步骤的结果再相加，然后在继续判断是否有进位，直到没有进位为止，那么此时的相加的过程，依然是重复前面的两步，直到不产生进位为止。 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): #第一种代码：循环。简洁但是原理相同，那么我们以下面第二段代码为例；来解析。 # while (num2): # num1, num2 = (num1 ^ num2) &amp; 0xFFFFFFFF, ((num1 &amp; num2) &lt;&lt; 1) &amp; 0xFFFFFFFF # return num1 if num1 &lt;= 0x7FFFFFFF else ~(num1 ^ 0xFFFFFFFF) #第二种代码： #首先两个数做 一个 异或 运算^ 那就是 在不进位的情况下，让两个相加 求和。 xorNum = num1 ^ num2 #让两个数 做 位与 操作，然后再向 左 移 一位，得到它 向前进位的值。 andNum = (num1 &amp; num2) &lt;&lt; 1 #判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。 while andNum != 0: #那么我们就继续上面的操作。但是这次的 数值 改为上次的两个结果， #一个 是异或的结果，一个是 与 操作 &amp; 以后 左移一位的 结果。 tmp1 = xorNum ^ andNum tmp2 = (xorNum &amp; andNum) &lt;&lt; 1 #因为如果这个数为负数的话，那么负数 左移 一位与正数 不同，负数 是数值变小，正数 数值变大 #如果是正数的话那么这一步就 不变，如果是负数的话，这一步就对负数来起作用。 #对于python来说 负数的 二进制 可能会有无数个1，我们用这个方法让它变成一个可数的数字长度。 tmp1 = tmp1 &amp; 0xffffffff xorNum = tmp1 andNum = tmp2 #一个负整数（或原码）与其补数（或补码）相加，和为模。 0xffffffff # ~(xorNum ^ 0xFFFFFFFF) 这个是 异或数 与 模 来 异或，最后 按位 取反 来求得 负数的补码。 return xorNum if xorNum &lt;= 0x7ffffff else ~(xorNum ^ 0xFFFFFFFF) 21.数组中出现次数超过一半的数字[^本题考点 数组]数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路：抵消掉 遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。 首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。 我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here #dict [key] = count #o(n) 空间复杂度为O(n) #第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。 numsCount = {} numLen = len(numbers) for num in numbers: if num in numsCount: numsCount[num] += 1 else: numsCount[num] = 1 #如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2. if numsCount[num] &gt; (numLen &gt;&gt; 1): return num return 0 #想要空间复杂度为O（1），时间复杂度为o(n)#第二种： #定义变量 上次出现的数字为0 last = 0 #上次出现的数字的数量为0 lastCount = 0 #遍历数组中的数字 for num in numbers: #如果说这个数字出现的次数为0了。 if lastCount == 0: #那么就把上次出现的数字，变为需要保存的那个数字。 last = num #并把次数设置为1 次，出现了这一次。 lastCount = 1 else: #否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1. if num == last: lastCount += 1 #如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1； else: lastCount -= 1 #如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉 if lastCount == 0: return 0 #否则的话，就说明 数组里面 留下了没有抵消掉的数 else: #这种情况是last可能是大于一半的数字 #这个时候把 记录数字次数的变量 计数 为0 lastCount = 0 #遍历数组中的数 for num in numbers: #如果这个数与我们记录的数相等的话 if num == last: #让这个计数加1 lastCount += 1 #最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0. if lastCount &gt; (len(numbers)&gt;&gt; 1): return last return 0 22.数组中只出现一次的数字[^数组]一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here #如果两个数相同那么两个数的异或操作为0 #数组的长度如果小于2，那么就就不会有数字出现了偶数次。 if len(array) &lt; 2: return None #变量赋值 两个数的异或为none twoNumXor = None #遍历 数组中的数字 for num in array: #判断 如果 两个数的数字异或的结果为0 的话， if twoNumXor == None: #那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。 twoNumXor = num #如果数 这个数不为 空 的话 else: #那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。 twoNumXor = twoNumXor ^ num #变量 计数 为 0 count = 0 #当异或的 结果 为偶数时 while twoNumXor % 2 == 0 : #那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。 twoNumXor = twoNumXor &gt;&gt; 1 # 右移以为 相当于 除以2 count += 1 #以上是用来计数 判断 这个 二进制数中 第一个1 是在哪一位上。 #我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1 mask = 1 &lt;&lt; count #向左 移 位 count 位。 #为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。 firstNum = None secondNum = None for num in array: if mask &amp; num == 0: if firstNum == None: firstNum = num else: firstNum = firstNum ^ num else: if secondNum == None: secondNum = num else: secondNum = secondNum ^ num return firstNum,secondNum 23.整数中1出现的次数[^本题考点 数组]求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。 那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。 若 以上 栗子 中的 十万位上的 0 那一位 为 数字1 的话，有多少种 可能？ ​ 首先 直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有 0-3458 个数 那么就一共是 3459 中可能性。 ​ 那么十万位 后面 出现1 的情况有多少种 可能性 ？ ​ 0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说 后面 为的可能性是 10^5. 那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。 ​ 接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？ 如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共34591种情况，后面 是一共 4 位，那么就有 10^4种情况。 那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。 ​ 我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？ 如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是 3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有 3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。 分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here #循环的出口是 highValue = 0 #我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。 # 一开始 精准度为1.高位低位中位 先赋值为1. preceise = 1 highValue = 1 lowValue = 1 midValue =1 #计数 后面的位数。 count = 0 #计数 1 的次数和 sumNum = 0 #循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。 while highValue != 0: #高位 先将这个数 除以10 得到高位 highValue = n // (preceise * 10) #中位 先将这个数 与 10 取余。 midValue = (n // preceise)%10 #低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0. lowValue = n % preceise #每遍历一次 向右移一位，那么就是说 精准度要乘以10. preceise *= 10 #如果这个数是0 的话， if midValue == 0: #那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0， num = (highValue)* pow(10,count) #如果这个数 大于1 的话， elif midValue &gt; 1: #那么它 就是 最高位加1 乘以 10^后面的位数 次方， num = (highValue+1)*pow(10,count) else: #否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。 num = highValue*pow(10,count)+(lowValue+1) #最后 我们1 出现的 次数 就是这 三个 num 的和，。 sumNum += num #没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。 count += 1 #最后返回这个 次数和。 return sumNum 24.丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？ 因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。 1234567891011121314151617181920212223242526272829class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt; 1: return None #死循环，找丑数 #判断一个数是不是丑数，先循环除以2，直到不能整除， #循环除以3 直到不能整除，循环除以5 直到不能整除 #这时如果剩余的值是1 我们就说它是丑数 #其他情况就都不是丑数 def isUglyNumber(num): while num % 2 == 0: num = num //2 while num % 3 == 0: num = num //3 while num % 5 == 0: num = num //5 if num == 1: return True else: return False count = 0 num = 1 while True: if isUglyNumber(num): count += 1 if count == index: return num num += 1 第二种方法分析: 我们可以保存已经找到的丑数，然后 用空间环时间 来 找出丑数。 如何用空间换时间？ 我们找一种，只需要计算丑数的办法,根据上面丑数的定义，我们可以知道，丑数应该是另一个丑数 乘以 2,3，或者5 的结果（1除外）。因此我们 可以创建一个 列表，里面的数字是排好序的 丑数，每个丑数都是前面的丑数乘以2,3，或者5得到的。 那么我们就可以在一个列表中，给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，第一个丑数为1，那么我们在这个列表的起始位置 设置三个指针，这三个指针代表的值 分别为2,3,5.又由于这个列表中的所有的丑数 是有序的，从小到大排列的，那么我们在每次 给一个丑数 乘以 2,3,5 以后要与前面的丑数比较大小，然后在根据大小值 来放入列表中。由于一开始第一个丑数是1，那么 1 2 得到的是2,13 得到的是3，1 乘以5 得到的是5，那么三个数中比较大小，最小的是 1 乘以2，那么 肯定第一个先放置的是2，然后是 2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，下一个 是 2 乘以3 是6,6 与 5 和4 比较大小 最小的是4，以此类推，那么现在的到的丑数的顺序就是1,2,3,4.。。。。。 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def nthUglyNumber(self, index): #首先判断 要找的 丑数 是不是第0个 或者是负数，如果是的话，那么就返回0 if index &lt;= 0: return 0 #然后判断要找的丑数 是不是第一个，如果是第一个，那么就返回1. if index == 1: return 1 #在丑数 这个列表中 给出第一个丑数是1 numbers = [1] #在列表的 一开始 设置三个 指针，也就是 三个指针的 索引位置是0， two, three, five = 0, 0, 0 #丑数的个数 起始为 1 count = 1 #循环 当丑数的个数不等于我们要找到 那第 index 个 丑数时，就循环，等于的时候就跳出循环。 while count != index : #给列表中的 2,3,5 这三个指针所在位置的 丑数 分别 乘以2,3,5 n2, n3, n5 = numbers[two] * 2, numbers[three] * 3, numbers[five] * 5 #比较这三个丑数的大小 minValue = min(n2, n3, n5) #在丑数列表中，把三个中最小的那个 放进去。 numbers.append(minValue) #每放进去一个，丑数的数量就加1 count += 1 #这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位 if minValue == n2: two += 1 #如果是 3 那个指针的话，那么3 这个指针就移一位。 if minValue == n3: three += 1 #如果是 5 那个指针的话，那么5这个指针就移一位。 if minValue == n5: five += 1 #最后输出这个丑数列表中的 最后一位，那么就是我们的计数的丑数的个数 -1，就是最后一个丑数的索引值。 return numbers[count-1] 树的知识点：什么叫做树？树状图是一种数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树； 叶节点没有子节点，根节点没有父节点。 什么是二叉树？每个节点最多含有两个子树的树称为二叉树。下图就是一个二叉树。 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点 二叉树的遍历：遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。 设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class treeNode(object): def __init__(self,x): self.val = x self.left = None self.right = None#1. 深度优先#2. 广度优先#对于深度优先来说：\"\"\"1 先序遍历 先打印根 1,2,4,5,3,6,8,72 中序遍历 先打印左侧的叶子节点 4，再输出 中节点 2 ； 4 2 5 1 6 8 3 7 3 先序遍历 输出顺序 4 5 2 8 6 7 3 1注意： 先序 中序 后序 都是对应于根节点来说的，左右节点都是先左后右\"\"\"#递归def preOrderRecusive(root): if root == None: return None print(root.val) preOrderRecusive(root.left) preOrderRecusive(root.right)def midOrderRecusive(root): if root == None: return None midOrderRecusive(root.left) print(root.val) midOrderRecusive(root.right)def laterOrderRecusive(root): if root == None: return None laterOrderRecusive(root.left) laterOrderRecusive(root.right) print(root.val)#非递归的形式 去遍历数#递归和循环是可以互相转换的\"\"\"1 先根遍历 先访问根节点，再访问左子节点，最后访问右子节点2 中根遍历 先访问左子节点，再访问根节点，最后访问右子节点3 后跟遍历 先访问左子节点，再访问右子节点，最后访问根节点。\"\"\"def preOrder(root): if root == None: return None stack = [] tmpNode = root while tmpNode or stack : while tmpNode: print(tmpNode.val) stack.append(tmpNode) tmpNode = tmpNode.left node = stack.pop() tmpNode = node.rightdef midOrder(root): if root == None: return None stack = [] tmpNode = root while tmpNode or stack : while tmpNode: stack.append(tmpNode) tmpNode = tmpNode.left node = stack.pop() print(node.val) tmpNode = node.rightdef laterOrder(root): if root == None: return None stack = [] tmpNode = root while tmpNode or stack : while tmpNode: stack.append(tmpNode) tmpNode = tmpNode.left node = stack[-1] tmpNode = node.right if node.right == None: node = stack.pop() print(node.val) while stack and node == stack[-1].right: node = stack.pop() print(node.val) 25.重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if not pre or not tin: return None if len(pre) != len(tin): return None # 取出pre 的第一个值 就是根节点 root = pre[0] rootNode = TreeNode(root) # 找到在 tin 中序遍历中的根节点 所在的索引位置 pos = tin.index(root) # 中序遍历的 列表的左右节点 分开 切片 成两个列表 tinLeft = tin[0:pos] tinRight = tin[pos + 1:] # 前序遍历的 列表的左右节点 分开 切片 成两个列表 preLeft = pre[1:pos + 1] preRight = pre[pos + 1:] leftNode = self.reConstructBinaryTree(preLeft, tinLeft) rightNode = self.reConstructBinaryTree(preRight, tinRight) rootNode.left = leftNode rootNode.right = rightNode return rootNode 26.树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if pRoot2 == None or pRoot1 == None: return False def hasEqual(pRoot1, pRoot2): if pRoot2 == None: return True if pRoot1 == None: return False if pRoot1.val == pRoot2.val: if pRoot2.left == None: leftEqual = True else: leftEqual = hasEqual(pRoot1.left, pRoot2.left) if pRoot2.right == None: rightEqual = True else: rightEqual = hasEqual(pRoot1.right, pRoot2.right) return leftEqual and rightEqual return False if pRoot1.val == pRoot2.val: ret = hasEqual(pRoot1, pRoot2) if ret: return True ret = self.HasSubtree(pRoot1.left, pRoot2) if ret: return True ret = self.HasSubtree(pRoot1.right, pRoot2) return ret\"\"\"对于Python这道题，有些地方需要仔细考虑的。先说下算法实现思路：对于两棵二叉树来说，要判断B是不是A的子结构，首先第一步在树A中查找与B根节点的值一样的节点。通常对于查找树中某一个节点，我们都是采用递归的方法来遍历整棵树。第二步就是判断树A中以R为根节点的子树是不是和树B具有相同的结构。这里同样利用到了递归的方法，如果节点R的值和树的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；如果它们值是相同的，则递归的判断各自的左右节点的值是不是相同。递归的终止条件是我们达到了树A或者树B的叶节点。有地方要重点注意，DoesTree1haveTree2()函数中的两个 if 判断语句 不能颠倒顺序 。因为如果颠倒了顺序，会先判断pRoot1 是否为None, 其实这个时候，pRoot1 的节点已经遍历完成确认相等了，但是这个时候会返回 False，判断错误。有同学不相信的，可以去试试换个顺序，肯定不能AC。同时这个也是《剑指offer》书上没有写的，希望能引起大家的注意。\"\"\"# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution2: def HasSubtree(self, pRoot1, pRoot2): # write code here result = False if pRoot1 != None and pRoot2 != None: if pRoot1.val == pRoot2.val: result = self.DoesTree1haveTree2(pRoot1, pRoot2) if not result: result = self.HasSubtree(pRoot1.left, pRoot2) if not result: result = self.HasSubtree(pRoot1.right, pRoot2) return result # 用于递归判断树的每个节点是否相同 # 需要注意的地方是: 前两个if语句不可以颠倒顺序 # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误 def DoesTree1haveTree2(self, pRoot1, pRoot2): if pRoot2 == None: return True if pRoot1 == None: return False if pRoot1.val != pRoot2.val: return False return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right) 27.二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 12345678910111213141516# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if root == None: return None #处理根节点 root.left,root.right = root.right,root.left self.Mirror(root.left) self.Mirror(root.right) 28.从上往下打印二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 1234567891011121314151617181920212223# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if root == None: return [] treeNodeTmp = [root] ret = [] while treeNodeTmp: tmpNode = treeNodeTmp[0] ret.append(tmpNode.val) if tmpNode.left: treeNodeTmp.append(tmpNode.left) if tmpNode.right: treeNodeTmp.append(tmpNode.right) del treeNodeTmp[0] return ret 29.二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556\"\"\"python:后序遍历 的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，后面用递归分别判断前后两部分 是否 符合以上原则\"\"\"class Solution: def VerifySquenceOfBST(self, sequence): # write code here if sequence==None or len(sequence)==0: return False length=len(sequence) root=sequence[length-1] # 在二叉搜索 树中 左子树节点小于根节点 for i in range(length): if sequence[i]&gt;root: break # 二叉搜索树中右子树的节点都大于根节点 for j in range(i,length): if sequence[j]&lt;root: return False # 判断左子树是否为二叉树 left=True if i&gt;0: left=self.VerifySquenceOfBST(sequence[0:i]) # 判断 右子树是否为二叉树 right=True if i&lt;length-1: right=self.VerifySquenceOfBST(sequence[i:-1]) return left and right# -*- coding:utf-8 -*-class Solution2: def VerifySquenceOfBST(self, sequence): # write code here if sequence == []: return False rootNum = sequence[-1] del sequence[-1] index = None for i in range(len(sequence)): if index == None and sequence[i] &gt; rootNum: index = i if index != None and sequence[i] &lt; rootNum: return False if sequence[:index] == []: leftRet = True else: leftRet = self.VerifySquenceOfBST(sequence[:index]) if sequence[index:] == []: rightRet = True else: rightRet = self.VerifySquenceOfBST(sequence[index:]) return leftRet and rightRet 30.二叉树中和为某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889\"\"\"递归先序遍历树， 把结点加入路径。若该结点是叶子结点则比较当前路径和是否等于期待和。弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点\"\"\"# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneimport copyclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if root == None: return [] ret = [] support = [root] supportArrayList = [[root.val]] while support: tmpNode = support[0] tmpArrayList = supportArrayList[0] if tmpNode.left == None and tmpNode.right == None: if sum(tmpArrayList) == expectNumber: ret.insert(0, tmpArrayList) if tmpNode.left: support.append(tmpNode.left) newTmpArrayList = copy.copy(tmpArrayList) newTmpArrayList.append(tmpNode.left.val) supportArrayList.append(newTmpArrayList) if tmpNode.right: support.append(tmpNode.right) newTmpArrayList = copy.copy(tmpArrayList) newTmpArrayList.append(tmpNode.right.val) supportArrayList.append(newTmpArrayList) del supportArrayList[0] del support[0] return ret# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution2: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] result = [] def FindPathMain(root, path, currentSum): currentSum += root.val path.append(root) isLeaf = root.left == None and root.right == None if currentSum == expectNumber and isLeaf: onePath = [] for node in path: onePath.append(node.val) result.append(onePath) if currentSum &lt; expectNumber: if root.left: FindPathMain(root.left, path, currentSum) if root.right: FindPathMain(root.right, path, currentSum) path.pop() FindPathMain(root, [], 0) return result 31.二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Convert(self, pRootOfTree): # write code here if pRootOfTree == None: return None def find_right(node): while node.right: node = node.right return node leftNode = self.Convert(pRootOfTree.left) rightNode = self.Convert(pRootOfTree.right) retNode = leftNode if leftNode: leftNode = find_right(leftNode) else: retNode = pRootOfTree pRootOfTree.left = leftNode pRootOfTree.right = rightNode if leftNode != None: leftNode.right = pRootOfTree if rightNode != None: rightNode.left = pRootOfTree return retNode","link":"/2019/07/25/jian offer/"},{"title":"markdown格式编写","text":"一些简易的格式备忘录 markdown格式编写第一个标题段落1 中间空一行 段落2 区块引用 使用“&gt;”和空格高亮 这是一段段落高亮 超链接百度 利用中括号小括号的格式 图片 超链接前面+! 无序列表 1 1 1 “*” 2 2 2 “-“ 有序列表 “1.”2.3. 分割线 “ *或是-” 大于3个","link":"/2019/06/08/Joint/"},{"title":"【Person Search】 RCAA Relational Context-Aware Agents for Person Search","text":"论文：RCAA Relational Context-Aware Agents for Person Search链接：http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html代码地址：没有公开 Abstract在本文中，我们通过训练relational context-aware agents来解决这个问题，这些agens从整个场景图像库中学习定位目标人物的操作。我们将相关的空间和时间上下文合并到框架中。具体地说，我们建议在依赖查询的关系网络中使用目标人员作为查询。agent通过同时考虑局部的视觉信息、关系上下文和时间上下文，以及目标人员，确定在每个时间步上要采取的最佳操作。 1. Introduction时空背景可能会提供额外的重要信息，但对人的搜索仍然不够深入。空间语境已被证明在回答视觉问题等任务中是有用的。在整个场景图像中，目标人物依赖的物体之间的空间关系可能有助于更有辨别力的表示。此外，序列决策在目标检测中的成功应用也为人的识别提供了借鉴。多步推理的agent可以更好地定位目标人，同时考虑到目标人的时间行为和状态记忆。在这项工作中，我们提出了一个自顶向下的搜索策略，由一个时空上下文感知的代理提供支持，以解决上面讨论的限制和机会。具体地说，考虑到整个场景、它的本地图像特性和查询图像，我们利用一个依赖于目标-人的关系网络来提取对象之间的空间上下文。然后，我们的深度强化学习代理根据空间上下文及其时间动作和状态记忆，在每一个时间步选择最佳动作，以缩小目标人物的精确位置。整个框架不包含人员建议计算，并且是端到端可培训的。 贡献： 我们最早尝试将人的搜索问题作为一个决策过程来解决，并构建了第一个基于深度强化学习的人的搜索框架。 该模型采用端到端方式进行训练，不需要进行冗余和噪声的proposal Scomputing。有趣的是，我们的模型甚至比负载完美的proposal detector方法性能更好。 我们在训练过程中加入了相关的时空背景，从而引导模型产生更多的信息“经验”。 2. Related Work Person re-idpass pedestrian detectionpass Deep Reinforcement Learning文献中讨论了两种广泛使用的DRL方法——Deep QNetworks(DQN)和策略policy gradient，具体的看论文吧。 3. Relational Context-Aware Agents3.1 Overview行人搜索解决了从整个场景图像库中寻找目标人物的精确位置的问题。系统通过时空上下文感知agent确定的顺序操作动态定位目标行人。我们的代理接受空间和时间上下文、本地图像特征和查询图像作为输入，并预测要采取的最佳操作。通过预测动作将包围框从当前状态转换为下一个状态，并从下一个状态预测下一个动作。这个过程不断重复，直到达到最优结果。 3.2 Relational Decision Making该模型遵循马尔可夫决策过程(MDP)，适用于序列决策过程的建模。 Action 存在移动，扩张和裁剪共14个操作。 State Reward这个具体看懂得有一些强化学习得知识和MDP的相关知识。 3.3 Network Structure我们使用ResNet-50进行特征提取，因为它在人的识别方面显示了极大的优越性。为了编码关系上下文信息，我们结合了一个关系网络(RN)，上文所述，来考虑图像中所有对对象之间的所有关系。 3.4 Training为了避免次优解决方案，我们使用了actor-critic (A3C) method，它在环境的多个实例上异步并行地执行多个agents。我们使用ADAM optimizer训练模型，中间还介绍了强化学习的损失函数和训练策略，不太懂不展开了。4. Experiments 相当高的表现，在两个数据集上，表现见下图，即使放在19年也是很有竞争力的表现了。 Conclusion本文首先尝试解决人的搜索问题，建立了第一个基于深度强化学习的人的搜索框架。与以往依赖proposal learning的工作不同，我们的方法利用了关系上下文信息，并在联合框架中预先利用视觉信息和query。在未来，我们计划在我们的框架中使用宽松的学习lenient learning，因为存储的转换可能会因为agents并行更新它们各自的策略而过时。 个人心得有点复杂的论文，需要有强化学习和一些机器学习的基础，与众多的利用以Faster R-CNN为行人检测器的论文不同，还有以前用proposal learning的传统检测器。总感觉和我之前认知的Person Search有些不同。 我的理解包括跑的一些Person Search的代码：Testing的时候，query和gallery的图像是分批次进入的，query的特征和再和所有gallery检测出的行人特征（也是通过检测后的行人包围框的特征），进行特征对比（比如用余弦相似度或是欧式距离等等），如果detction时候没有检测出iou&gt;0.5的包围框，再怎么query对比都没意义。 这篇RCAA，看文章模型的structure，Our agent accepts the spatial and temporal context, the local image feature and the query image as input,When the training is finished, we fix the policy and value network for testing. A single agent is used to process each query for testing. For each query, we rank all the value V and retrieve the top ranked results. 看的像是test的时候同时可以输入query引导detectoring的过程，和之前的方法推理过程有点不太一样。如果有研究person search的同学可以评论一下，和我交流。","link":"/2018/12/09/RCAA Relational Context Aware Agents for Person Search/"},{"title":"【Person Search】 Person Search by Multi-Scale Matching","text":"论文：Person Search by Multi-Scale Matching链接：http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html代码地址：没有公开 Abstract研究了无约束场景图像中的人搜索问题。现有的检测方法多侧重于提高人的检测精度，以减轻自动检测噪声引起的配准误差、误检等带来的负面影响。与以往的研究相比，我们发现，通过改进现有的深度学习对象检测器(如Fast R-CNN)，可以实现足够的可重复责任人实例裁剪，而在人员搜索中尚未得到充分研究的多尺度匹配问题是一个更为严重的障碍。在这项工作中，我们提出了一种跨层次语义对齐(CLSA)的深度学习方法，能够在统一的端到端模型中学习更具鉴别性的身份特征表示，从而解决了这个多尺度的人搜索挑战。这是通过利用深度神经网络的网络内特征金字塔结构来实现的。这很好地消除了构建计算开销昂贵的图像金字塔和复杂的多分支网络体系结构的需要。 1. Introduction行人搜索处理原始的未细化的检测与许多错误裁剪和未知程度的错位。这就产生了一个更具挑战性的匹配问题，尤其是在人的重新识别过程中。此外，自动检测的人员框通常在规模(分辨率)上比常规的差异更大。由于人与摄像机之间固有的无法控制的距离(图1(a))。因此，它本质上是一个多尺度匹配问题。然而，这一问题目前在人员搜索中研究不足。 贡献： 我们确定了人搜索中的多尺度匹配问题，这是文献中缺少的一个元素，但发现它对提高模型性能具有重要意义。 我们提出了一个跨层次语义对齐(CLSA)的深度学习方法来解决多尺度匹配的挑战。这是基于学习一个端到端的网络内特征金字塔表示，具有较强的鲁棒性，以应对可变尺度的自动检测人的边界框。 我们改进了Faster R-CNN模型，在不受控制的场景中实现更可靠的行人定位，从而提高了整体搜索性能。以及用实验证明了这一点。 2. Related Work Person searchpass pedestrian detectionpass 3. Cross-Level Semantic Alignment for Person Search 3.1 Person Detection进一步提高检测性能和效率,我们介绍一些设计改进原模型。 不是使用传统的RoI的利益(地区)池层,我们该地区农作物和调整功能映射到14×14像素,并进一步最大池他们7×7获得更好的效率 在ImageNet-1K上对backbone ResNet-50网络进行预训练后，我们将第一个构建块(前4层)固定在目标人物搜索数据的微调中。这允许保留从较大的源数据中学到的共享底层特性，同时使模型适应目标数据。 在非最大抑制(NMS)操作之前，我们保留并利用所有大小的proposals来降低在不受控制的场景中极端尺度下的误检率。在部署中，我们考虑所有的检测框得分都在0.5以上，而不是从每个场景图像中提取固定数量的框。这个很好理解。3.2 Multi-Scale Matching by Cross-Level Semantic Alignment 有点复杂，具体可以见论文。 4. ExperimentsOn CUHK-SYSU On PRWpass Further Analysis and Discussions在re-id和detection的数据集上也做了一些实验。 Conclusion在本文中，我们提出了一种新的跨层次语义对齐(CLSA)深度学习框架，用于无约束场景图像中的人物搜索。与现有的以提高人的检测性能为核心的人的搜索方法相比，我们的实验表明，解决多尺度匹配问题对提高人的搜索结果更为重要。为了解决这一研究不足的跨尺度人员搜索问题，我们提出了一种端到端的CLSA深度学习方法，通过构造网络内特征金字塔结构表示，利用语义对齐学习损失函数增强其表示能力。以使所有特征金字塔等级识别具有辨别力，从而导致更有效的分层表示，用于匹配具有大且无约束的尺度变化的人物图像。 个人心得主要通过提升检测时候增加了多尺度匹配，通过特征金字塔，在re-id部分增加语义对齐，这个在re-id里也是常用手段，但是是跨层次的，相当于multi-scale的。最后结尾在一些image-based re-id数据集上也做了实验，比如market1501和cuhk03上，但是提升效果寥寥，88.9的top1在market1501上真的很一般。为啥能在person search上表现这么好，总之person search的坑很多，一些在detection上和re-id上能提升的，改进一些都可以在person search上有提高。但是这也提高了太多了把~","link":"/2018/11/28/Person Search by Multi-Scale Matching/"},{"title":"【Person Search】 Joint Detection and Identification Feature Learning for Person Search","text":"论文：Joint Detection and Identification Feature Learning for Person Search链接：https://arxiv.org/abs/1604.01850代码地址： https://github.com/ShuangLI59/person_search caffe版本疑似复现地址：https://github.com/liliangqi/person_search pytorch版本 Abstract 现有的行人再识别方法中所使用的标准和方法主要关注的是经过裁剪的行人照片，这与现实生活场景中的图片有所不同。本文为了缩小两者的差距，提出了一种行人搜索的新框架，将行人检测和行人再识别结合起来，利用单个CNN来进行训练。文中使用了OIM损失（Online Instance Matching）来训练网络，它比一般的Softmax损失函数的效果更快更好。 同时提出了一个大型的数据集，总共18184 images，所有图像中总共有8432 persons，99809个标注的bounding boxes。 1. Introduction 行人重识别和行人搜索的不同点在于，行人重识别，是在已经假设行人检测已经做的完美的基础上做的再识别研究。而行人搜索更贴近于现实世界的应用，更具有挑战性，正如检测行人时可能不可避免的出现false alarms，漏检，misalignments，这些都会对行人搜索的效果产生影响。 与传统方法中将行人检测和再识别分成两个问题不同，本文利用单个CNN将两者结合来解决上述问题，该CNN分为两个部分，一个是pedestrian proposal net，来产生候选行人的 bounding boxes，另一个是identification net，来提取特征来进行与检索目标的比较。两者在 joint optimization过程中具有相互适应的特点，从而消除自身外另一网络带来的问题。 传统的re-id特征学习主要依赖于pair-wise或triplet distance loss functions,它们一次都只能用少量的数据做比较;以及Softmax loss function,虽然把行人重识别问题当成是多分类问题去做，解决了之前两个loss function的问题，但是随着行人类型（不同身份的人）数量的增多，训练一个如此庞大的Softmax 分类器会变得及其的慢，甚至更糟糕的时候网络会无法收敛。 2. Related Work2.1 Person re-idpass 2.2 pedestrian detectionpass 3. Method Pipline 首先，经过Stem CNN将raw pixel转换成Convolutional Feature Maps。然后，放到Pedestrain Proposal net生成候选行人的bounding boxes。 然后放到一个带有Rol(regionof interest) Pooling的识别网络，提取出每个候选区（boundingbox）对应的L2正则化256维特征向量。 在推测阶段，利用gallery person和目标行人之间的features distances来进行排序。 在训练阶段，根据feature vectors，使用OIM loss function以及其他的loss functions来监控identification net，以多任务方式来训练网络。Model Structure 文中选用的是ResNet-50作为CNN模型的网络结构，利用其中的conv1和 conv4_3作为stem CNN部分。给定一张输入图片，stem会产生1024个通道的 features maps，它们的分辨率只有原图像的十六分之一。 根据生成的这些features maps，利用512 × 3 × 3的卷积层来对行人特征进行转换，接着在feature map的每个位置利用9个anchors（源于Faster RCNN）和1个Softmax分类器来预测每个anchor是否包含行人在内，同时还包括了1个线性回归器来调整anchors的位置。在NMS过后仅保留128个调整后的bounding boxes作为最终的proposals； 建立IdentificationNet，用于提取每个候选区的特征，并和目标特征做对比。首先用ROI-Pooling从每个候选区的特征图中池化出一个10241414的区域。然后，他们通过ResNet-50的con4_4到conv5_3，最后通过全局的平均池化层汇总成2048维特征向量。 另一方面，pedestrian proposal net 生成的 pedestrian proposals 中会不可避免地会包含一些 false alarms（也就是proposal里包含的不是行人）和 misalignments（也就是框没有对齐行人），因此再次利用Softmax分类器和线性回归器来拒绝非行人的区域并精修proposal的位置。另一方面，我们将特征投影到经过L2正则化后的256维向量子空间中，并在推测阶段计算它们和目标行人的余弦相似度。Online Instance Matching Loss labeled identity：与目标行人相吻合的proposal。 unlabeled identities：包含行人但不是目标行人的proposal。 background clutter：包含非行人物体或者背景的proposal。在OIM损失函数中只考虑前两者。具体见下图： 因为目标是为了区分开不同id的人，一个很自然很常用的方法就是缩小相同id人的特征距离，同时增大不同id的人的特征距离，为了实现这个目的，我们需要存储所有人的特征。对所有训练集图像同时进行网络的前向传递就可以实现，但这对于SGD优化器来说是不实际的，因为随机梯度下降每次只取一个mini-batch，不可能把所有训练集图像一次包含进去训练，所以本文并未选择SGD进行优化，而是采用了 online approximation。mini-batch中一个labeled identity的特征被记为记为x（x是D维特征向量），之后生成一个 lookup table V（LUT，查询表，前面有介绍过，Figure 3中右上角的蓝色格子），V用来记录所有labeled identity的特征（D×L 维矩阵，D是上面的x的维度，也就是一个labeled identity的特征维度；L是不同id的人，就是L个类；所以D×L 维矩阵就是整个LUT的维度）。前向计算时，会计算minibatch sample 与所有LUT中labeled identity的实例的cosine 相似度，通过矩阵乘法，后向传播时，如果query的ID为t，则更新LUT的第t列与之ID对应的labeled identity实例特征，如下： 4. Dataset4.1 CUHK-SYSU总共有8432 persons，99809个标注的bounding boxes。For street snaps, 12490 images and 6057 query persons ； For movie/TV，5694 images and 2375 query persons ； training set：11206 images and 5532 query persons ； test set：6978 images and 2900 query persons ； every query至少有与query同一ID的图片，不同的query有不同的gallery set且training and test sets have no overlap on images or query persons，以保证用测试集评价的合理性. 4.2 Metrics mAP CMC-K 5. Experiment Settings文章是基于caffe框架和faster rcnn算法为基础的，用了基于ImageNet 的ResNet50的预训练模型 所有用到的loss都有一样的损失权重，每一个mini-batch有2张全景图，学习率初始化为0.001，在4万次迭代后下降到0.0001，然后保持不变直到模型在大约5万次迭代的时候达到收敛。直接看文章开头的代码上手更快些。 可以看出不管是CMC或者mAP两项评价指标，本文提出的方法均遥遥领先于其他方法。与IDNet方法相同，提升的原因，主要是：检测和重识别两项任务的有效结合，互相提升，以及在OIM loss中有效地使用了unlabeled identity 来监督学习。行人检测中 detectors 检测器的选择对行人重识别任务的效果提升尤为关键，我们可以看到CCF、ACF、CNN和GT之间的差别都是巨大的，直接使用现有的 detector 对现实生活中的行人检测任务来说并不是最优的，否则 detector 很可能就会成为限制行人重识别任务效果的一个瓶颈。 Conclusionpass 个人心得上手Person Search相关的科研论文，这篇文章是必读的，是第一篇整合两个子任务到同一个框架的工作，源码由于是caffe的，对于新手不太友好，尤其是18年开始入坑CV的小白来说，一些更轻便的框架,把层，代价函数，模块封装好的，如tensorflow或是pytorch则更容易手上，建议可以从那个疑似复现代码的地址上手，可能复现不到这篇论文的结果，相差大约1~2%,但从熟悉整个Person Search的框架再好不过了，主要还是大部分的Person Search论文都没有开源，或者只是提供了test的部分代码和训练好的网络参数和结构，打包成了.pth等让读者在云盘上下载，有点小坑，很难复现到原始论文的结果。","link":"/2018/10/21/Joint Detection and Identification Feature Learning for Person Search/"},{"title":"【Person Search】 Joint Detection and Identification Feature Learning for Person Search","text":"论文：Joint Detection and Identification Feature Learning for Person Search链接：https://arxiv.org/abs/1604.01850代码地址： https://github.com/ShuangLI59/person_search caffe版本疑似复现地址：https://github.com/liliangqi/person_search pytorch版本 Abstract 现有的行人再识别方法中所使用的标准和方法主要关注的是经过裁剪的行人照片，这与现实生活场景中的图片有所不同。本文为了缩小两者的差距，提出了一种行人搜索的新框架，将行人检测和行人再识别结合起来，利用单个CNN来进行训练。文中使用了OIM损失（Online Instance Matching）来训练网络，它比一般的Softmax损失函数的效果更快更好。 同时提出了一个大型的数据集，总共18184 images，所有图像中总共有8432 persons，99809个标注的bounding boxes。 1. Introduction 行人重识别和行人搜索的不同点在于，行人重识别，是在已经假设行人检测已经做的完美的基础上做的再识别研究。而行人搜索更贴近于现实世界的应用，更具有挑战性，正如检测行人时可能不可避免的出现false alarms，漏检，misalignments，这些都会对行人搜索的效果产生影响。 与传统方法中将行人检测和再识别分成两个问题不同，本文利用单个CNN将两者结合来解决上述问题，该CNN分为两个部分，一个是pedestrian proposal net，来产生候选行人的 bounding boxes，另一个是identification net，来提取特征来进行与检索目标的比较。两者在 joint optimization过程中具有相互适应的特点，从而消除自身外另一网络带来的问题。 传统的re-id特征学习主要依赖于pair-wise或triplet distance loss functions,它们一次都只能用少量的数据做比较;以及Softmax loss function,虽然把行人重识别问题当成是多分类问题去做，解决了之前两个loss function的问题，但是随着行人类型（不同身份的人）数量的增多，训练一个如此庞大的Softmax 分类器会变得及其的慢，甚至更糟糕的时候网络会无法收敛。 2. Related Work2.1 Person re-idpass 2.2 pedestrian detectionpass 3. Method Pipline 首先，经过Stem CNN将raw pixel转换成Convolutional Feature Maps。然后，放到Pedestrain Proposal net生成候选行人的bounding boxes。 然后放到一个带有Rol(regionof interest) Pooling的识别网络，提取出每个候选区（boundingbox）对应的L2正则化256维特征向量。 在推测阶段，利用gallery person和目标行人之间的features distances来进行排序。 在训练阶段，根据feature vectors，使用OIM loss function以及其他的loss functions来监控identification net，以多任务方式来训练网络。Model Structure 文中选用的是ResNet-50作为CNN模型的网络结构，利用其中的conv1和 conv4_3作为stem CNN部分。给定一张输入图片，stem会产生1024个通道的 features maps，它们的分辨率只有原图像的十六分之一。 根据生成的这些features maps，利用512 × 3 × 3的卷积层来对行人特征进行转换，接着在feature map的每个位置利用9个anchors（源于Faster RCNN）和1个Softmax分类器来预测每个anchor是否包含行人在内，同时还包括了1个线性回归器来调整anchors的位置。在NMS过后仅保留128个调整后的bounding boxes作为最终的proposals； 建立IdentificationNet，用于提取每个候选区的特征，并和目标特征做对比。首先用ROI-Pooling从每个候选区的特征图中池化出一个10241414的区域。然后，他们通过ResNet-50的con4_4到conv5_3，最后通过全局的平均池化层汇总成2048维特征向量。 另一方面，pedestrian proposal net 生成的 pedestrian proposals 中会不可避免地会包含一些 false alarms（也就是proposal里包含的不是行人）和 misalignments（也就是框没有对齐行人），因此再次利用Softmax分类器和线性回归器来拒绝非行人的区域并精修proposal的位置。另一方面，我们将特征投影到经过L2正则化后的256维向量子空间中，并在推测阶段计算它们和目标行人的余弦相似度。Online Instance Matching Loss labeled identity：与目标行人相吻合的proposal。 unlabeled identities：包含行人但不是目标行人的proposal。 background clutter：包含非行人物体或者背景的proposal。在OIM损失函数中只考虑前两者。具体见下图： 因为目标是为了区分开不同id的人，一个很自然很常用的方法就是缩小相同id人的特征距离，同时增大不同id的人的特征距离，为了实现这个目的，我们需要存储所有人的特征。对所有训练集图像同时进行网络的前向传递就可以实现，但这对于SGD优化器来说是不实际的，因为随机梯度下降每次只取一个mini-batch，不可能把所有训练集图像一次包含进去训练，所以本文并未选择SGD进行优化，而是采用了 online approximation。mini-batch中一个labeled identity的特征被记为记为x（x是D维特征向量），之后生成一个 lookup table V（LUT，查询表，前面有介绍过，Figure 3中右上角的蓝色格子），V用来记录所有labeled identity的特征（D×L 维矩阵，D是上面的x的维度，也就是一个labeled identity的特征维度；L是不同id的人，就是L个类；所以D×L 维矩阵就是整个LUT的维度）。前向计算时，会计算minibatch sample 与所有LUT中labeled identity的实例的cosine 相似度，通过矩阵乘法，后向传播时，如果query的ID为t，则更新LUT的第t列与之ID对应的labeled identity实例特征，如下： 4. Dataset4.1 CUHK-SYSU总共有8432 persons，99809个标注的bounding boxes。For street snaps, 12490 images and 6057 query persons ； For movie/TV，5694 images and 2375 query persons ； training set：11206 images and 5532 query persons ； test set：6978 images and 2900 query persons ； every query至少有与query同一ID的图片，不同的query有不同的gallery set且training and test sets have no overlap on images or query persons，以保证用测试集评价的合理性. 4.2 Metrics mAP CMC-K 5. Experiment Settings文章是基于caffe框架和faster rcnn算法为基础的，用了基于ImageNet 的ResNet50的预训练模型 所有用到的loss都有一样的损失权重，每一个mini-batch有2张全景图，学习率初始化为0.001，在4万次迭代后下降到0.0001，然后保持不变直到模型在大约5万次迭代的时候达到收敛。直接看文章开头的代码上手更快些。 可以看出不管是CMC或者mAP两项评价指标，本文提出的方法均遥遥领先于其他方法。与IDNet方法相同，提升的原因，主要是：检测和重识别两项任务的有效结合，互相提升，以及在OIM loss中有效地使用了unlabeled identity 来监督学习。行人检测中 detectors 检测器的选择对行人重识别任务的效果提升尤为关键，我们可以看到CCF、ACF、CNN和GT之间的差别都是巨大的，直接使用现有的 detector 对现实生活中的行人检测任务来说并不是最优的，否则 detector 很可能就会成为限制行人重识别任务效果的一个瓶颈。 Conclusionpass 个人心得上手Person Search相关的科研论文，这篇文章是必读的，是第一篇整合两个子任务到同一个框架的工作，源码由于是caffe的，对于新手不太友好，尤其是18年开始入坑CV的小白来说，一些更轻便的框架,把层，代价函数，模块封装好的，如tensorflow或是pytorch则更容易手上，建议可以从那个疑似复现代码的地址上手，可能复现不到这篇论文的结果，相差大约1~2%,但从熟悉整个Person Search的框架再好不过了，主要还是大部分的Person Search论文都没有开源，或者只是提供了test的部分代码和训练好的网络参数和结构，打包成了.pth等让读者在云盘上下载，有点小坑，很难复现到原始论文的结果。","link":"/2018/10/21/Neural Person Search Machines/"},{"title":"【Person Search】 Person Re-identification in the Wild","text":"论文：Person Re-identification in the Wild链接：https://arxiv.org/abs/1604.02531代码地址：https://github.com/liangzheng06/PRW-baseline Abstract 这篇论文发布了一个可以研究端到端的行人检测-重识别的大规模数据集和一些baselines，baselines主要包括不同检测器和reid识别算法组合的性能，行人检测怎么有助于reid准确率的提升及评估不同检测器对reid的有效性。 贡献： 提出了一个新的数据集：PRW，及基于数据集的广泛的benchmark。 行人检测通过以下两种方式对re-id有帮助，IDE 级联微调训练策略（充分利用detector得到的数据）+ CWS（Confidence Weighted Similarity，加入到相似度度量中（给错检附更低的权重，即通过优化相似度计算的方法改进detector对reid的影响）。 在特定场合下的accurate re-id过程中，检测器性能评价和一些关于发布数据集的实验结论。 1. Introduction行人识别和重识别通常被分为两个不同的问题来考虑。作者开创性的在自己的数据集上研究了不同检测器和reid识别方法组合的性能，研究是否检测可以帮助提升reid准确率，研究选择怎样的检测器可以最大程度的提升reid准确率。文中提出了与以往不同的新的dataset（PRW）和baselines（which moves beyond sequential application of detection and recognition），因为目前的许多数据集缺少annotations，从而无法将识别与再识别进行结合来评估。 2. Related Work 前人的研究工作无法体现不同质量的detector对re-id精确度的影响。本文的pipline则是考虑了从detection到re-id的整个过程。 Pedestrian detection的发展过程. Person re-identification的发展过程。 3. The PRW Dataset具体最直观的了解数据集方法就是下载它，一张张看加了解命名规则，README.md里介绍的很清楚。 4. Evaluation Protocols沿用了Person re-id的标准 5. Experiments 还有很多张实验的对比图没放，一些最基本的Detector+Metic-learning的方法，基本是作为以后Person Search论文里吊打的对比方法，毕竟拿深度学习的方法和传统方法对比，起码表格里看得出拉开了差距。 Conclusion 设计有效的框回归方案来提升行人框定位精度，总而提升行人匹配正确率 设计更复杂有效的权重方案，用检测的置信度或其他来指导更有效的相似度计算 re-ranking方法对于可扩展的reid应用很有帮助 怎样能够利用无ID标注的现存数据或若标签数据来提升reid性能也具有重要的研究价值 检测和识别的联合学习问题，而不是组合形式，更符合reid实用需求 有效的基于部件的reid，如对齐网络的引进和设计，将极大提升端到端网络的reid性能 个人心得 论文用的是matlab的代码，由于是16年的论文，从19年返回再来看价值不是很高，虽然现在也有很多还是把re-id和detection分开做的工作，但是只是在detection部分加入了简单的CNN层，re-id部分还是传统的图像处理。但是毕竟是提出的PRW的论文，引用也是必须的，PRW数据集是market1501的整帧图片，提出的作者也是同一个郑良大大，太厉害了。了解一下数据集图片命名的规则，对于做无监督的同学也是大有帮助的。","link":"/2018/10/02/Person Re-identification in the Wild/"}],"tags":[{"name":"论文笔记","slug":"论文笔记","link":"/tags/论文笔记/"},{"name":"代码踩坑","slug":"代码踩坑","link":"/tags/代码踩坑/"},{"name":"基本算法","slug":"基本算法","link":"/tags/基本算法/"},{"name":"编程语言","slug":"编程语言","link":"/tags/编程语言/"},{"name":"机器学习","slug":"机器学习","link":"/tags/机器学习/"},{"name":"神经网络","slug":"神经网络","link":"/tags/神经网络/"},{"name":"深度学习","slug":"深度学习","link":"/tags/深度学习/"},{"name":"聚类算法","slug":"聚类算法","link":"/tags/聚类算法/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"检测算法","slug":"检测算法","link":"/tags/检测算法/"},{"name":"刷题笔记","slug":"刷题笔记","link":"/tags/刷题笔记/"}],"categories":[{"name":"行人搜索","slug":"行人搜索","link":"/categories/行人搜索/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"python","slug":"python","link":"/categories/python/"}]}