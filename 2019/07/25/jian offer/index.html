<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.8.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>python实现剑指offer1-31题 - Cy的学习日常</title>


    <meta name="description" content="详细地分析剑指offer1-31题的解题思路，代码及代码注释。">
<meta name="keywords" content="编程语言,数据结构,刷题笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="python实现剑指offer1-31题">
<meta property="og:url" content="http://www.cygao.xyz/2019/07/25/jian offer/index.html">
<meta property="og:site_name" content="Cy的学习日常">
<meta property="og:description" content="详细地分析剑指offer1-31题的解题思路，代码及代码注释。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.cygao.xyz/images/og_image.png">
<meta property="og:updated_time" content="2019-09-02T02:05:21.970Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python实现剑指offer1-31题">
<meta name="twitter:description" content="详细地分析剑指offer1-31题的解题思路，代码及代码注释。">
<meta name="twitter:image" content="http://www.cygao.xyz/images/og_image.png">







<link rel="icon" href="/assets/favicon.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="python实现剑指offer1-31题" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/laboratory">统计</a>
                
                <a class="navbar-item"
                href="/photos/">相册</a>
                
                <a class="navbar-item"
                href="/music">音乐</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/gggcy">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-25T05:23:45.000Z">2019-07-25</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 小时 读完 (大约 20947 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                python实现剑指offer1-31题
            
        </h1>
        <div class="content">
            <p>详细地分析剑指offer1-31题的解题思路，代码及代码注释。<br><a id="more"></a></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</strong></p>
<p>对列的添加       insert              append </p>
<p>队列的取值      列表[-1]            列表[0]</p>
<p>队列的删除       pop()            pop(0)</p>
<hr>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</strong></p>
<p>只允许在栈的栈顶来操作。</p>
<p>添加元素用append(push)，称作是进栈，入栈或者压栈</p>
<p>取值列表[-1]，因为它只能从栈顶来取值，相当于取列表的最后一个值，所以用索引-1.</p>
<p>删除元素pop()从后端开始删除。称作是出栈或者退栈。</p>
<hr>
<h2 id="1-两个栈实现一个队列：-本题考点-队列-栈"><a href="#1-两个栈实现一个队列：-本题考点-队列-栈" class="headerlink" title="1. 两个栈实现一个队列：[^本题考点 队列 栈]"></a>1. 两个栈实现一个队列：[^本题考点 队列 栈]</h2><p><strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</strong></p>
<p>……解析：</p>
<p>定义一个类，首先这个类要具备两个属性，一个是压栈，一个是出栈。</p>
<p>因为要两个栈来实现一个队列：进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>那么如何用：两个栈实现一个队列？</p>
<p>栈： 先进后出</p>
<p>队列：先进先出</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianggezhan.png" alt></p>
<h4 id="如图所示："><a href="#如图所示：" class="headerlink" title="如图所示："></a>如图所示：</h4><p>队列从一头添加数据，从一头删除数据。</p>
<p>所以我们需要让两个栈</p>
<p>一个栈实现添加数据 </p>
<p>​    即：<code>self.acceptStack=[]</code>它拥有一个<code>push</code>的方法，用来作为队列的一端的添加数据 功能 用append来实现</p>
<p>​        <code>self.acceptStack.append(node)</code></p>
<p>另一个栈实现删除数据：</p>
<p>​    即：<code>self.outputStack = []</code>它拥有pop 的方法，用来作为队列的另一端的删除数据的功能 用pop 来实现</p>
<p>​    但是我们要实现的是队列的先进先出，也就意味着 如果说我们添加数据的栈中添加了一个数据，那么我们另一个删除数据的栈中，也要相应的删除这个数据，所以说这两个栈中的数据的顺序是相反的。</p>
<p>以上的需求我们通过，删除<code>acceptStack</code>栈中的数据，在<code>outputStack</code>中添加这个数据，那么先在<code>acceptStack</code>中删除的数据，就会进入到<code>outputStack</code>的栈底，后在<code>acceptStack</code>中删除的数据，会后进入<code>outputStack</code>，那么它就会先出来。</p>
<p>那么两个栈，这样来合作，就会实现队列的先进先出，如图：1 是先进的（栈1） 那么1 就会先出来（栈2）。</p>
<p>进而实现了 题目的需求。</p>
<p>在pop 的方法中，如果说 <code>self.outputStack</code>是空 没有数据，那么 就给它 while 循环我们的 作为添加数据的栈 </p>
<p><code>acceptStack</code>，删除这个栈中的内容，它会弹出，然后把它添加到 <code>栈2 outputStack</code>  中，它就会有数据，有数据的话就返回 （如果 调用了 删除 数据的这个方法的话）。如果说 做了循环，我们的<code>栈2 outputStack</code> 中还没有数据，就明 <code>acceptStack</code>中，没有数据压入，也就说明这个 队列 没有添加数据，也就不会有删除的数据，所以返回一个None。</p>
<hr>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#添加数据栈</span></span><br><span class="line">        self.acceptStack=[]</span><br><span class="line">        <span class="hljs-comment">#删除数据栈</span></span><br><span class="line">        self.outputStack = []</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#向添加数据的栈中添加数据</span></span><br><span class="line">        self.acceptStack.append(node)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#判断删除数据的栈中是否有数据，没有的话，就添加数据，添加数据时，要添加栈1 中删除的数据</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.outputStack:</span><br><span class="line">            <span class="hljs-keyword">while</span> self.acceptStack:</span><br><span class="line">            self.outputStack.append(self.acceptStack.pop())</span><br><span class="line">        <span class="hljs-comment">#如果有数据的话，就返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.outputStack:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.outputStack.pop()</span><br><span class="line">        <span class="hljs-comment">#如果没有数据，说明没有数据添加进去，也就不需要删除数据，所以返回none</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><h5 id="分析查找：首先快速的查找方法-有二分查找法，那么什么是二分查找法？"><a href="#分析查找：首先快速的查找方法-有二分查找法，那么什么是二分查找法？" class="headerlink" title="分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？"></a><strong>分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？</strong></h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找法什么情况下用。有序的数组中。首先 肯定是在有序的 数组中的！！！！！</span><br></pre></td></tr></table></figure>
<p>算法：二分法查找适用于数据量较大时，但是数据需要先排好顺序。主要思想是：（设查找的数组区间为array[low, high]）</p>
<p>（1）确定该区间的中间位置K（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：a.array[k]&gt;T 由数组的有序性可知array[k,k+1,……,high]&gt;T;故新的区间为array[low,……，K-1]b.array[k]&lt;T 类似上面查找区间为array[k+1,……，high]。每一次查找与中间值比较，可以确定是否查找成功，不成功当前查找区间将缩小一半，递归查找即可。</p>
<p>时间复杂度为:<code>O(log2n)</code>。</p>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)所以T(n)=O(log2n)</p>
<p>2.最好情况查找中间元素O(1)查找的元素即为中间元素（奇数长度数列的正中间，偶数长度数列的中间靠左的元素）</p>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ol>
<li>S(n)=n</li>
</ol>
<h5 id="二分法代码实现："><a href="#二分法代码实现：" class="headerlink" title="二分法代码实现："></a>二分法代码实现：</h5><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(array,target)</span>:</span></span><br><span class="line">    left= <span class="hljs-number">0</span></span><br><span class="line">    right= len(array)<span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">while</span> left &lt;= right :</span><br><span class="line">        <span class="hljs-comment">#除法没有移位的快</span></span><br><span class="line">        <span class="hljs-comment"># mid = (left + right)//2</span></span><br><span class="line">        <span class="hljs-comment"># 101 = 5 =&gt; 10 = 2</span></span><br><span class="line">        <span class="hljs-comment">#1100 = 12 =&gt; 110 = 6</span></span><br><span class="line">        <span class="hljs-comment">#一下用了 向右 移一位， 那么上面是解释，它就相当于 除以2 。</span></span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#如果中间的数等于我们要找的数，那么就返回。</span></span><br><span class="line">        <span class="hljs-keyword">if</span>  array[mid] == target:</span><br><span class="line">            <span class="hljs-keyword">return</span> mid</span><br><span class="line">        <span class="hljs-comment">#如果说中间的数 &lt; 目标的数，那么就说明，我们要找的数在右侧，所以左侧取值的索引需要改变为中间的索引+1；</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> array[mid]&lt; target:</span><br><span class="line">            left = mid + <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#如果说中间的数 &gt; 目标的数，那么就说明，我们要找的数在左侧，所以左侧取值的索引需要改变为中间的索引-1； 因为越往左索引值越小</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            right = mid<span class="hljs-number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure>
<p>把数组内的数据一分为二，然后计算出中间数据的 索引值。</p>
<p>数组中 最左侧的  索引为 0  ；最右侧的索引为 len(array)-1，数组的长度 减 1 就是 最后一个数的索引。</p>
<p>先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，如果相等那么就返回，如果不相等，那么就继续判断。如果说我们找到的 array[mid] 小于  target 这个数; 那么 就说明 我们要查找的数在右侧的一半数据中，那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。如果说我们找到的 array[mid]  大于 target 这个数 ，那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。</p>
<p>以上为二分法的原理。</p>
<hr>
<h2 id="2-旋转数组的最小数字-本题考点-查找"><a href="#2-旋转数组的最小数字-本题考点-查找" class="headerlink" title="2. 旋转数组的最小数字 [^本题考点 查找]"></a>2. 旋转数组的最小数字 [^本题考点 查找]</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#最小值 一定比前面的要小</span></span><br><span class="line">        <span class="hljs-comment"># 二分法查找数据  找左右的方法是：</span></span><br><span class="line">        <span class="hljs-comment">#右边的值大于中值，就说明最小值在左边</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rotateArray:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        right = len(rotateArray) - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果说中间的数的上一个数 &gt; 中间数，那么就说明，我们要找的数就是这个中间的数，返回这个数。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> rotateArray[mid - <span class="hljs-number">1</span>] &gt; rotateArray[mid]:</span><br><span class="line">                <span class="hljs-keyword">return</span> rotateArray[mid]</span><br><span class="line">            <span class="hljs-comment">#如果说中间的数 &lt; 中间数的上一个数，那么就说明，我们要找的数在二分法的左侧，所以右侧取值的索引需要改变为中间的索引-1；因为越往左索引值越小</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                right = mid - <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#否则就说明，我们要找的数在二分法的右侧，所以左侧取值的索引需要改变为中间的索引+1；因为越往右索引值越小</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="什么叫做数组？"><a href="#什么叫做数组？" class="headerlink" title="什么叫做数组？"></a>什么叫做数组？</h5><p><em>所谓数组，是有序的元素序列。 [1]  若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。 [1]  这些无序排列的同类数据元素的集合称为数组。</em></p>
<p>例如：</p>
<p>int (32 位)      int         int         这三个就会组成一个数组，类型相同的变量。<br>a(0)             a(1)          a(2)</p>
<p>数组与python中的 列表比较相似， 用索引去查找。<br>数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。<br>数组还和元组比较像，元组是初始化后，长度指定了就不可以变。<br>但是元组在初始化时给的值，确定了以后就不可以变了。<br>所以可以理解为数组与list 列表很相似。</p>
<hr>
<h2 id="3-在二维数组中的查找-本题考点-查找"><a href="#3-在二维数组中的查找-本题考点-查找" class="headerlink" title="3.在二维数组中的查找[^本题考点 查找]"></a>3.在二维数组中的查找[^本题考点 <em>查找</em>]</h2><p><strong>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># array 二维列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Find</span><span class="hljs-params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># 1 2 3 4</span></span><br><span class="line">        <span class="hljs-comment"># 3 4 5 6</span></span><br><span class="line">        <span class="hljs-comment"># 4 6 8 10</span></span><br><span class="line">        <span class="hljs-comment"># 9 11 13 15</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度 o(n**n)</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># for i in range(len(array)):</span></span><br><span class="line">        <span class="hljs-comment">#     for j in range(len(array[i])):</span></span><br><span class="line">        <span class="hljs-comment">#         if target == array[i][j]:</span></span><br><span class="line">        <span class="hljs-comment">#             return True</span></span><br><span class="line">        <span class="hljs-comment"># return False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#时间复杂度</span></span><br><span class="line">        <span class="hljs-comment">#O（n)</span></span><br><span class="line">        <span class="hljs-comment">#这个二维数组的长度是多少，也就是说这个数组有几行；</span></span><br><span class="line">        row_count = len(array)</span><br><span class="line">        i = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列</span></span><br><span class="line">        column_count = len(array[<span class="hljs-number">0</span>])</span><br><span class="line">        <span class="hljs-comment">#给j 一个值，就是数组列数的值-1，即为j 的最大值。</span></span><br><span class="line">        j = len(array[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment">#循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。</span></span><br><span class="line">        <span class="hljs-comment">#我们要取到每行的最后一个数，即对应的那一列的第一个数，来与我们的目标数来对比，这个数是这一行的最大数，是这一列的最小数。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> i &lt; row_count <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#根据两个索引下标可以取到 对应的在数组中的值</span></span><br><span class="line">            value = array[i][j]</span><br><span class="line">            <span class="hljs-comment">#如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回就好。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> value == target:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-comment">#如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，给它减-1，找前一列的数做比较</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> target &lt; value:</span><br><span class="line">                j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果说取到的值 &lt; 我们的目标值。那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                i += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-包含min-函数的栈-本题考点-栈"><a href="#4-包含min-函数的栈-本题考点-栈" class="headerlink" title="4.包含min 函数的栈[^本题考点 栈]"></a>4.包含min 函数的栈[^本题考点 <em>栈</em>]</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</strong></p>
<p>原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：考虑两个栈的长度相同，添加一个，另一个栈也会删除一个</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment">#给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []</span><br><span class="line">    <span class="hljs-comment">#给栈中推进去数值，推进去元素node，添加函数</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="hljs-comment">#如果最小值列表里有值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue:</span><br><span class="line">            <span class="hljs-comment">#如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="hljs-comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.minValue[<span class="hljs-number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">             <span class="hljs-comment">#如果列表里面的最后一个值，小于node值，那么就说明node这个值大；那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                self.minValue.append(self.minValue[<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-comment">#如果最小值列表里面没有值，就在最小值列表里添加node</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">    <span class="hljs-comment">#给栈中做删除操作</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个</span></span><br><span class="line">        self.minValue.pop()</span><br><span class="line">        <span class="hljs-comment">#有值得话，就需要删除一个，删除做pop 操作；返回我们删除的那个数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="hljs-comment">#栈顶 </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]</span><br><span class="line">   	<span class="hljs-comment">#取出最小值，那么就是我们minvalue 中的最后一个值为最小值</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.minValue[<span class="hljs-number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">#第二种方法：不考虑两个栈的长度必须要保持一致，那么在栈删除值的时候，判断一下删除的值，是不是与装最小值的栈里的最后一个最小值相同，如果相同就删掉，如果不同，就不删除。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue:</span><br><span class="line">            <span class="hljs-comment">#如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="hljs-comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.minValue[<span class="hljs-number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">             <span class="hljs-comment">#最后一个值不大于node这个值得话；不做操作，不需要把它两个做的长度一致</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#删除的时候，做个判断，它是不是与栈里面的最后一个值，与我们最小值栈里的最后一个值相等，那么就删除双方的这个值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack[<span class="hljs-number">-1</span>] == self.minValue[<span class="hljs-number">-1</span>]:</span><br><span class="line">            self.minValue.pop()</span><br><span class="line">            <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="hljs-comment">#如果不等的话，就只要删除栈 里最后一个值就可以</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.minValue[<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="5-替换空格-本题考点-字符串"><a href="#5-替换空格-本题考点-字符串" class="headerlink" title="5.替换空格[^本题考点 字符串]"></a>5.替换空格[^本题考点 <em>字符串</em>]</h2><p><strong>请实现一个函数，将一个字符串中的每个空格替换成<code>“%20”</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># s 源字符串</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">    	<span class="hljs-comment">#第一种：python中自带的一个替换的函数</span></span><br><span class="line">        <span class="hljs-comment"># return s.replace(' ','%20')</span></span><br><span class="line">        <span class="hljs-comment">#第二种遍历来替换字符串中的空格</span></span><br><span class="line">        strlen = len(s)</span><br><span class="line">        <span class="hljs-comment">#借助第三方的列表来实现时间的节省。</span></span><br><span class="line">        aaa = []</span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(strlen):</span><br><span class="line">            <span class="hljs-comment">#如果是空格的话那就替换为%20.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">" "</span>:</span><br><span class="line">            <span class="hljs-comment">#if s[i] isspace:</span></span><br><span class="line">                aaa.append(<span class="hljs-string">"%"</span>)</span><br><span class="line">                aaa.append(<span class="hljs-string">"2"</span>)</span><br><span class="line">                aaa.append(<span class="hljs-string">"0"</span>)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                aaa.append(s[i])</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(aaa)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-斐波那契数列"><a href="#6-斐波那契数列" class="headerlink" title="6.斐波那契数列"></a>6.斐波那契数列</h2><p><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：下面是使用了for循环，</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># 如果是按照递归来写的话， 时间复杂度就是随着n的变化 增长率是 2^n</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-string">''' 递归实现</span></span><br><span class="line"><span class="hljs-string">        # n = 0 f(0) = 0</span></span><br><span class="line"><span class="hljs-string">        if n == 0:</span></span><br><span class="line"><span class="hljs-string">            return 0</span></span><br><span class="line"><span class="hljs-string">        # n = 1 f(1) = 1</span></span><br><span class="line"><span class="hljs-string">        if n == 1:</span></span><br><span class="line"><span class="hljs-string">            return 1</span></span><br><span class="line"><span class="hljs-string">        # if n &gt; 1  f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="hljs-string">        if n &gt; 1:</span></span><br><span class="line"><span class="hljs-string">            num = self.Fibonacci(n-1) + self.Fibonacci(n-2)</span></span><br><span class="line"><span class="hljs-string">            return num</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        return None</span></span><br><span class="line"><span class="hljs-string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># n = 0 f(0) = 0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># n = 1 f(1) = 1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        b = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># if n &gt; 1  f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="hljs-comment"># h = a + b</span></span><br><span class="line">        <span class="hljs-comment"># 当 n = 2 h = 0 + 1</span></span><br><span class="line">        ret = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#三个变量，互相转换 来实现</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>):</span><br><span class="line">            ret = a + b</span><br><span class="line">            b = a</span><br><span class="line">            a = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"><span class="hljs-comment">#第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n</span></span><br><span class="line"></span><br><span class="line"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#初始列表值 为 0 1 第三项为 0+1 = 1；</span></span><br><span class="line">         res = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</span><br><span class="line">         <span class="hljs-comment">#临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。</span></span><br><span class="line">         <span class="hljs-keyword">while</span> len(res) &lt;= n:</span><br><span class="line">                <span class="hljs-comment">#取出列表的最后两项，然后求和，并添加到列表中。</span></span><br><span class="line">             res.append(res[<span class="hljs-number">-1</span>] + res[<span class="hljs-number">-2</span>])</span><br><span class="line">         <span class="hljs-keyword">return</span> res[n]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-青蛙跳台阶"><a href="#7-青蛙跳台阶" class="headerlink" title="7.青蛙跳台阶"></a>7.青蛙跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</strong></p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/qinwa.png" alt></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 (1)</span></span><br><span class="line"><span class="hljs-string">2 (11,2)</span></span><br><span class="line"><span class="hljs-string">3 (12,21,111)</span></span><br><span class="line"><span class="hljs-string">4 (1111,22,112,121,211)</span></span><br><span class="line"><span class="hljs-string">5 (11111,221,212,122,1121,2111,1112,1211)</span></span><br><span class="line"><span class="hljs-string">6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(self, number)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第一种方法：</span></span><br><span class="line">         res = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span><br><span class="line">         <span class="hljs-keyword">while</span> len(res) &lt;= number:</span><br><span class="line">             res.append(res[<span class="hljs-number">-1</span>] + res[<span class="hljs-number">-2</span>])</span><br><span class="line">         <span class="hljs-keyword">return</span> res[number]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         a = <span class="hljs-number">1</span></span><br><span class="line">         b = <span class="hljs-number">1</span></span><br><span class="line">         <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,number):</span><br><span class="line">             a,b = b,a+b</span><br><span class="line">         <span class="hljs-keyword">return</span> a</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number ==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number == <span class="hljs-number">2</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span></span><br><span class="line">        ret = <span class="hljs-number">0</span></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        b = <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,number+<span class="hljs-number">1</span>):</span><br><span class="line">            ret = a+b</span><br><span class="line">            a = b</span><br><span class="line">            b = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="8-变态跳台阶"><a href="#8-变态跳台阶" class="headerlink" title="8.变态跳台阶"></a>8.变态跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 (1)</span></span><br><span class="line"><span class="hljs-string">2 (11,2)</span></span><br><span class="line"><span class="hljs-string">3 (111,21,3,12)</span></span><br><span class="line"><span class="hljs-string">4 (1111,22,13,31,211,112,121,4)</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">n  2^(n-1)</span></span><br><span class="line"><span class="hljs-string">f(n)  = f(n-1) + f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="hljs-string">f(n-1) = f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="hljs-string">f(n) = 2f(n-1)  n &gt; 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">f(1) = 1 n = 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(self, number)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#第一种方法：</span></span><br><span class="line">        <span class="hljs-comment"># return pow(2,number-1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第二种方法：</span></span><br><span class="line">        <span class="hljs-comment"># return 2 ** (number - 1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第三种方法：</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number ==<span class="hljs-number">1</span> :</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        ret = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,number+<span class="hljs-number">1</span>):</span><br><span class="line">            a,ret = ret,<span class="hljs-number">2</span>*ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-调整数组顺序使奇数位于偶数前面-本题知识点-数组"><a href="#9-调整数组顺序使奇数位于偶数前面-本题知识点-数组" class="headerlink" title="9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]"></a>9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 <em>数组</em>]</h2><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(self, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度是o(n)</span></span><br><span class="line">        <span class="hljs-comment">#空间复杂度o(n)</span></span><br><span class="line">        <span class="hljs-comment"># ret = []</span></span><br><span class="line">        <span class="hljs-comment"># for i in array:</span></span><br><span class="line">        <span class="hljs-comment">#     if i % 2 == 1:</span></span><br><span class="line">        <span class="hljs-comment">#         ret.append(i)</span></span><br><span class="line">        <span class="hljs-comment"># for i in array:</span></span><br><span class="line">        <span class="hljs-comment">#     if i % 2 == 0:</span></span><br><span class="line">        <span class="hljs-comment">#         ret.append(i)</span></span><br><span class="line">        <span class="hljs-comment"># return ret</span></span><br><span class="line">		<span class="hljs-comment">#用了冒泡排序的原理，判断奇偶数，如果一个是偶数而且下一个是奇数，那么两个就互换位置。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(array) - i - <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> array[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> array[j + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">                    array[j], array[j + <span class="hljs-number">1</span>] = array[j + <span class="hljs-number">1</span>], array[j]</span><br><span class="line">        <span class="hljs-keyword">return</span> array</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="知识点：冒泡排序法"><a href="#知识点：冒泡排序法" class="headerlink" title="知识点：冒泡排序法"></a>知识点：冒泡排序法</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(array)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">#一共 需要 n 次 的循环，每一个都要找到没排好序的最大值。</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="hljs-comment">#将没有排好序的数组 找最大值，并一直将最大值换到最顶端。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(array)-i<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-comment">#判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> array[j] &gt; array[j+<span class="hljs-number">1</span>]:</span><br><span class="line">                array[j],array[j+<span class="hljs-number">1</span>] = array[j+<span class="hljs-number">1</span>],array[j]</span><br><span class="line">    <span class="hljs-keyword">return</span> array</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="10-栈的压入，弹出序列-本题考点-栈"><a href="#10-栈的压入，弹出序列-本题考点-栈" class="headerlink" title="10.栈的压入，弹出序列  [^本题考点 栈]"></a>10.栈的压入，弹出序列  [^本题考点 <em>栈</em>]</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先要先有一个栈，列表</span></span><br><span class="line">        <span class="hljs-comment">#按照 pushV 的方式去压入栈，</span></span><br><span class="line">        <span class="hljs-comment"># 弹出的时候是需要循环判断是否需要弹出</span></span><br><span class="line">        <span class="hljs-comment">#判断是否需要弹出的时机，刚刚压入过后就判断</span></span><br><span class="line">        <span class="hljs-comment">#判断需要弹出的情况的条件，压入栈的顶部和弹出栈的顶部数据相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#先判断pushV 这个栈里是否为空，如果是空的话返回none，或者说这两个序列的长度不相同。那也返回none。</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pushV == [] <span class="hljs-keyword">or</span> len(pushV ) != len(popV):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">		<span class="hljs-comment">#首先有个栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="hljs-comment">#定义一个变量，它作为弹出序列的索引存在。</span></span><br><span class="line">        index = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#遍历 pushV 的这个列表里的元素，并把它每个都添加进stack 这个列表中</span></span><br><span class="line">        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> pushV:</span><br><span class="line">            stack.append(item)</span><br><span class="line">            <span class="hljs-comment">#做判断 1，stack 里有元素 并且 stack里的最后一个元素 等于 popV 这个序列里 第一个元素，那么就进去这个循环，然后把stack里的这个元素删掉，这样下次还会添加新的元素，然后再和 popV 里的下一个元素 做判断，所以这个时候 index  这个索引值就要发生变化了，这个时候比较的是 它的下一个值。往右移动一位。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>] == popV[index]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                index += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        if stack == []:</span></span><br><span class="line"><span class="hljs-string">            return True</span></span><br><span class="line"><span class="hljs-string">        else:</span></span><br><span class="line"><span class="hljs-string">            return False</span></span><br><span class="line"><span class="hljs-string">            </span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-comment">#最后 直到 把 pushV 里的元素都遍历完，然后stack内的元素都比较完，并都删除完，就返回True，如果说 它不为空：说明 pushV 里有的元素 是popV 中所没有的，这个时候就说明他们不相等，那么这个情况，就需要返回 False。</span></span><br><span class="line">        <span class="hljs-comment">#以下代码与以上代码 共同实现的相同的功能，但是下面的代码相对来说等 “装B” 一点。节省代码空间。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> stack == [] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="知识点链表："><a href="#知识点链表：" class="headerlink" title="知识点链表："></a><code>知识点</code>链表：</h4><p>链表是一种物理<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/8727749" target="_blank" rel="noopener">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782" target="_blank" rel="noopener">存储结构</a>，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313" target="_blank" rel="noopener">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>域。 相比于<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081" target="_blank" rel="noopener">线性表</a><a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/9845234" target="_blank" rel="noopener">顺序结构</a>，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiao.png" alt></p>
<p>数组 就是连续的 同一个类型的 元素，而且必须是固定的长度。</p>
<p>如果我们想要非固定的长度来存储数据。这个时候就出现了链表。</p>
<hr>
<h2 id="11-从栈尾到栈头打印链表-本题知识点-链表"><a href="#11-从栈尾到栈头打印链表-本题知识点-链表" class="headerlink" title="11. 从栈尾到栈头打印链表 [^本题知识点 链表]"></a>11. 从栈尾到栈头打印链表 [^本题知识点 <em>链表</em>]</h2><p><strong>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># pointer 指针 temporary临时数据;node 结点</span></span><br><span class="line">        <span class="hljs-comment">#给一个 arraylist 空列表，然后向这个里面压入数据，来输出 这个链表值 的一个从尾到头 的顺序值。</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="hljs-comment">#把 listNode 这个链表 传给一个 变量</span></span><br><span class="line">        pTemp = listNode</span><br><span class="line">        <span class="hljs-comment">#当这个变量 存在时 有值时：</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pTemp:</span><br><span class="line">            <span class="hljs-comment">#使用 insert 的原因是：insert 可以在指定位置之前插入元素，列表.insert(索引，值)</span></span><br><span class="line">            <span class="hljs-comment">#在空列表中起始位置，插入 pTemp的第一个值，然后 给pTemp 赋值 为 pTemp.next （下一个值） </span></span><br><span class="line">            ret.insert(<span class="hljs-number">0</span>, pTemp.val)</span><br><span class="line">            <span class="hljs-comment">#更改 指针，使指针指向下一个 元素</span></span><br><span class="line">            pTemp = pTemp.next</span><br><span class="line">		<span class="hljs-comment">#最后返回我们 这个 插入值的 列表 </span></span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/congtou.png" alt></p>
<p>如图所示：打印出 3 2 1 即为我们的目标。</p>
<hr>
<h2 id="12-链表中的倒数第k个结点-本题考点-链表"><a href="#12-链表中的倒数第k个结点-本题考点-链表" class="headerlink" title="12.链表中的倒数第k个结点[^本题考点 链表]"></a>12.链表中的倒数第k个结点[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(self, head, k)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># k 如果 比我们的链表的长度还要大的话，我们直接返回None</span></span><br><span class="line">        <span class="hljs-comment"># k 如果小于链表的长度，我们可以定义两个变量，这两个变量中间间隔k</span></span><br><span class="line">        <span class="hljs-comment">#用两个指针做一个尺子，然后让尺子在跳跳，然后就会找到 第k 个结点</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#起始位置 第一个和第二个指针 都是从头开始的。</span></span><br><span class="line">        firstPoint = head</span><br><span class="line">        secondPoint = head</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#首先让一个指针先开始移动，那么就是遍历我们的k 值，让我们的 第一个指针移动 k 步。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):</span><br><span class="line">            <span class="hljs-comment">#如果第一个指针为空的话，那么说明我们的k值为空，那么我们的这个链表就为空。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> firstPoint == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">            <span class="hljs-comment">#第一个指针 移动一步 </span></span><br><span class="line">            firstPoint = firstPoint.next</span><br><span class="line">		<span class="hljs-comment">#当 第一个指针不为空的时候，</span></span><br><span class="line">        <span class="hljs-keyword">while</span> firstPoint != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-comment">#移动尺子，移动距离为  k 的长度， 直到 第一个指针点 为空的时候 ，就到了 这个链表的结尾，此时就返回 第二个指针 那么就为 倒数第 k 个结点。</span></span><br><span class="line">            firstPoint = firstPoint.next</span><br><span class="line">            secondPoint = secondPoint.next</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> secondPoint</span><br></pre></td></tr></table></figure>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiaozhong.png" alt></p>
<hr>
<p>如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。</p>
<h2 id="13-反转链表-本题考点-链表"><a href="#13-反转链表-本题考点-链表" class="headerlink" title="13.反转链表[^本题考点 链表]"></a>13.反转链表[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，反转链表后，输出新链表的表头。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"> pHead始终指向要反转的结点</span></span><br><span class="line"><span class="hljs-string">last 指向反转后的首结点</span></span><br><span class="line"><span class="hljs-string">每反转一个结点，</span></span><br><span class="line"><span class="hljs-string">把pHead结点的下一个结点指向last,</span></span><br><span class="line"><span class="hljs-string">last指向pHead成为反转后首结点,</span></span><br><span class="line"><span class="hljs-string">再把pHead向前移动一个结点直至None结束</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回ListNode</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#首先判断这个链表里是否只有一个结点，只有一个结点那么它就不需要发生变化，它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="hljs-comment"># 这个时候就直接返回这个 pHead</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pHead <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> pHead.next:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead</span><br><span class="line">        <span class="hljs-comment">#首先要明白 反转过后，第一个数值的指针的结点指向的是none 也就是一个指向反转后的首结点 为none</span></span><br><span class="line">        last = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#当 要反转的结点 pHead 存在的时候</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pHead:</span><br><span class="line">            <span class="hljs-comment">#先找到第一个元素的结点指向的元素，赋值给一个临时变量</span></span><br><span class="line">            temp = pHead.next</span><br><span class="line">            <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">            本来一个元素的结点 是要指向它的下一个 元素的 .</span></span><br><span class="line"><span class="hljs-string">            反转后 就是  这个元素 要指向它的 上一个 元素 .</span></span><br><span class="line"><span class="hljs-string">            </span></span><br><span class="line"><span class="hljs-string">            """</span></span><br><span class="line">            <span class="hljs-comment">#然后第一次循环 把这第一个元素的结点 改为 none last 第一个值 是 none (此时还没有发生改变的last)</span></span><br><span class="line">            <span class="hljs-comment"># 之后循环 就是 每 反转一个结点 把pHead结点的下一个结点指向last,</span></span><br><span class="line">            pHead.next = last</span><br><span class="line">            <span class="hljs-comment">#下一步 是把 pHead 这个 元素的 赋值给last</span></span><br><span class="line">            <span class="hljs-comment"># last指向pHead成为反转后首结点,</span></span><br><span class="line">            last = pHead</span><br><span class="line">            <span class="hljs-comment"># 再把pHead向前移动一个结点直至None结束</span></span><br><span class="line">            pHead = temp</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> last</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">反转需要两步 ，第一步找到它的 结点，第二步改变结点就可以了；</span></span><br><span class="line"><span class="hljs-string">之后需要 把结点 赋值为 这个元素的 本身 ；</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">循环：</span></span><br><span class="line"><span class="hljs-string"> 找到 元素结点指向的元素，</span></span><br><span class="line"><span class="hljs-string">目标是 让元素结点指向的元素 改为 自己本身。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#第二种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 将现有的头换成尾，尾部的next为空</span></span><br><span class="line"><span class="hljs-string">2 将从第二个node开始，循环将next指向前一个</span></span><br><span class="line"><span class="hljs-string">3 需要一直有一个指针指向还没有反转的链表的头部</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回ListNode</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#判断是否为空值，没有元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#判断是否只有一个元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead.next == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead</span><br><span class="line">		<span class="hljs-comment">#左边指针为 头 第一个 指针</span></span><br><span class="line">        leftPointer = pHead</span><br><span class="line">        <span class="hljs-comment">#中间 的指针 为 第二个指针</span></span><br><span class="line">        midPointer = pHead.next</span><br><span class="line">        <span class="hljs-comment">#右边的指针  为 指向 中间 指针后的 所有的元素 </span></span><br><span class="line">        rightPointer = midPointer.next</span><br><span class="line">        <span class="hljs-comment">#左边的指针为 起始 的 元素， 反转后 它的next 为 None；</span></span><br><span class="line">        leftPointer.next = <span class="hljs-literal">None</span></span><br><span class="line">		<span class="hljs-comment">#循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> rightPointer:</span><br><span class="line">            <span class="hljs-comment">#中间指针指向的为上一个 元素 即 leftPointer</span></span><br><span class="line">            midPointer.next = leftPointer</span><br><span class="line">            <span class="hljs-comment">#三个指针开始往右移。每次移一个。</span></span><br><span class="line">            <span class="hljs-comment">#左边指针 往右移一个 就是中间指针的位置</span></span><br><span class="line">            leftPointer = midPointer</span><br><span class="line">            <span class="hljs-comment">#中间指针 往 右 移 一个，就时 右边指针的位置</span></span><br><span class="line">            midPointer = rightPointer</span><br><span class="line">            <span class="hljs-comment">#右边指针往右移 一个 ，就时 右边指针的下一个。</span></span><br><span class="line">            rightPointer = rightPointer.next</span><br><span class="line">		<span class="hljs-comment">#当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。</span></span><br><span class="line">        midPointer.next = leftPointer</span><br><span class="line">        <span class="hljs-comment">#最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> midPointer</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/fanzhuan.png" alt></p>
<hr>
<h2 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14.复杂链表的复制"></a>14.复杂链表的复制</h2><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/复杂链表的复制.png" alt></p>
<hr>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class RandomListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.label = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-comment">#         self.random = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回 RandomListNode</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Clone</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#判断当pHead 为空值的时候 返回的是none</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#把第一个 A 的值 赋给 node 为A‘</span></span><br><span class="line">            node = RandomListNode(pTmp.label)</span><br><span class="line">            <span class="hljs-comment">#此时 node A' 的结点指向的是 原来A 的结点指向的 值</span></span><br><span class="line">            node.next = pTmp.next</span><br><span class="line">            <span class="hljs-comment">#将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">            pTmp.next = node</span><br><span class="line">            <span class="hljs-comment">#将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素</span></span><br><span class="line">            pTmp = node.next</span><br><span class="line">        <span class="hljs-comment"># 实现新建的node的random的指向</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp.random:</span><br><span class="line">                <span class="hljs-comment">#那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。</span></span><br><span class="line">                pTmp.next.random = pTmp.random.next</span><br><span class="line">            <span class="hljs-comment">#建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="hljs-comment">#当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。</span></span><br><span class="line">            pTmp = pTmp.next.next</span><br><span class="line">        <span class="hljs-comment"># 断开原来的node 和 新的node 之间的链接</span></span><br><span class="line">        <span class="hljs-comment">#最后 为断开 链接 的操作</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-comment">#复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        <span class="hljs-comment">#复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        pNewTmp = pHead.next</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#print(pTmp.label)</span></span><br><span class="line">            <span class="hljs-comment">#将旧链表 A 的指向结点 改为  A‘ 的指向的下一个 的B。</span></span><br><span class="line">            pTmp.next = pTmp.next.next</span><br><span class="line">            <span class="hljs-comment">#如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pNewTmp.next:</span><br><span class="line">                <span class="hljs-comment">#那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’</span></span><br><span class="line">                pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                <span class="hljs-comment">#然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘ </span></span><br><span class="line">                pNewTmp = pNewTmp.next</span><br><span class="line">            <span class="hljs-comment">#上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B </span></span><br><span class="line">            pTmp = pTmp.next</span><br><span class="line">            <span class="hljs-comment">#如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line">        <span class="hljs-comment">#最后返回这个复制好的新链表。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> newHead</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">#第二种方法：</span></span><br><span class="line">    	 <span class="hljs-keyword">import</span> copy</span><br><span class="line">         chead=copy.deepcopy(pHead)</span><br><span class="line">         <span class="hljs-keyword">return</span> chead</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="15-两个链表之间的第一个公共结点"><a href="#15-两个链表之间的第一个公共结点" class="headerlink" title="15.两个链表之间的第一个公共结点"></a>15.两个链表之间的第一个公共结点</h2><p><strong>输入两个链表，找出它们的第一个公共结点</strong></p>
<p>如图：</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/liangge.png" alt></p>
<hr>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="hljs-comment">#当链表1 和链表2 同时存在的时候</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp1 <span class="hljs-keyword">and</span> pTmp2:</span><br><span class="line">            <span class="hljs-comment">#当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp1 == pTmp2:</span><br><span class="line">                <span class="hljs-keyword">return</span> pTmp1</span><br><span class="line">            <span class="hljs-comment">#移动指针的位置，两个同时移动，</span></span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">            </span><br><span class="line">        <span class="hljs-comment">#第一个参数给比较短的那个链表的值</span></span><br><span class="line">        <span class="hljs-comment">#第二个参数给比较长的链表的值</span></span><br><span class="line">        <span class="hljs-comment">#第三个参数是比较短的那个链表头</span></span><br><span class="line">        <span class="hljs-comment">#第四个参数是比较长的那个链表头</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findEqual</span><span class="hljs-params">(longPointer, shorPointer, longHead, shortHead)</span>:</span></span><br><span class="line">            k = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> longPointer:</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">                k += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#然后：</span></span><br><span class="line">            <span class="hljs-comment"># 先让长的那个去走k步</span></span><br><span class="line">            longPointer = longHead</span><br><span class="line">            shortPointer = shortHead</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">			<span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> longPointer != shortPointer:</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">                shortPointer = shortPointer.next</span><br><span class="line">            <span class="hljs-keyword">return</span> shortPointer</span><br><span class="line">		<span class="hljs-comment">#如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp1:</span><br><span class="line">            <span class="hljs-keyword">return</span> findEqual(pTmp1,pTmp2,pHead1,pHead2)</span><br><span class="line">            <span class="hljs-comment"># k = 0</span></span><br><span class="line">            <span class="hljs-comment"># #寻找出链表长度之间的差值</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     k += 1</span></span><br><span class="line">            <span class="hljs-comment"># #先让长的那个去走k步</span></span><br><span class="line">            <span class="hljs-comment"># pTmp2 = pHead2</span></span><br><span class="line">            <span class="hljs-comment"># pTmp1 = pHead1</span></span><br><span class="line">            <span class="hljs-comment"># for  i in range(k):</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1=pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1 != pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment"># return pTmp1</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp2:</span><br><span class="line">            <span class="hljs-keyword">return</span> findEqual(pTmp1, pTmp2, pHead1, pHead2)</span><br><span class="line">            <span class="hljs-comment"># k = 0</span></span><br><span class="line">            <span class="hljs-comment"># # 寻找出链表长度之间的差值</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment">#     k += 1</span></span><br><span class="line">            <span class="hljs-comment"># # 先让长的那个去走k步</span></span><br><span class="line">            <span class="hljs-comment"># pTmp2 = pHead2</span></span><br><span class="line">            <span class="hljs-comment"># pTmp1 = pHead1</span></span><br><span class="line">            <span class="hljs-comment"># for i in range(k):</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1 != pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment"># return pTmp2</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="16-合并两个排序的链表-本题考点-链表"><a href="#16-合并两个排序的链表-本题考点-链表" class="headerlink" title="16.合并两个排序的链表 [^本题考点  链表]"></a>16.合并两个排序的链表 [^本题考点  链表]</h2><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong></p>
<p>如图：为两个递增的链表</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/liang.png" alt></p>
<p>如下图，合并成一个单调不减链表</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/hecheng.png" alt></p>
<hr>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">比较两个链表的首结点，哪个小的的结点则合并到第三个链表尾结点，并向前移动一个结点。</span></span><br><span class="line"><span class="hljs-string">步骤一结果会有一个链表先遍历结束，或者没有</span></span><br><span class="line"><span class="hljs-string">第三个链表尾结点指向剩余未遍历结束的链表</span></span><br><span class="line"><span class="hljs-string">返回第三个链表首结点</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回合并后列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="hljs-number">0</span>)</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="hljs-keyword">while</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="hljs-keyword">if</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="hljs-keyword">elif</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next</span><br><span class="line">        </span><br><span class="line"><span class="hljs-comment">#第二种方法：</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回合并后列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先判断两个链表是不是为空。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead2</span><br><span class="line">        <span class="hljs-keyword">if</span> pHead2 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead1</span><br><span class="line">		<span class="hljs-comment">#比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。</span></span><br><span class="line">        newHead = pHead1 <span class="hljs-keyword">if</span> pHead1.val &lt; pHead2.val <span class="hljs-keyword">else</span> pHead2</span><br><span class="line">		</span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="hljs-comment">#判断 如果新表头 是 表1 的头的话 那么 新表头</span></span><br><span class="line">        <span class="hljs-keyword">if</span> newHead == pTmp1:</span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">        <span class="hljs-comment">#</span></span><br><span class="line">        previousPointer = newHead</span><br><span class="line">		</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp1 <span class="hljs-keyword">and</span> pTmp2:</span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp1.val &lt; pTmp2.val:</span><br><span class="line">                previousPointer.next = pTmp1</span><br><span class="line">                previousPointer = pTmp1</span><br><span class="line">                pTmp1 = pTmp1.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                previousPointer.next = pTmp2</span><br><span class="line">                previousPointer = pTmp2</span><br><span class="line">                pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp1 == <span class="hljs-literal">None</span>:</span><br><span class="line">        </span><br><span class="line">            previousPointer.next = pTmp2</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            previousPointer.next = pTmp1</span><br><span class="line">            </span><br><span class="line">        <span class="hljs-keyword">return</span> newHead</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="17-圆圈中最后剩下的数-本题考点-模拟"><a href="#17-圆圈中最后剩下的数-本题考点-模拟" class="headerlink" title="17.圆圈中最后剩下的数 [^本题考点 模拟]"></a>17.圆圈中最后剩下的数 [^本题考点 <em>模拟</em>]</h2><p><strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</strong></p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/xiao.png" alt></p>
<hr>
<p>思路分析：</p>
<p>这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。</p>
<p>链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).</p>
<p>链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).</p>
<p>这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。</p>
<p>链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)</p>
<p>  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。</p>
<p>但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：</p>
<p>(iii+m)%n    我们一共是 n 个值，从0-(n-1);</p>
<p>f(n-1) = iii</p>
<p>所以 f(n) = f `(n-1) = (iii+m)%n</p>
<p>所以 f(n) = (f(n-1)+m)</p>
<p>那么这个通项表达式我们就找到了，再去编写代码。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#通过推导公式可得 f(n) = (f(n-1)+m)%n</span></span><br><span class="line">        <span class="hljs-comment">#首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment">#只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        value = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度 o(n)</span></span><br><span class="line">        <span class="hljs-comment">#从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 </span></span><br><span class="line">        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-comment">#现在数到的 m-1 这个值 的索引。对应上上面的公式。</span></span><br><span class="line">            currentValue = (value+m) % index</span><br><span class="line">            <span class="hljs-comment">#把找到的这个下标值 赋值给 value</span></span><br><span class="line">            value = currentValue</span><br><span class="line">        <span class="hljs-comment">#返回编号</span></span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="18-链表中环的入口点-本题知识点-链表"><a href="#18-链表中环的入口点-本题知识点-链表" class="headerlink" title="18.链表中环的入口点 [^本题知识点  链表]"></a>18.链表中环的入口点 [^本题知识点  链表]</h2><p><strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</strong></p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiaozhonghuan.png" alt></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。</span></span><br><span class="line">        <span class="hljs-comment">#循环跳</span></span><br><span class="line">        <span class="hljs-comment">#要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> </span><br><span class="line">		<span class="hljs-comment">#定义两个指针，一个快的一个慢的。</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        slowPointer = pHead</span><br><span class="line">		<span class="hljs-comment">#当快指针存在时，而且快指针的结点指向的下一个也存在</span></span><br><span class="line">        <span class="hljs-keyword">while</span> fastPointer <span class="hljs-keyword">and</span> fastPointer.next :</span><br><span class="line">            <span class="hljs-comment">#那么让快指针走两步</span></span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            <span class="hljs-comment">#让慢指针走一步</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">            <span class="hljs-comment">#如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break</span></span><br><span class="line">            <span class="hljs-keyword">if</span> fastPointer == slowPointer:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment">#如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> fastPointer == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> fastPointer.next == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度</span></span><br><span class="line">        <span class="hljs-comment">#假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 那么  L = s + d</span></span><br><span class="line">        <span class="hljs-comment">#假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少</span></span><br><span class="line">        <span class="hljs-comment"># fast 走的长度 就是 ( m + d ) * n + d + s = 2 L</span></span><br><span class="line">        <span class="hljs-comment">#带入 ( m + d ) * n + d + s = 2 （s + d ）</span></span><br><span class="line">        <span class="hljs-comment"># s = m + (n-1)(m+d)</span></span><br><span class="line">		<span class="hljs-comment">#有环的话，那么就让快指针从头开始走，这次一次走一步，</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">		<span class="hljs-comment">#此时慢指针还在环里走着，没有走到结点</span></span><br><span class="line">        <span class="hljs-keyword">while</span> fastPointer != slowPointer:</span><br><span class="line">            fastPointer = fastPointer.next</span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        <span class="hljs-comment">#当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> fastPointer</span><br></pre></td></tr></table></figure>
<p>定义：</p>
<p>假设 slow 走了 L 步，那么 fast 就走了 2L 步。</p>
<p> 我们 链表的头部 到 链表的环的入口结点处 的距离是 S</p>
<p>那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 </p>
<p>链表的环中，慢指针走过的距离是d，那么没走过的距离是M。</p>
<p>我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。</p>
<p>那么 L = s + d</p>
<p>2L = 2(s+d) = n*(m + d) + d + s</p>
<p>由上面公式 推导出 n(m+d) = s + d</p>
<p>得到：s = n(m+d) -d；</p>
<p>s = nm + (n-1)(d)<br>s = m + (n-1)(m+d)</p>
<hr>
<h2 id="19-二进制中的1的个数"><a href="#19-二进制中的1的个数" class="headerlink" title="19.二进制中的1的个数"></a>19.二进制中的1的个数</h2><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</strong></p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a><code>知识点:</code></h4><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>特性：</p>
<p>1、一个负整数（或原码）与其补数（或补码）相加，和为模。</p>
<p>2、对一个整数的补码再求补码，等于该整数自身。</p>
<p>3、补码的正零与负零表示方法相同</p>
<h4 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 ~"></a>按位取反 ~</h4><p>~，用法只有一个那就是按位取反，需要注意的是：</p>
<ul>
<li>~的按位取反，包括符号位</li>
<li>正数各位取反变为负数，显示时转化为其补码</li>
<li>负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位去反</li>
</ul>
<h5 id="1-5"><a href="#1-5" class="headerlink" title="1. ~5"></a>1. ~5</h5><p>5 的二进制为 0101，</p>
<p>~5</p>
<ul>
<li>（1）各位取反，1010</li>
<li>（2）变为负数，转化为其补码形式（符号位保持不变），各位取反 1（1101），再加1（1110），也即 -6</li>
</ul>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~<span class="hljs-number">5</span></span><br><span class="line">&gt;&gt; <span class="hljs-number">-6</span></span><br></pre></td></tr></table></figure>
<h5 id="2-5"><a href="#2-5" class="headerlink" title="2. ~(-5)"></a>2. ~(-5)</h5><p>-5 因为是负数，存储时存储的是其补码：</p>
<ul>
<li>-5 的补码是：1011，</li>
<li>~(-5)将其各位取反（包括符号位），也即 0100（4）</li>
</ul>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~(<span class="hljs-number">-5</span>)</span><br><span class="line">&gt;&gt; <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#第一种：</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#补码：正数不变，负数是它的正数的反码 + 1</span></span><br><span class="line">        <span class="hljs-comment"># -2 补码： -2 的 1 0000.。。000010，</span></span><br><span class="line">        <span class="hljs-comment">#                 1 1111.。。111101 + 1</span></span><br><span class="line">        <span class="hljs-comment">#-2 的补码就是    1 1111.。。111110</span></span><br><span class="line">        <span class="hljs-comment">#把输入的正数n转化为二进制的数，并把0b 替换掉，计算1的数量，如果输入的值不是正数的话</span></span><br><span class="line">        <span class="hljs-comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。</span></span><br><span class="line">        <span class="hljs-comment">#那么就是 2 的32 次方 然后 + n  这是在取一个负数的补码  就相当于  n &amp; 0xffffffff</span></span><br><span class="line">        <span class="hljs-comment">#然后计算 这个数里面 1 的 数量</span></span><br><span class="line">        <span class="hljs-keyword">return</span> bin(n).replace(<span class="hljs-string">"0b"</span>, <span class="hljs-string">""</span>).count(<span class="hljs-string">"1"</span>) <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> bin(<span class="hljs-number">2</span> ** <span class="hljs-number">32</span> + n).replace(<span class="hljs-string">"0b"</span>, <span class="hljs-string">""</span>).count(<span class="hljs-string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">#第二种：</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># 1 出现的次数为0 次</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#判断 这个数 n 是不是负数，如果是负数的话 求其补码：</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:</span><br><span class="line">            n = n &amp; <span class="hljs-number">0xffffffff</span></span><br><span class="line">        <span class="hljs-comment">#如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.</span></span><br><span class="line">        <span class="hljs-keyword">while</span> n:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line">            n = (n - <span class="hljs-number">1</span>) &amp; n</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.</span></span><br><span class="line"><span class="hljs-string">    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。</span></span><br><span class="line"><span class="hljs-string">    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.</span></span><br><span class="line"><span class="hljs-string">    </span></span><br><span class="line"><span class="hljs-string">    """</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="20-不用加减乘除做加法-本题考点-按位运算"><a href="#20-不用加减乘除做加法-本题考点-按位运算" class="headerlink" title="20.不用加减乘除做加法[^本题考点 按位运算]"></a>20.不用加减乘除做加法[^本题考点 <em>按位运算</em>]</h2><p><strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</strong></p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/buyong.png" alt></p>
<p>分析：</p>
<p>对于数字运算，如果说四则运算不能用的话，那么我们只能用位运算来做了。</p>
<p>我们以 5 + 17 为例 结果为 22，那么 22 的计算结果，我们可以分为三步 来进行：</p>
<p>​    第一步： 只做各位相加不进位  也就是说 没一位上的数字 相应的来相加 但是不进位，那么  5 + 7 为 12 </p>
<p>​    个位数 5 和 7 相加 不进位 是2  十位是0 和1  相加 为 1 </p>
<p>​    第二步： 5 + 7 中有进位，进位值 是10 ;</p>
<p>​    第三步： 把前面两个结果 加起来： 12 + 10 = 22</p>
<p>以上为我们用十进制计算的 策略，那么 我们用于位运算中是不是也合适，我们来举个栗子：</p>
<p>还是以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；</p>
<p>第一步：各位相加 但不进位： 101 + 10001 = 10110  不进位的话  结果为 10100 （最后一位两个数都是1，相加的结果需要进位，但是这一位不进位，意味着结果仍然是0）</p>
<p>第二步： 记下进位，它只在最后一位相加时产生了一个进位。</p>
<p>第三步： 把前面两个结果相加，得到的结果是 10110.</p>
<p><strong>那么现在我们把前面的 二进制的加法用位运算来替代的话</strong></p>
<p>第一步的 求 和 运算就是 不考虑 进位的话，对每一位来相加，0 和0 1 和1 的结果都是0,0+1，或者1+0 的结果 都是1；那么我们会看出它与我们学过的异或运算相同，就是相同为假，不同为真，所以叫 异  或  XOR 。</p>
<p>第二步： 对0 加 0、1加0、0加1 而言，都不会产生进位，只有1+1 的时候，会产生一个进位。此时 我们可以想象成两个数 先做了一个 位 与 &amp; 运算，然后再向 左移 一位。只有两个数是1 的时候，位与 &amp; 得到的结果是 1，其余的都是0。</p>
<p>第三步：把前面两个步骤的结果再相加，然后在继续判断是否有进位，直到没有进位为止，那么此时的相加的过程，依然是重复前面的两步，直到不产生进位为止。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Add</span><span class="hljs-params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#第一种代码：循环。简洁但是原理相同，那么我们以下面第二段代码为例；来解析。</span></span><br><span class="line">        <span class="hljs-comment"># while (num2):</span></span><br><span class="line">        <span class="hljs-comment">#     num1, num2 = (num1 ^ num2) &amp; 0xFFFFFFFF, ((num1 &amp; num2) &lt;&lt; 1) &amp; 0xFFFFFFFF</span></span><br><span class="line">        <span class="hljs-comment"># return num1 if num1 &lt;= 0x7FFFFFFF else ~(num1 ^ 0xFFFFFFFF)</span></span><br><span class="line">		</span><br><span class="line">        <span class="hljs-comment">#第二种代码：</span></span><br><span class="line">        <span class="hljs-comment">#首先两个数做 一个 异或 运算^ 那就是 在不进位的情况下，让两个相加 求和。</span></span><br><span class="line">        xorNum = num1 ^ num2</span><br><span class="line">        <span class="hljs-comment">#让两个数 做 位与 操作，然后再向 左 移 一位，得到它 向前进位的值。</span></span><br><span class="line">        andNum = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span></span><br><span class="line">		<span class="hljs-comment">#判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> andNum != <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#那么我们就继续上面的操作。但是这次的 数值 改为上次的两个结果，</span></span><br><span class="line">            <span class="hljs-comment">#一个 是异或的结果，一个是 与 操作 &amp; 以后 左移一位的 结果。</span></span><br><span class="line">            tmp1 = xorNum ^ andNum</span><br><span class="line">            tmp2 = (xorNum &amp; andNum) &lt;&lt; <span class="hljs-number">1</span></span><br><span class="line">			<span class="hljs-comment">#因为如果这个数为负数的话，那么负数 左移 一位与正数 不同，负数 是数值变小，正数 数值变大</span></span><br><span class="line">            <span class="hljs-comment">#如果是正数的话那么这一步就 不变，如果是负数的话，这一步就对负数来起作用。</span></span><br><span class="line">            <span class="hljs-comment">#对于python来说  负数的 二进制 可能会有无数个1，我们用这个方法让它变成一个可数的数字长度。</span></span><br><span class="line">            tmp1 = tmp1 &amp; <span class="hljs-number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">            xorNum = tmp1</span><br><span class="line">            andNum = tmp2</span><br><span class="line">         <span class="hljs-comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。 0xffffffff </span></span><br><span class="line">		<span class="hljs-comment"># ~(xorNum ^ 0xFFFFFFFF)  这个是 异或数  与  模 来 异或，最后 按位 取反 来求得 负数的补码。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> xorNum <span class="hljs-keyword">if</span> xorNum &lt;= <span class="hljs-number">0x7ffffff</span> <span class="hljs-keyword">else</span> ~(xorNum ^ <span class="hljs-number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure>
<h2 id="21-数组中出现次数超过一半的数字-本题考点-数组"><a href="#21-数组中出现次数超过一半的数字-本题考点-数组" class="headerlink" title="21.数组中出现次数超过一半的数字[^本题考点 数组]"></a>21.数组中出现次数超过一半的数字[^本题考点 数组]</h2><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</strong></p>
<p>  思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。<br>        首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。</p>
<p>我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#dict [key] = count</span></span><br><span class="line">        <span class="hljs-comment">#o(n) 空间复杂度为O(n)</span></span><br><span class="line">     <span class="hljs-comment">#第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。</span></span><br><span class="line">        numsCount = &#123;&#125;</span><br><span class="line">        numLen = len(numbers)</span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> numsCount:</span><br><span class="line">                numsCount[num] += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                numsCount[num] = <span class="hljs-number">1</span></span><br><span class="line">             <span class="hljs-comment">#如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> numsCount[num] &gt; (numLen &gt;&gt; <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">return</span> num</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#想要空间复杂度为O（1），时间复杂度为o(n)</span></span><br><span class="line"><span class="hljs-comment">#第二种：</span></span><br><span class="line">        <span class="hljs-comment">#定义变量 上次出现的数字为0</span></span><br><span class="line">        last = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#上次出现的数字的数量为0 </span></span><br><span class="line">        lastCount = <span class="hljs-number">0</span></span><br><span class="line">		<span class="hljs-comment">#遍历数组中的数字</span></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">            <span class="hljs-comment">#如果说这个数字出现的次数为0了。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> lastCount == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-comment">#那么就把上次出现的数字，变为需要保存的那个数字。</span></span><br><span class="line">                last = num</span><br><span class="line">                <span class="hljs-comment">#并把次数设置为1 次，出现了这一次。</span></span><br><span class="line">                lastCount = <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.</span></span><br><span class="line">                <span class="hljs-keyword">if</span> num == last:</span><br><span class="line">                    lastCount += <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-comment">#如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    lastCount -= <span class="hljs-number">1</span></span><br><span class="line">		<span class="hljs-comment">#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉</span></span><br><span class="line">        <span class="hljs-keyword">if</span> lastCount == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#否则的话，就说明 数组里面 留下了没有抵消掉的数</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment">#这种情况是last可能是大于一半的数字</span></span><br><span class="line">            <span class="hljs-comment">#这个时候把 记录数字次数的变量 计数 为0 </span></span><br><span class="line">            lastCount = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment">#遍历数组中的数</span></span><br><span class="line">            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">                <span class="hljs-comment">#如果这个数与我们记录的数相等的话</span></span><br><span class="line">                <span class="hljs-keyword">if</span> num == last:</span><br><span class="line">                    <span class="hljs-comment">#让这个计数加1</span></span><br><span class="line">                    lastCount += <span class="hljs-number">1</span></span><br><span class="line">			<span class="hljs-comment">#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> lastCount &gt; (len(numbers)&gt;&gt; <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">return</span> last</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="22-数组中只出现一次的数字-数组"><a href="#22-数组中只出现一次的数字-数组" class="headerlink" title="22.数组中只出现一次的数字[^数组]"></a>22.数组中只出现一次的数字[^数组]</h2><p><strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</strong></p>
<p>思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(self, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#如果两个数相同那么两个数的异或操作为0</span></span><br><span class="line">        <span class="hljs-comment">#数组的长度如果小于2，那么就就不会有数字出现了偶数次。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(array) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">#变量赋值 两个数的异或为none</span></span><br><span class="line">        twoNumXor = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#遍历 数组中的数字</span></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:</span><br><span class="line">            <span class="hljs-comment">#判断 如果 两个数的数字异或的结果为0 的话，</span></span><br><span class="line">            <span class="hljs-keyword">if</span> twoNumXor == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-comment">#那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。</span></span><br><span class="line">                twoNumXor = num</span><br><span class="line">            <span class="hljs-comment">#如果数 这个数不为 空 的话</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。</span></span><br><span class="line">                twoNumXor = twoNumXor ^ num</span><br><span class="line">        <span class="hljs-comment">#变量  计数 为 0 </span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#当异或的 结果 为偶数时</span></span><br><span class="line">        <span class="hljs-keyword">while</span> twoNumXor % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> :</span><br><span class="line">            <span class="hljs-comment">#那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。</span></span><br><span class="line">            twoNumXor  = twoNumXor &gt;&gt; <span class="hljs-number">1</span>  <span class="hljs-comment"># 右移以为 相当于 除以2</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1</span></span><br><span class="line">        </span><br><span class="line">        mask = <span class="hljs-number">1</span> &lt;&lt; count   <span class="hljs-comment">#向左 移 位 count 位。</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。</span></span><br><span class="line">        </span><br><span class="line">        firstNum = <span class="hljs-literal">None</span></span><br><span class="line">        secondNum = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:</span><br><span class="line">            <span class="hljs-keyword">if</span> mask &amp; num == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> firstNum == <span class="hljs-literal">None</span>:</span><br><span class="line">                    firstNum = num</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    firstNum = firstNum ^ num</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> secondNum == <span class="hljs-literal">None</span>:</span><br><span class="line">                    secondNum = num</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    secondNum = secondNum ^ num</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> firstNum,secondNum</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="23-整数中1出现的次数-本题考点-数组"><a href="#23-整数中1出现的次数-本题考点-数组" class="headerlink" title="23.整数中1出现的次数[^本题考点 数组]"></a>23.整数中1出现的次数[^本题考点 数组]</h2><p><strong>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</strong></p>
<p> <img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/zhengshu.png" alt></p>
<hr>
<p>如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。</p>
<p>那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。</p>
<p><strong>若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ </strong></p>
<p>​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有</p>
<p><code>0-3458</code> 个数 那么就一共是 3459 中可能性。</p>
<p>​    <strong>那么十万位 后面 出现1 的情况有多少种 可能性 ？</strong></p>
<p>​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 <code>10^5</code>. </p>
<p>那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。</p>
<p>​    <strong>接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？</strong></p>
<p>如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共<code>34591</code>种情况，后面 是一共 4 位，那么就有        <code>10^4</code>种情况。</p>
<p>那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。</p>
<p>​    <strong>我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？</strong></p>
<p>如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是</p>
<p>3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有</p>
<p>3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。</p>
<p>分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#循环的出口是 highValue = 0</span></span><br><span class="line">        <span class="hljs-comment">#我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。</span></span><br><span class="line">        <span class="hljs-comment"># 一开始 精准度为1.高位低位中位 先赋值为1.</span></span><br><span class="line">        preceise = <span class="hljs-number">1</span></span><br><span class="line">        highValue = <span class="hljs-number">1</span></span><br><span class="line">        lowValue = <span class="hljs-number">1</span></span><br><span class="line">        midValue =<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#计数 后面的位数。</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#计数 1 的次数和</span></span><br><span class="line">        sumNum = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> highValue != <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#高位 先将这个数 除以10 得到高位</span></span><br><span class="line">            highValue = n // (preceise * <span class="hljs-number">10</span>)</span><br><span class="line">            <span class="hljs-comment">#中位 先将这个数  与 10 取余。</span></span><br><span class="line">            midValue = (n // preceise)%<span class="hljs-number">10</span></span><br><span class="line">            <span class="hljs-comment">#低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.</span></span><br><span class="line">            lowValue = n % preceise</span><br><span class="line">            <span class="hljs-comment">#每遍历一次 向右移一位，那么就是说 精准度要乘以10.</span></span><br><span class="line">            preceise *= <span class="hljs-number">10</span></span><br><span class="line">			<span class="hljs-comment">#如果这个数是0 的话，</span></span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">if</span> midValue == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-comment">#那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，</span></span><br><span class="line">                num = (highValue)* pow(<span class="hljs-number">10</span>,count)</span><br><span class="line">            <span class="hljs-comment">#如果这个数 大于1 的话，</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> midValue &gt; <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-comment">#那么它 就是 最高位加1 乘以 10^后面的位数 次方，</span></span><br><span class="line">                num = (highValue+<span class="hljs-number">1</span>)*pow(<span class="hljs-number">10</span>,count)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。</span></span><br><span class="line">                num = highValue*pow(<span class="hljs-number">10</span>,count)+(lowValue+<span class="hljs-number">1</span>)</span><br><span class="line">            <span class="hljs-comment">#最后 我们1 出现的 次数 就是这 三个 num 的和，。</span></span><br><span class="line">            sumNum += num</span><br><span class="line">            <span class="hljs-comment">#没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">		<span class="hljs-comment">#最后返回这个  次数和。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> sumNum</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-丑数"><a href="#24-丑数" class="headerlink" title="24.丑数"></a>24.丑数</h2><p><strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p>
<p>思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？</p>
<p>因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(self, index)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#死循环，找丑数</span></span><br><span class="line">        <span class="hljs-comment">#判断一个数是不是丑数，先循环除以2，直到不能整除，</span></span><br><span class="line">        <span class="hljs-comment">#循环除以3 直到不能整除，循环除以5 直到不能整除</span></span><br><span class="line">        <span class="hljs-comment">#这时如果剩余的值是1  我们就说它是丑数</span></span><br><span class="line">        <span class="hljs-comment">#其他情况就都不是丑数</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isUglyNumber</span><span class="hljs-params">(num)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">3</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">5</span></span><br><span class="line">            <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        num = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> isUglyNumber(num):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> count == index:</span><br><span class="line">                <span class="hljs-keyword">return</span> num</span><br><span class="line">            num += <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure>
<p>第二种方法分析:</p>
<p>我们可以保存已经找到的丑数，然后 用空间环时间 来 找出丑数。</p>
<p>如何用空间换时间？</p>
<p>我们找一种，只需要计算丑数的办法,根据上面丑数的定义，我们可以知道，丑数应该是另一个丑数 乘以 2,3，或者5 的结果（1除外）。因此我们 可以创建一个 列表，里面的数字是排好序的 丑数，每个丑数都是前面的丑数乘以2,3，或者5得到的。</p>
<p>那么我们就可以在一个列表中，给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，第一个丑数为1，那么我们在这个列表的起始位置 设置三个指针，这三个指针代表的值  分别为2,3,5.又由于这个列表中的所有的丑数 是有序的，从小到大排列的，那么我们在每次 给一个丑数 乘以 2,3,5 以后要与前面的丑数比较大小，然后在根据大小值 来放入列表中。由于一开始第一个丑数是1，那么 1 <em> 2 得到的是2,1</em>3 得到的是3，1 乘以5 得到的是5，那么三个数中比较大小，最小的是 1 乘以2，那么 肯定第一个先放置的是2，然后是 2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，以此类推，那么现在的到的丑数的顺序就是1,2,3,4.。。。。。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(self, index)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#首先判断  要找的 丑数 是不是第0个 或者是负数，如果是的话，那么就返回0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#然后判断要找的丑数 是不是第一个，如果是第一个，那么就返回1.</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#在丑数 这个列表中 给出第一个丑数是1</span></span><br><span class="line">        numbers = [<span class="hljs-number">1</span>]</span><br><span class="line">        <span class="hljs-comment">#在列表的 一开始  设置三个 指针，也就是 三个指针的 索引位置是0，</span></span><br><span class="line">        two, three, five = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#丑数的个数 起始为 1</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#循环 当丑数的个数不等于我们要找到 那第 index 个 丑数时，就循环，等于的时候就跳出循环。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> count != index :</span><br><span class="line">            <span class="hljs-comment">#给列表中的 2,3,5 这三个指针所在位置的 丑数 分别 乘以2,3,5</span></span><br><span class="line">            n2, n3, n5 = numbers[two] * <span class="hljs-number">2</span>, numbers[three] * <span class="hljs-number">3</span>, numbers[five] * <span class="hljs-number">5</span></span><br><span class="line">            <span class="hljs-comment">#比较这三个丑数的大小</span></span><br><span class="line">            minValue = min(n2, n3, n5)</span><br><span class="line">            <span class="hljs-comment">#在丑数列表中，把三个中最小的那个 放进去。</span></span><br><span class="line">            numbers.append(minValue)</span><br><span class="line">            <span class="hljs-comment">#每放进去一个，丑数的数量就加1</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n2:</span><br><span class="line">                two += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果是 3 那个指针的话，那么3 这个指针就移一位。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n3:</span><br><span class="line">                three += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果是 5 那个指针的话，那么5这个指针就移一位。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n5:</span><br><span class="line">                five += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#最后输出这个丑数列表中的 最后一位，那么就是我们的计数的丑数的个数 -1，就是最后一个丑数的索引值。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> numbers[count<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="树的知识点："><a href="#树的知识点：" class="headerlink" title="树的知识点："></a>树的知识点：</h4><h5 id="什么叫做树？"><a href="#什么叫做树？" class="headerlink" title="什么叫做树？"></a>什么叫做树？</h5><p><strong>树状图</strong>是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">数据结构</a>，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88" target="_blank" rel="noopener">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；</p>
<p>叶节点没有子节点，根节点没有父节点。</p>
<h5 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h5><p>每个节点最多含有两个子树的树称为二叉树。下图就是一个二叉树。</p>
<p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>
<p>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点</p>
<p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/ercha.png" alt></p>
<h5 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h5><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，<a href="https://baike.baidu.com/item/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">树的遍历</a>实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p>
<p>设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">treeNode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="hljs-literal">None</span></span><br><span class="line">        self.right = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#1. 深度优先</span></span><br><span class="line"><span class="hljs-comment">#2. 广度优先</span></span><br><span class="line"><span class="hljs-comment">#对于深度优先来说：</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">1 先序遍历  先打印根 1,2,4,5,3,6,8,7</span></span><br><span class="line"><span class="hljs-string">2 中序遍历  先打印左侧的叶子节点 4，再输出 中节点  2 ；  4 2 5 1 6 8 3 7 </span></span><br><span class="line"><span class="hljs-string">3 先序遍历  输出顺序  4 5 2 8 6 7 3 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">注意：  先序   中序 后序  都是对应于根节点来说的，左右节点都是先左后右</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment">#递归</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    print(root.val)</span><br><span class="line">    preOrderRecusive(root.left)</span><br><span class="line">    preOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">midOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">    midOrderRecusive(root.left)</span><br><span class="line">    print(root.val)</span><br><span class="line">    midOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laterOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">    laterOrderRecusive(root.left)</span><br><span class="line">    laterOrderRecusive(root.right)</span><br><span class="line">    print(root.val)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#非递归的形式 去遍历数</span></span><br><span class="line"><span class="hljs-comment">#递归和循环是可以互相转换的</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">1 先根遍历 先访问根节点，再访问左子节点，最后访问右子节点</span></span><br><span class="line"><span class="hljs-string">2 中根遍历 先访问左子节点，再访问根节点，最后访问右子节点</span></span><br><span class="line"><span class="hljs-string">3 后跟遍历 先访问左子节点，再访问右子节点，最后访问根节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line">            print(tmpNode.val)</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node  = stack.pop()</span><br><span class="line">        tmpNode = node.right</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line"></span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node  = stack.pop()</span><br><span class="line">        print(node.val)</span><br><span class="line">        tmpNode = node.right</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laterOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node = stack[<span class="hljs-number">-1</span>]</span><br><span class="line">        tmpNode = node.right</span><br><span class="line">        <span class="hljs-keyword">if</span> node.right == <span class="hljs-literal">None</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            print(node.val)</span><br><span class="line">            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> node == stack[<span class="hljs-number">-1</span>].right:</span><br><span class="line">                node =  stack.pop()</span><br><span class="line">                print(node.val)</span><br></pre></td></tr></table></figure>
<h2 id="25-重建二叉树"><a href="#25-重建二叉树" class="headerlink" title="25.重建二叉树"></a>25.重建二叉树</h2><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> tin:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(pre) != len(tin):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 取出pre 的第一个值  就是根节点</span></span><br><span class="line">        root = pre[<span class="hljs-number">0</span>]</span><br><span class="line">        rootNode = TreeNode(root)</span><br><span class="line">        <span class="hljs-comment"># 找到在 tin  中序遍历中的根节点 所在的索引位置</span></span><br><span class="line">        pos = tin.index(root)</span><br><span class="line">        <span class="hljs-comment"># 中序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        tinLeft = tin[<span class="hljs-number">0</span>:pos]</span><br><span class="line">        tinRight = tin[pos + <span class="hljs-number">1</span>:]</span><br><span class="line">        <span class="hljs-comment"># 前序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        preLeft = pre[<span class="hljs-number">1</span>:pos + <span class="hljs-number">1</span>]</span><br><span class="line">        preRight = pre[pos + <span class="hljs-number">1</span>:]</span><br><span class="line"></span><br><span class="line">        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        rightNode = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line"></span><br><span class="line">        rootNode.left = leftNode</span><br><span class="line">        rootNode.right = rightNode</span><br><span class="line">        <span class="hljs-keyword">return</span> rootNode</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasEqual</span><span class="hljs-params">(pRoot1, pRoot2)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                <span class="hljs-keyword">if</span> pRoot2.left == <span class="hljs-literal">None</span>:</span><br><span class="line">                    leftEqual = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    leftEqual = hasEqual(pRoot1.left, pRoot2.left)</span><br><span class="line">                <span class="hljs-keyword">if</span> pRoot2.right == <span class="hljs-literal">None</span>:</span><br><span class="line">                    rightEqual = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    rightEqual = hasEqual(pRoot1.right, pRoot2.right)</span><br><span class="line">                <span class="hljs-keyword">return</span> leftEqual <span class="hljs-keyword">and</span> rightEqual</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">            ret = hasEqual(pRoot1, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> ret:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">if</span> ret:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">对于Python这道题，有些地方需要仔细考虑的。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">先说下算法实现思路：对于两棵二叉树来说，要判断B是不是A的子结构，首先第一步在树A中查找与B根节点的值一样的节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">通常对于查找树中某一个节点，我们都是采用递归的方法来遍历整棵树。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">第二步就是判断树A中以R为根节点的子树是不是和树B具有相同的结构。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">这里同样利用到了递归的方法，如果节点R的值和树的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">如果它们值是相同的，则递归的判断各自的左右节点的值是不是相同。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">递归的终止条件是我们达到了树A或者树B的叶节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">有地方要重点注意，DoesTree1haveTree2()函数中的两个 if 判断语句 不能颠倒顺序 。</span></span><br><span class="line"><span class="hljs-string">因为如果颠倒了顺序，会先判断pRoot1 是否为None, 其实这个时候，pRoot1 的节点已经遍历完成确认相等了，但是这个时候会返回 False，判断错误。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">有同学不相信的，可以去试试换个顺序，肯定不能AC。同时这个也是《剑指offer》书上没有写的，希望能引起大家的注意。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        result = <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1 != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pRoot2 != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                result = self.DoesTree1haveTree2(pRoot1, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:</span><br><span class="line">                result = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:</span><br><span class="line">                result = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br><span class="line">    <span class="hljs-comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">    <span class="hljs-comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">    <span class="hljs-comment"># 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DoesTree1haveTree2</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) <span class="hljs-keyword">and</span> self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><code>输入描述:</code></h5><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    <span class="hljs-number">8</span></span><br><span class="line">    	   /  \</span><br><span class="line">    	  <span class="hljs-number">6</span>   <span class="hljs-number">10</span></span><br><span class="line">    	 / \  / \</span><br><span class="line">    	<span class="hljs-number">5</span>  <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span></span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    <span class="hljs-number">8</span></span><br><span class="line">    	   /  \</span><br><span class="line">    	  <span class="hljs-number">10</span>   <span class="hljs-number">6</span></span><br><span class="line">    	 / \  / \</span><br><span class="line">    	<span class="hljs-number">11</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(self, root)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#处理根节点</span></span><br><span class="line">        root.left,root.right = root.right,root.left</span><br><span class="line">        self.Mirror(root.left)</span><br><span class="line">        self.Mirror(root.right)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="28-从上往下打印二叉树"><a href="#28-从上往下打印二叉树" class="headerlink" title="28.从上往下打印二叉树"></a>28.从上往下打印二叉树</h2><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(self, root)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line">        treeNodeTmp = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="hljs-keyword">while</span> treeNodeTmp:</span><br><span class="line">            tmpNode = treeNodeTmp[<span class="hljs-number">0</span>]</span><br><span class="line">            ret.append(tmpNode.val)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left:</span><br><span class="line">                treeNodeTmp.append(tmpNode.left)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.right:</span><br><span class="line">                treeNodeTmp.append(tmpNode.right)</span><br><span class="line">            <span class="hljs-keyword">del</span> treeNodeTmp[<span class="hljs-number">0</span>]</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="29-二叉搜索树的后序遍历序列"><a href="#29-二叉搜索树的后序遍历序列" class="headerlink" title="29.二叉搜索树的后序遍历序列"></a>29.二叉搜索树的后序遍历序列</h2><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">python:后序遍历 的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，后面用递归分别判断前后两部分 是否 符合以上原则</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> len(sequence)==<span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        length=len(sequence)</span><br><span class="line">        root=sequence[length<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># 在二叉搜索 树中 左子树节点小于根节点</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length):</span><br><span class="line">            <span class="hljs-keyword">if</span> sequence[i]&gt;root:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment"># 二叉搜索树中右子树的节点都大于根节点</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j  <span class="hljs-keyword">in</span> range(i,length):</span><br><span class="line">            <span class="hljs-keyword">if</span> sequence[j]&lt;root:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-comment"># 判断左子树是否为二叉树</span></span><br><span class="line">        left=<span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span>  i&gt;<span class="hljs-number">0</span>:</span><br><span class="line">            left=self.VerifySquenceOfBST(sequence[<span class="hljs-number">0</span>:i])</span><br><span class="line">        <span class="hljs-comment"># 判断 右子树是否为二叉树</span></span><br><span class="line">        right=<span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span> i&lt;length<span class="hljs-number">-1</span>:</span><br><span class="line">            right=self.VerifySquenceOfBST(sequence[i:<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-keyword">return</span> left <span class="hljs-keyword">and</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        rootNum = sequence[<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">del</span> sequence[<span class="hljs-number">-1</span>]</span><br><span class="line">        index = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(sequence)):</span><br><span class="line">            <span class="hljs-keyword">if</span> index == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> sequence[i] &gt; rootNum:</span><br><span class="line">                index = i</span><br><span class="line">            <span class="hljs-keyword">if</span> index != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> sequence[i] &lt; rootNum:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence[:index] == []:</span><br><span class="line">            leftRet = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            leftRet = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        <span class="hljs-keyword">if</span> sequence[index:] == []:</span><br><span class="line">            rightRet = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            rightRet = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> leftRet <span class="hljs-keyword">and</span> rightRet</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="30-二叉树中和为某一值的路径"><a href="#30-二叉树中和为某一值的路径" class="headerlink" title="30.二叉树中和为某一值的路径"></a>30.二叉树中和为某一值的路径</h2><p><strong>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">递归先序遍历树， 把结点加入路径。</span></span><br><span class="line"><span class="hljs-string">若该结点是叶子结点则比较当前路径和是否等于期待和。</span></span><br><span class="line"><span class="hljs-string">弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        support = [root]</span><br><span class="line">        supportArrayList = [[root.val]]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> support:</span><br><span class="line">            tmpNode = support[<span class="hljs-number">0</span>]</span><br><span class="line">            tmpArrayList = supportArrayList[<span class="hljs-number">0</span>]</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> tmpNode.right == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> sum(tmpArrayList) == expectNumber:</span><br><span class="line">                    ret.insert(<span class="hljs-number">0</span>, tmpArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left:</span><br><span class="line">                support.append(tmpNode.left)</span><br><span class="line">                newTmpArrayList = copy.copy(tmpArrayList)</span><br><span class="line">                newTmpArrayList.append(tmpNode.left.val)</span><br><span class="line">                supportArrayList.append(newTmpArrayList)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.right:</span><br><span class="line">                support.append(tmpNode.right)</span><br><span class="line">                newTmpArrayList = copy.copy(tmpArrayList)</span><br><span class="line">                newTmpArrayList.append(tmpNode.right.val)</span><br><span class="line">                supportArrayList.append(newTmpArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">del</span> supportArrayList[<span class="hljs-number">0</span>]</span><br><span class="line">            <span class="hljs-keyword">del</span> support[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPathMain</span><span class="hljs-params">(root, path, currentSum)</span>:</span></span><br><span class="line">            currentSum += root.val</span><br><span class="line"></span><br><span class="line">            path.append(root)</span><br><span class="line">            isLeaf = root.left == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> currentSum == expectNumber <span class="hljs-keyword">and</span> isLeaf:</span><br><span class="line">                onePath = []</span><br><span class="line">                <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> path:</span><br><span class="line">                    onePath.append(node.val)</span><br><span class="line">                result.append(onePath)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> currentSum &lt; expectNumber:</span><br><span class="line">                <span class="hljs-keyword">if</span> root.left:</span><br><span class="line">                    FindPathMain(root.left, path, currentSum)</span><br><span class="line">                <span class="hljs-keyword">if</span> root.right:</span><br><span class="line">                    FindPathMain(root.right, path, currentSum)</span><br><span class="line"></span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        FindPathMain(root, [], <span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="31-二叉搜索树与双向链表"><a href="#31-二叉搜索树与双向链表" class="headerlink" title="31.二叉搜索树与双向链表"></a>31.二叉搜索树与双向链表</h2><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Convert</span><span class="hljs-params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRootOfTree == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_right</span><span class="hljs-params">(node)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">while</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="hljs-keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        leftNode = self.Convert(pRootOfTree.left)</span><br><span class="line">        rightNode = self.Convert(pRootOfTree.right)</span><br><span class="line"></span><br><span class="line">        retNode = leftNode</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> leftNode:</span><br><span class="line">            leftNode = find_right(leftNode)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            retNode = pRootOfTree</span><br><span class="line"></span><br><span class="line">        pRootOfTree.left = leftNode</span><br><span class="line">        pRootOfTree.right = rightNode</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">None</span>:</span><br><span class="line">            leftNode.right = pRootOfTree</span><br><span class="line">        <span class="hljs-keyword">if</span> rightNode != <span class="hljs-literal">None</span>:</span><br><span class="line">            rightNode.left = pRootOfTree</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> retNode</span><br></pre></td></tr></table></figure>
            
        </div>
                
                        <ul class="post-copyright">
                        <li><strong>本文标题：</strong><a href="http://www.cygao.xyz/2019/07/25/jian offer/">python实现剑指offer1-31题</a></li>
                        <li><strong>本文作者：</strong><a href="http://www.cygao.xyz">Cunyuan</a></li>
                        <li><strong>本文链接：</strong><a href="http://www.cygao.xyz/2019/07/25/jian offer/">http://www.cygao.xyz/2019/07/25/jian offer/</a></li>
                        <li><strong>发布时间：</strong>2019-07-25</li>
                        <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
                        </li>
                        </ul>
                    
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/刷题笔记/">刷题笔记</a>, <a class="has-link-grey -link" href="/tags/数据结构/">数据结构</a>, <a class="has-link-grey -link" href="/tags/编程语言/">编程语言</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="/images/ali.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/wechat.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2019/08/10/linux/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">linux的个人向常用操作</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2019/07/12/lightweight/">
                <span class="level-item">MobileNetv1~v3,ShufflNet等轻量级网络</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        
<div id="valine-thread" class="content"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#valine-thread' ,
        notify: true,
        verify: false,
        app_id: '5bpmqQ4MrKPysDXE0gVbfMKG-gzGzoHsz',
        app_key: 'pP0cI6JOgjj5FVYXF6gh5aFh',
        placeholder: '有话要说？'
    });
</script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                目录
            </h3>
            <ul class="menu-list"><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#队列">
        <span class="has-mr-6">1.1.1</span>
        <span>队列</span>
        </a></li><li>
        <a class="is-flex" href="#栈">
        <span class="has-mr-6">1.1.2</span>
        <span>栈</span>
        </a></li></ul></ul><li>
        <a class="is-flex" href="#1-两个栈实现一个队列：-本题考点-队列-栈">
        <span class="has-mr-6">2</span>
        <span>1. 两个栈实现一个队列：[^本题考点 队列 栈]</span>
        </a><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#如图所示：">
        <span class="has-mr-6">2.1.1</span>
        <span>如图所示：</span>
        </a></li></ul><li>
        <a class="is-flex" href="#二分查找法">
        <span class="has-mr-6">2.2</span>
        <span>二分查找法</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#2-旋转数组的最小数字-本题考点-查找">
        <span class="has-mr-6">3</span>
        <span>2. 旋转数组的最小数字 [^本题考点 查找]</span>
        </a></li><li>
        <a class="is-flex" href="#3-在二维数组中的查找-本题考点-查找">
        <span class="has-mr-6">4</span>
        <span>3.在二维数组中的查找[^本题考点 查找]</span>
        </a></li><li>
        <a class="is-flex" href="#4-包含min-函数的栈-本题考点-栈">
        <span class="has-mr-6">5</span>
        <span>4.包含min 函数的栈[^本题考点 栈]</span>
        </a></li><li>
        <a class="is-flex" href="#5-替换空格-本题考点-字符串">
        <span class="has-mr-6">6</span>
        <span>5.替换空格[^本题考点 字符串]</span>
        </a></li><li>
        <a class="is-flex" href="#6-斐波那契数列">
        <span class="has-mr-6">7</span>
        <span>6.斐波那契数列</span>
        </a></li><li>
        <a class="is-flex" href="#7-青蛙跳台阶">
        <span class="has-mr-6">8</span>
        <span>7.青蛙跳台阶</span>
        </a></li><li>
        <a class="is-flex" href="#8-变态跳台阶">
        <span class="has-mr-6">9</span>
        <span>8.变态跳台阶</span>
        </a></li><li>
        <a class="is-flex" href="#9-调整数组顺序使奇数位于偶数前面-本题知识点-数组">
        <span class="has-mr-6">10</span>
        <span>9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#知识点：冒泡排序法">
        <span class="has-mr-6">10.1</span>
        <span>知识点：冒泡排序法</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#10-栈的压入，弹出序列-本题考点-栈">
        <span class="has-mr-6">11</span>
        <span>10.栈的压入，弹出序列  [^本题考点 栈]</span>
        </a><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#知识点链表：">
        <span class="has-mr-6">11.1.1</span>
        <span>知识点链表：</span>
        </a></li></ul></ul></li><li>
        <a class="is-flex" href="#11-从栈尾到栈头打印链表-本题知识点-链表">
        <span class="has-mr-6">12</span>
        <span>11. 从栈尾到栈头打印链表 [^本题知识点 链表]</span>
        </a></li><li>
        <a class="is-flex" href="#12-链表中的倒数第k个结点-本题考点-链表">
        <span class="has-mr-6">13</span>
        <span>12.链表中的倒数第k个结点[^本题考点 链表]</span>
        </a></li><li>
        <a class="is-flex" href="#13-反转链表-本题考点-链表">
        <span class="has-mr-6">14</span>
        <span>13.反转链表[^本题考点 链表]</span>
        </a></li><li>
        <a class="is-flex" href="#14-复杂链表的复制">
        <span class="has-mr-6">15</span>
        <span>14.复杂链表的复制</span>
        </a></li><li>
        <a class="is-flex" href="#15-两个链表之间的第一个公共结点">
        <span class="has-mr-6">16</span>
        <span>15.两个链表之间的第一个公共结点</span>
        </a></li><li>
        <a class="is-flex" href="#16-合并两个排序的链表-本题考点-链表">
        <span class="has-mr-6">17</span>
        <span>16.合并两个排序的链表 [^本题考点  链表]</span>
        </a></li><li>
        <a class="is-flex" href="#17-圆圈中最后剩下的数-本题考点-模拟">
        <span class="has-mr-6">18</span>
        <span>17.圆圈中最后剩下的数 [^本题考点 模拟]</span>
        </a></li><li>
        <a class="is-flex" href="#18-链表中环的入口点-本题知识点-链表">
        <span class="has-mr-6">19</span>
        <span>18.链表中环的入口点 [^本题知识点  链表]</span>
        </a></li><li>
        <a class="is-flex" href="#19-二进制中的1的个数">
        <span class="has-mr-6">20</span>
        <span>19.二进制中的1的个数</span>
        </a><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#知识点">
        <span class="has-mr-6">20.1.1</span>
        <span>知识点:</span>
        </a></li><li>
        <a class="is-flex" href="#补码">
        <span class="has-mr-6">20.1.2</span>
        <span>补码</span>
        </a></li><li>
        <a class="is-flex" href="#按位取反">
        <span class="has-mr-6">20.1.3</span>
        <span>按位取反 ~</span>
        </a></li></ul></ul></li><li>
        <a class="is-flex" href="#20-不用加减乘除做加法-本题考点-按位运算">
        <span class="has-mr-6">21</span>
        <span>20.不用加减乘除做加法[^本题考点 按位运算]</span>
        </a></li><li>
        <a class="is-flex" href="#21-数组中出现次数超过一半的数字-本题考点-数组">
        <span class="has-mr-6">22</span>
        <span>21.数组中出现次数超过一半的数字[^本题考点 数组]</span>
        </a></li><li>
        <a class="is-flex" href="#22-数组中只出现一次的数字-数组">
        <span class="has-mr-6">23</span>
        <span>22.数组中只出现一次的数字[^数组]</span>
        </a></li><li>
        <a class="is-flex" href="#23-整数中1出现的次数-本题考点-数组">
        <span class="has-mr-6">24</span>
        <span>23.整数中1出现的次数[^本题考点 数组]</span>
        </a></li><li>
        <a class="is-flex" href="#24-丑数">
        <span class="has-mr-6">25</span>
        <span>24.丑数</span>
        </a><ul class="menu-list"><ul class="menu-list"><li>
        <a class="is-flex" href="#树的知识点：">
        <span class="has-mr-6">25.1.1</span>
        <span>树的知识点：</span>
        </a></li></ul></ul></li><li>
        <a class="is-flex" href="#25-重建二叉树">
        <span class="has-mr-6">26</span>
        <span>25.重建二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#26-树的子结构">
        <span class="has-mr-6">27</span>
        <span>26.树的子结构</span>
        </a></li><li>
        <a class="is-flex" href="#27-二叉树的镜像">
        <span class="has-mr-6">28</span>
        <span>27.二叉树的镜像</span>
        </a></li><li>
        <a class="is-flex" href="#28-从上往下打印二叉树">
        <span class="has-mr-6">29</span>
        <span>28.从上往下打印二叉树</span>
        </a></li><li>
        <a class="is-flex" href="#29-二叉搜索树的后序遍历序列">
        <span class="has-mr-6">30</span>
        <span>29.二叉搜索树的后序遍历序列</span>
        </a></li><li>
        <a class="is-flex" href="#30-二叉树中和为某一值的路径">
        <span class="has-mr-6">31</span>
        <span>30.二叉树中和为某一值的路径</span>
        </a></li><li>
        <a class="is-flex" href="#31-二叉搜索树与双向链表">
        <span class="has-mr-6">32</span>
        <span>31.二叉搜索树与双向链表</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
    
        <div class="column-right-shadow  ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="python实现剑指offer1-31题" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Cunyuan&nbsp;
                
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>

            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/gggcy">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
        
    </div>

    
</footer>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'true'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>