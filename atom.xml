<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy的学习日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cygao.xyz/"/>
  <updated>2019-09-25T14:07:31.352Z</updated>
  <id>http://www.cygao.xyz/</id>
  
  <author>
    <name>Cunyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录面经</title>
    <link href="http://www.cygao.xyz/2019/09/25/mianjing/"/>
    <id>http://www.cygao.xyz/2019/09/25/mianjing/</id>
    <published>2019-09-25T13:01:49.000Z</published>
    <updated>2019-09-25T14:07:31.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="腾讯优图"><a href="#腾讯优图" class="headerlink" title="腾讯优图"></a>腾讯优图</h1><p>26分钟</p><ol><li>自我介绍，可以实习多久，手上有没有offer</li><li>主要是深挖项目1，包括介绍Non-local，这个点没准备好</li><li>平时使用什么语言居多，编程题（判断链表有环，链表相交，青蛙跳，数组里面相加=target的数对数）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;腾讯优图&quot;&gt;&lt;a href=&quot;#腾讯优图&quot; class=&quot;headerlink&quot; title=&quot;腾讯优图&quot;&gt;&lt;/a&gt;腾讯优图&lt;/h1&gt;&lt;p&gt;26分钟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍，可以实习多久，手上有没有offer&lt;/li&gt;
&lt;li&gt;主要是深挖项目1，包括介
      
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="总结经验" scheme="http://www.cygao.xyz/tags/%E6%80%BB%E7%BB%93%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Bagging和Boosting概念及区别、决策树相关</title>
    <link href="http://www.cygao.xyz/2019/09/24/bagging/"/>
    <id>http://www.cygao.xyz/2019/09/24/bagging/</id>
    <published>2019-09-24T11:44:28.000Z</published>
    <updated>2019-09-24T13:28:31.546Z</updated>
    
    <content type="html"><![CDATA[<p>主要是原理和区别，面试向。<br><a id="more"></a><br>Baggging 和Boosting都是模型融合的方法，可以将弱分类器融合之后形成一个强分类器，而且融合之后的效果会比最好的弱分类器更好。</p><h1 id="Bagging-bootstrap-aggregating"><a href="#Bagging-bootstrap-aggregating" class="headerlink" title="Bagging (bootstrap aggregating)"></a>Bagging (bootstrap aggregating)</h1><p>Bagging即套袋法，其算法过程如下：</p><ol><li>从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</li><li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</li><li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</li></ol><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><ul><li>对于训练集中的每个样本建立权值wi，表示对每个样本的权重， 其关键在与对于被错误分类的样本权重会在下一轮的分类中获得更大的权重（错误分类的样本的权重增加）。</li><li>同时加大分类误差概率小的弱分类器的权值，使其在表决中起到更大的作用，减小分类误差率较大弱分类器的权值，使其在表决中起到较小的作用。每一次迭代都得到一个弱分类器，需要使用某种策略将其组合，最为最终模型，(adaboost给每个迭代之后的弱分类器一个权值，将其线性组合作为最终的分类器,误差小的分类器权值越大。)</li></ul><h1 id="Bagging-和-Boosting-的区别"><a href="#Bagging-和-Boosting-的区别" class="headerlink" title="Bagging 和 Boosting 的区别"></a>Bagging 和 Boosting 的区别</h1><ol><li>样本选择上：</li></ol><p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的.</p><p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化.而权值是根据上一轮的分类结果进行调整.</p><ol start="2"><li>样例权重：</li></ol><p>Bagging：使用均匀取样，每个样例的权重相等</p><p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大.</p><ol start="3"><li>预测函数：</li></ol><p>Bagging：所有预测函数的权重相等.</p><p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重.</p><ol start="4"><li>并行计算：</li></ol><p>Bagging：各个预测函数可以并行生成</p><p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果.</p><h1 id="下面是将决策树与这些算法框架进行结合所得到的新的算法："><a href="#下面是将决策树与这些算法框架进行结合所得到的新的算法：" class="headerlink" title="下面是将决策树与这些算法框架进行结合所得到的新的算法："></a>下面是将决策树与这些算法框架进行结合所得到的新的算法：</h1><ol><li>Bagging + 决策树 = 随机森林</li><li>AdaBoost + 决策树 = 提升树</li><li>Gradient Boosting + 决策树 = GBDT</li></ol><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>策树是一种自上而下，对样本数据进行树形分类的过程，由节点和有向边组成。节点分为内部节点和叶子节点，其中每个内部节点表示一个特征或属性，叶子节点表示类别。决策树常用于分类问题于回归问题，完全生长的决策树模型具有简单直观、解释性强的特点。</p><p>常用的决策树算法有ID3，C4.5，CART三种。3种算法的模型构建思想都十分类似，只是采用了不同的指标。</p><ul><li>ID3-最大信息增益</li><li>C4.5-最大信息增益比</li><li>CART-最大基尼指数（Gini）</li></ul><h2 id="ID3，C4-5，CART差异"><a href="#ID3，C4-5，CART差异" class="headerlink" title="ID3，C4.5，CART差异"></a>ID3，C4.5，CART差异</h2><ol><li>从样本类型的角度：</li></ol><p>ID3只能处理离散型变量，而C4.5和CART都可以处理连续型变量。C4.5处理连续型变量时，通过对数据排序之后找到类别不同的分割线作为切分点，根据切分点把把连续属性转换为布尔型，从而将连续型变量转换成多个取值区间的离散型变量。而对于CART，由于其构建时每次都会对特征进行二值划分，因此可以可以很好的适用于连续型变量。</p><ol start="2"><li>从应用角度：</li></ol><p>ID3和C4.5只能用于分类任务，而CART(Classification and Regression Tree,分类回归树)既可以用于分类，也可以用于回归任务（回归树使用最小平方误差准则）。</p><ol start="3"><li>从细节、优化过程角度：</li></ol><p>ID3对样本特征缺失值比较敏感，而C4.5和CART可以对缺失值进行不同方式的处理；</p><p>ID3和C4.5可以在每个节点上产生多叉分支，且每个特征在层级之间不会复用，而CART每个节点只会产生两个分支，因此最后会形成一颗二叉树，且每个特征可以被重复使用；ID3和C4.5通过剪枝来权衡树的准确性于泛化能力，而CART直接利用全部数据发现所有可能的树结构进行对比。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是原理和区别，面试向。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>计算机视觉杂七杂八</title>
    <link href="http://www.cygao.xyz/2019/09/24/vision/"/>
    <id>http://www.cygao.xyz/2019/09/24/vision/</id>
    <published>2019-09-24T10:49:45.000Z</published>
    <updated>2019-09-25T08:34:08.934Z</updated>
    
    <content type="html"><![CDATA[<p>啥都有。持续更新中。。。<br><a id="more"></a></p><h1 id="如何防止过拟合？"><a href="#如何防止过拟合？" class="headerlink" title="如何防止过拟合？"></a>如何防止过拟合？</h1><ul><li>数据增广（Data Augmentation）</li><li>正则化（L0正则、L1正则和L2正则），也叫限制权值Weight-decay</li><li>Dropout</li><li>Early Stopping</li><li>简化模型</li><li>增加噪声</li><li>Bagging</li><li>贝叶斯方法</li><li>决策树剪枝</li><li>集成方法，随机森林</li><li>Batch Normalization</li></ul><h1 id="如何防止欠拟合？"><a href="#如何防止欠拟合？" class="headerlink" title="如何防止欠拟合？"></a>如何防止欠拟合？</h1><ul><li>添加新特征</li><li>添加多项式特征</li><li>减少正则化参数</li><li>增加网络复杂度</li><li>使用集成学习方法，如Bagging</li></ul><h1 id="聚类算法中的距离度量有哪些？"><a href="#聚类算法中的距离度量有哪些？" class="headerlink" title="聚类算法中的距离度量有哪些？"></a>聚类算法中的距离度量有哪些？</h1><p>欧氏距离、曼哈顿距离、夹角余弦、切比雪夫距离、汉明距离</p><h1 id="神经网络中的Epoch、Iteration、Batchsize"><a href="#神经网络中的Epoch、Iteration、Batchsize" class="headerlink" title="神经网络中的Epoch、Iteration、Batchsize"></a>神经网络中的Epoch、Iteration、Batchsize</h1><ul><li>batchsize：中文翻译为批大小（批尺寸）。在深度学习中，一般采用SGD训练，即每次训练在训练集中取batchsize个样本训练；</li><li>iteration：中文翻译为迭代，1个iteration等于使用batchsize个样本训练一次；一个迭代 = 一个正向通过+一个反向通过</li><li>epoch：迭代次数，1个epoch等于使用训练集中的全部样本训练一次；一个epoch = 所有训练样本的一个正向传递和一个反向传递</li></ul><p>举个例子，训练集有1000个样本，batchsize=10，那么：训练完整个样本集需要：100次iteration，1次epoch。</p><h1 id="CNN-模型所需的计算力（flops）和参数（parameters）数量是怎么计算的？"><a href="#CNN-模型所需的计算力（flops）和参数（parameters）数量是怎么计算的？" class="headerlink" title="CNN 模型所需的计算力（flops）和参数（parameters）数量是怎么计算的？"></a>CNN 模型所需的计算力（flops）和参数（parameters）数量是怎么计算的？</h1><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/flops.png" alt></div> <p>h,w是kernel的尺寸，+1是bias。</p><h1 id="边框回归-Bounding-Box-Regression"><a href="#边框回归-Bounding-Box-Regression" class="headerlink" title="边框回归 Bounding-Box Regression"></a>边框回归 Bounding-Box Regression</h1><p>经过 Ground Truth 和 Proposal 计算得到的真正需要的平移量(tx,ty)和尺度缩放(tw,th)。四个参数。</p><h1 id="反卷积-Deconvolution-、上采样-UNSampling-与上池化-UnPooling"><a href="#反卷积-Deconvolution-、上采样-UNSampling-与上池化-UnPooling" class="headerlink" title="反卷积(Deconvolution)、上采样(UNSampling)与上池化(UnPooling)"></a>反卷积(Deconvolution)、上采样(UNSampling)与上池化(UnPooling)</h1><p>转置卷积只能还原shape大小，而不能还原value,至少在数值方面上，转置卷积不能实现卷积操作的逆过程。所以说转置卷积与真正的反卷积有点相似，因为两者产生了相同的空间分辨率。但是又名反卷积（deconvolutions）的这种叫法是不合适的，因为它不符合反卷积的概念。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/network.png" alt></div> <ul><li>图（a）表示UnPooling的过程，特点是在Maxpooling的时候保留最大值的位置信息，之后在unPooling阶段使用该信息扩充Feature Map，除最大值位置以外，其余补0。</li><li>图（b），两者的区别在于UnSampling阶段没有使用MaxPooling时的位置信息，而是直接将内容复制来扩充Feature Map。从图中即可看到两者结果的不同。</li><li>图（c）为反卷积的过程，反卷积是卷积的逆过程，又称作转置卷积。最大的区别在于反卷积过程是有参数要进行学习的（类似卷积过程），理论是反卷积可以实现UnPooling和unSampling，只要卷积核的参数设置的合理。</li></ul><p>详细见<a href="https://buptldy.github.io/2016/10/29/2016-10-29-deconv/" target="_blank" rel="noopener">Transposed Convolution, Fractionally Strided Convolution or Deconvolution</a></p><h1 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h1><p><a href="https://www.zhihu.com/question/54149221" target="_blank" rel="noopener">如何理解空洞卷积（dilated convolution）？</a></p><h2 id="重新思考卷积：-Rethinking-Convolution"><a href="#重新思考卷积：-Rethinking-Convolution" class="headerlink" title="重新思考卷积： Rethinking Convolution"></a>重新思考卷积： Rethinking Convolution</h2><p>VGG很大的一个贡献，7 x 7 的卷积层的正则等效于 3 个 3 x 3 的卷积层的叠加。而这样的设计不仅可以大幅度的减少参数，其本身带有正则性质的 convolution map 能够更容易学一个 generlisable, expressive feature space。这也是现在绝大部分基于卷积的深层网络都在用小卷积核的原因。</p><p>然而 Deep CNN 对于其他任务还有一些致命性的缺陷。较为著名的是 up-sampling 和 pooling layer 的设计。</p><p>主要问题有：</p><ul><li>Up-sampling / pooling layer (e.g. bilinear interpolation) is deterministic. (a.k.a. not learnable)</li><li>内部数据结构丢失；空间层级化信息丢失。</li><li>小物体信息无法重建 (假设有四个pooling layer 则 任何小于 2^4 = 16 pixel 的物体信息将理论上无法重建。)</li></ul><p>在这样问题的存在下，语义分割问题一直处在瓶颈期无法再明显提高精度， 而 dilated convolution 的设计就良好的避免了这些问题。</p><p>需求：</p><ul><li>能不能设计一种新的操作，不通过pooling也能有较大的感受野看到更多的信息呢？</li></ul><p>目的：</p><ul><li>替代pooling和up-sampling运算，既增大感受野又不减小图像大小。</li></ul><p>简述：</p><ul><li>在标准的 convolution map 里注入空洞，以此来增加 reception field。相比原来的正常convolution，dilated convolution 多了一个 hyper-parameter 称之为 dilation rate 指的是kernel的间隔数量(e.g. 正常的 convolution 是 dilatation rate 1)。</li></ul><p>由此Dilated Convolution是在不改变kernel size的条件下，增大感受野。</p><h1 id="Focal-loss-和-GHM"><a href="#Focal-loss-和-GHM" class="headerlink" title="Focal loss 和 GHM"></a>Focal loss 和 GHM</h1><p>看这个文章就够了，<a href="https://zhuanlan.zhihu.com/p/80594704" target="_blank" rel="noopener">5分钟理解Focal Loss与GHM——解决样本不平衡利器</a></p><h1 id="ROIAlign-ROIPooling及ROIWarp对比"><a href="#ROIAlign-ROIPooling及ROIWarp对比" class="headerlink" title="ROIAlign, ROIPooling及ROIWarp对比"></a>ROIAlign, ROIPooling及ROIWarp对比</h1><h2 id="ROIPooling"><a href="#ROIPooling" class="headerlink" title="ROIPooling"></a>ROIPooling</h2><p>anchor经过优胜劣汰升级为RoI,之后输入 RoIPooling进行size归一化,归一化成卷积网络输入的尺寸。</p><p>缺陷：</p><ul><li>由于 RoIPooling 采用的是 INTER_NEAREST（即最近邻插值） ，即在resize时，对于 缩放后坐标不能刚好为整数 的情况，采用了 粗暴的四舍五入，相当于选取离目标点最近的点。</li></ul><h2 id="ROIAlign"><a href="#ROIAlign" class="headerlink" title="ROIAlign"></a>ROIAlign</h2><p>为了解决上述的缺陷，ROIAlign从原图到特征图直接的ROI映射直接使用双线性插值，不取整，这样误差会小很多，经过池化后再对应回原图的准确性也更高些。 </p><h2 id="ROIWarp"><a href="#ROIWarp" class="headerlink" title="ROIWarp"></a>ROIWarp</h2><p>在pooling层前面，添加一层，将特征图crop一块，然后warp到固定的尺寸，这里的warp采用长度和宽度两个方向的双线性插值。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啥都有。持续更新中。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/24/python/"/>
    <id>http://www.cygao.xyz/2019/09/24/python/</id>
    <published>2019-09-24T09:02:55.000Z</published>
    <updated>2019-09-25T08:34:07.816Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新中。。。。<br><a id="more"></a></p><h2 id="函数传参会改变参数本身吗"><a href="#函数传参会改变参数本身吗" class="headerlink" title="函数传参会改变参数本身吗"></a>函数传参会改变参数本身吗</h2><p>具体详见<a href="https://blog.csdn.net/liuxiao214/article/details/81673093" target="_blank" rel="noopener">python：函数传参是否会改变函数外参数的值</a></p><p>简单总结：</p><ul><li>当我们传的参数是int、字符串(string)、float、（数值型number）、元组（tuple) 时，无论函数中对其做什么操作，都不会改变函数外这个参数的值；</li><li>传的是字典型(dictionary)、列表型(list)时，如果是重新对其进行赋值，则不会改变函数外参数的值，如果是对其进行操作，则会改变。</li></ul><h2 id="python的字典为什么不选用红黑树而用哈希表做数据结构？"><a href="#python的字典为什么不选用红黑树而用哈希表做数据结构？" class="headerlink" title="python的字典为什么不选用红黑树而用哈希表做数据结构？"></a>python的字典为什么不选用红黑树而用哈希表做数据结构？</h2><p>红黑树在插入后恢复，删除后恢复有优势，就是但是查找较慢，字典类型更多的是查找，</p><h2 id="Python中的可变对象和不可变对象"><a href="#Python中的可变对象和不可变对象" class="headerlink" title="Python中的可变对象和不可变对象"></a>Python中的可变对象和不可变对象</h2><ul><li>不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。</li><li>可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。</li></ul><p>Python中，数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新中。。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>感受野相关</title>
    <link href="http://www.cygao.xyz/2019/09/24/receptive/"/>
    <id>http://www.cygao.xyz/2019/09/24/receptive/</id>
    <published>2019-09-24T06:56:42.000Z</published>
    <updated>2019-09-24T07:07:46.700Z</updated>
    
    <content type="html"><![CDATA[<p>感受野的计算，如何增加感受野。<br><a id="more"></a></p><h2 id="输出维度的计算"><a href="#输出维度的计算" class="headerlink" title="输出维度的计算"></a>输出维度的计算</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/receptive.png" alt></div> <h2 id="感受野的计算"><a href="#感受野的计算" class="headerlink" title="感受野的计算"></a>感受野的计算</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">RF: 待计算的feature map上的感受野大小</span></span><br><span class="line"><span class="hljs-string">stride: 卷积的步长(之前所有层stride的乘积)</span></span><br><span class="line"><span class="hljs-string">fsize: 卷积层滤波器的大小</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line">RF = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> （high layer To low layer）:</span><br><span class="line">　　RF = ((RF <span class="hljs-number">-1</span>)* stride) + fsize</span><br></pre></td></tr></table></figure><h2 id="如何增加感受野"><a href="#如何增加感受野" class="headerlink" title="如何增加感受野"></a>如何增加感受野</h2><ul><li>增加pooling层，但是会降低准确性（pooling过程中造成了信息损失）</li><li>增大卷积核的kernel size，但是会增加参数</li><li>增加卷积层的个数，但是会面临梯度消失的问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感受野的计算，如何增加感受野。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>optimizer</title>
    <link href="http://www.cygao.xyz/2019/09/24/optimizer/"/>
    <id>http://www.cygao.xyz/2019/09/24/optimizer/</id>
    <published>2019-09-24T03:03:58.000Z</published>
    <updated>2019-09-25T01:21:49.489Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://blog.csdn.net/qsczse943062710/article/details/76763739" target="_blank" rel="noopener">最全的机器学习中的优化算法介绍</a>，<a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等）</a></p><a id="more"></a><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li>随机梯度下降（SGD）</li><li>Mini-Batch</li><li>动量（Momentum）</li><li>Nesterov 动量</li><li>AdaGrad</li><li>AdaDelta</li><li>RMSProp</li><li>Adam</li><li>Adamax</li><li>Nadam</li><li>AMSGrad</li><li>AdaBound</li></ul><h2 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h2><p>一阶泰勒展开</p><p>梯度下降法根据每次求解损失函数L带入的样本数，可以分为：<strong>全量梯度下降</strong>（计算所有样本的损失），<strong>批量梯度下降</strong>（每次计算一个batch样本的损失）和<strong>随机梯度下降</strong>（每次随机选取一个样本计算损失）。<br>现在所说的SGD（随机梯度下降）多指Mini-batch-Gradient-Descent（批量梯度下降）。</p><h3 id="SGD的优缺点"><a href="#SGD的优缺点" class="headerlink" title="SGD的优缺点"></a>SGD的优缺点</h3><ol><li>优点：操作简单，计算量小，在损失函数是凸函数的情况下能够保证收敛到一个较好的全局最优解。 </li><li>缺点：α是个定值（在最原始的版本），它的选取直接决定了解的好坏，过小会导致收敛太慢，过大会导致震荡而无法收敛到最优解。</li><li>缺点: 对于非凸问题，只能收敛到局部最优，并且没有任何摆脱局部最优的能力（一旦梯度为0就不会再有任何变化）。</li></ol><h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>Momentum在每次更新时，保留一部分上次的更新方向： </p><ol><li>优点：一定程度上缓解了SGD收敛不稳定的问题，并且有一定的摆脱局部最优的能力（当前梯度为0时，仍可能按照上次迭代的方向冲出局部最优点）。</li><li>缺点：这里又多了另外一个超参数ρ需要我们设置，它的选取同样会影响到结果。</li></ol><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</p><ol><li>优点：二阶收敛，收敛速度快；</li><li>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</li></ol><h3 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h3><p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。</p><h2 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h2><p>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。</p><hr><p>  不同于上述算法对前进方向进行选择和调整，后面这些算法主要研究沿着梯度方向走多远的问题，也即如何选择合适的学习率α。</p><h2 id="Adagrad-adaptive-gradient"><a href="#Adagrad-adaptive-gradient" class="headerlink" title="Adagrad(adaptive gradient)"></a>Adagrad(adaptive gradient)</h2><p>自适应梯度法。它通过记录每次迭代过程中的前进方向和距离，从而使得针对不同问题，有一套自适应调整学习率的方法： </p><ol><li>优点：解决了SGD中学习率不能自适应调整的问题 </li><li>缺点：学习率单调递减，在迭代后期可能导致学习率变得特别小而导致收敛及其缓慢。<br>同样的，我们还需要手动设置初始α。</li></ol><h2 id="Adagrad-like"><a href="#Adagrad-like" class="headerlink" title="Adagrad-like"></a>Adagrad-like</h2><ol><li>优点：缓解了Adagrad中学习率单调递减的问题 </li><li>缺点：Hession矩阵的计算必须采用较好的近似解，其次t也成为了新的超参数需要手动设置，即我们需要保留参数前多少个梯度值用来缩放学习率。</li></ol><h2 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h2><ol><li>优点：完全自适应全局学习率，加速效果好 </li><li>缺点：后期容易在小范围内产生震荡</li></ol><h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>Adam是Momentum和Adaprop的结合体, 它利用误差函数的一阶矩估计和二阶矩估计来约束全局学习率。 </p><ol><li>优点：结合Momentum和Adaprop，稳定性好，同时相比于Adagrad，不用存储全局所有的梯度，适合处理大规模数据 </li></ol><h2 id="为什么大部分都是SGD"><a href="#为什么大部分都是SGD" class="headerlink" title="为什么大部分都是SGD"></a>为什么大部分都是SGD</h2><p>需要注意的是，其他的方法在计算性能和收敛方面确实优秀很多，有的甚至不用认为干涉，它会自适应的调整参数，但是，在良好的调参情况下，SGD收敛到的最优解一般是最好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/qsczse943062710/article/details/76763739&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最全的机器学习中的优化算法介绍&lt;/a&gt;，&lt;a href=&quot;https://www.cnblogs.com/shixiangwan/p/7532830.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="优化方法" scheme="http://www.cygao.xyz/tags/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++常见题</title>
    <link href="http://www.cygao.xyz/2019/09/24/cpp/"/>
    <id>http://www.cygao.xyz/2019/09/24/cpp/</id>
    <published>2019-09-24T01:55:13.000Z</published>
    <updated>2019-09-24T08:47:04.346Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新中。。。<br><a id="more"></a></p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html" target="_blank" rel="noopener">C++中static关键字作用总结</a></p><h2 id="C-中四种cast转换-或者说是显式转换"><a href="#C-中四种cast转换-或者说是显式转换" class="headerlink" title="C++中四种cast转换(或者说是显式转换)"></a>C++中四种cast转换(或者说是显式转换)</h2><p><a href="https://blog.csdn.net/u012630961/article/details/79501743" target="_blank" rel="noopener">C++ 四种类型转换</a></p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>能进行基础类型之间的转换，也是最常看到的类型转换。它主要有如下几种用法：</p><ol><li>用于类层次结构中父类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成父类表示）是安全的；</li><li>进行下行转换（把父类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的；</li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li>把void指针转换成目标类型的指针（不安全！！）</li><li>把任何类型的表达式转换成void类型。</li></ol><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast运算符用来修改类型的const或volatile属性。除了去掉const 或volatile修饰之外， type_id和expression得到的类型是一样的。但需要特别注意的是const_cast<strong>不是用于去除变量的常量性</strong>，而是去除<strong>指向常数对象的指针或引用的常量性</strong>，其去除常量性的对象必须<strong>为指针或引用</strong>。</p><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>类型转换函数,在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> *ip;</span><br><span class="line"><span class="hljs-keyword">char</span> *pc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure></p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。</p><p>从父类到子类，这也是dynamic_cast最常用的情况，这依赖于父类指针是否真实的指向了对应的子类类型，标示这是不是一个真实的子类对象，会检查转换的类型，相比static_cast更安全。</p><h2 id="C-中指针和引用的区别"><a href="#C-中指针和引用的区别" class="headerlink" title="C++ 中指针和引用的区别"></a>C++ 中指针和引用的区别</h2><ol><li>指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。</li><li>引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）</li><li>有多级指针，但是没有多级引用，只能有一级引用。</li><li>指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）</li><li>sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。</li><li>引用访问一个变量是直接访问，而指针访问一个变量是间接访问。</li><li>使用指针前最好做类型检查，防止野指针的出现；</li><li>引用底层是通过指针实现的；</li><li>作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。</li></ol><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ul><li>栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。</li><li>堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。</li><li>全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 – 程序结束后由系统释放。</li><li>文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放</li><li>程序代码区：存放函数体的二进制代码。<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-comment">//全局初始化区 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">char</span> *p1;<span class="hljs-comment">//   全局未初始化区    </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>    </span></span><br><span class="line"><span class="hljs-function"></span>&#123;    </span><br><span class="line">  <span class="hljs-keyword">int</span>   b;<span class="hljs-comment">//   栈    </span></span><br><span class="line">  <span class="hljs-keyword">char</span>   s[]   =   <span class="hljs-string">"abc"</span>;<span class="hljs-comment">//   栈    </span></span><br><span class="line">  <span class="hljs-keyword">char</span>   *p2;<span class="hljs-comment">//   栈    </span></span><br><span class="line">  <span class="hljs-keyword">char</span>   *p3   =   <span class="hljs-string">"123456"</span>;<span class="hljs-comment">//   123456/0在常量区，p3在栈上。    </span></span><br><span class="line">  <span class="hljs-keyword">static</span>   <span class="hljs-keyword">int</span>   c   =<span class="hljs-number">0</span>;<span class="hljs-comment">//   全局（静态）初始化区    </span></span><br><span class="line">  p1   =   (<span class="hljs-keyword">char</span>   *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);    </span><br><span class="line">  p2   =   (<span class="hljs-keyword">char</span>   *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);    </span><br><span class="line">  <span class="hljs-comment">//分配得来得10和20字节的区域就在堆区。    </span></span><br><span class="line">  <span class="hljs-built_in">strcpy</span>(p1,   <span class="hljs-string">"123456"</span>);<span class="hljs-comment">//   123456/0放在常量区，编译器可能会将它与p3所指向的"123456" 优化成一个地方。       </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆和栈的理论知识"><a href="#堆和栈的理论知识" class="headerlink" title="堆和栈的理论知识"></a>堆和栈的理论知识</h4><ul><li>stack: 由系统自动分配。例如，声明在函数中一个局部变量int b; 系统自动在栈中为b开辟空间</li><li>heap: 需要程序员自己申请，并指明大小，在c中malloc函数,如p1=(char *)malloc(10);在C++中用new运算符,如p2 = new char[10]; 但是注意p1、p2本身是在栈中的。</li></ul><h4 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h4><ul><li>栈:只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的 首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。</li></ul><h4 id="全局变量和static变量的区别"><a href="#全局变量和static变量的区别" class="headerlink" title="全局变量和static变量的区别"></a>全局变量和static变量的区别</h4><ol><li>全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</li></ol><p>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</p><ol start="2"><li>static函数与普通函数有什么区别？</li></ol><p>　　static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。</p><p>static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p><h4 id="静态成员与普通成员的区别"><a href="#静态成员与普通成员的区别" class="headerlink" title="静态成员与普通成员的区别"></a>静态成员与普通成员的区别</h4><ol><li>生命周期</li></ol><p>静态成员变量从类被加载开始到类被卸载，一直存在；<br>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</p><ol start="2"><li>共享方式</li></ol><p>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</p><ol start="3"><li>定义位置</li></ol><p>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</p><ol start="4"><li>初始化位置</li></ol><p>普通成员变量在类中初始化；静态成员变量在类外初始化；</p><ol start="5"><li>默认实参</li></ol><p>可以使用静态成员变量作为默认实参，</p><h2 id="什么是虚函数，作用是什么"><a href="#什么是虚函数，作用是什么" class="headerlink" title="什么是虚函数，作用是什么"></a>什么是虚函数，作用是什么</h2><p>虚函数的作用核心是在运行期实现多态。</p><p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p><h2 id="内存泄漏和内存溢出的区别"><a href="#内存泄漏和内存溢出的区别" class="headerlink" title="内存泄漏和内存溢出的区别"></a>内存泄漏和内存溢出的区别</h2><ul><li>内存泄漏-memory Leak是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存<br>的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。<br>很典型的，内存泄漏会导致可用的内存越来越少，最终我们发现没有内存可以使用了。在C++中可以理解为我们使用new分配的内存用完必须释放，在可分配内存远大于泄漏内存时影响不是很大，但是如果反过来的话影响就大大的了。</li><li>内存溢出就是内存越界，可以理解为我们使用了我们本不应该使用的内存，或者我们使用的内存的量远远大于我们本可以使用的内存量。有一种很常见的情况是我们调用的数组下标越界了，这个数组使用了本不应该使用的内存地址。另外还有调用栈溢出（stackoverflow），这种情况可以看成是栈内存不足的一种体现，当然内存溢出同时也包含缓冲区溢出(缓冲区也可以理解为我们开辟的数组，但是这个数组使用了它本不应该使用的区域，而这个区域我们可能放着其他一些重要的信息)。</li></ul><h2 id="手写String类"><a href="#手写String类" class="headerlink" title="手写String类"></a>手写String类</h2><p>主要是完成String类的构造函数、拷贝构造函数、赋值构造函数和析构函数。这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载构造函数、赋值函数、析构函数；</p><p>下面是具体的实现：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">String(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str=<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//普通的构造函数</span></span><br><span class="line">String(<span class="hljs-keyword">const</span> String&amp; other); <span class="hljs-comment">//拷贝构造函数</span></span><br><span class="line">~String();</span><br><span class="line">String&amp; operate = (<span class="hljs-keyword">const</span> String&amp; other);<span class="hljs-comment">//复制构造</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line"><span class="hljs-keyword">char</span>* m_data;<span class="hljs-comment">//用于保存字符串</span></span><br><span class="line">&#125;;</span><br><span class="line">String::String(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (str==<span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];</span><br><span class="line">*m_data = <span class="hljs-string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(str);</span><br><span class="line">m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len+<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-built_in">strcpy</span>(m_data, str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (m_data!=<span class="hljs-literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">delete</span>[] m_data;</span><br><span class="line">m_data = <span class="hljs-literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String::String(<span class="hljs-keyword">const</span> String &amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(other.m_data);</span><br><span class="line">m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len + <span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line">String&amp; String::operate = (<span class="hljs-keyword">const</span> String &amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>==other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">delete</span>[] m_data;</span><br><span class="line"><span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(other.m_data);</span><br><span class="line">m_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len + <span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line"><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现智能指针auto-ptr"><a href="#实现智能指针auto-ptr" class="headerlink" title="实现智能指针auto_ptr"></a>实现智能指针auto_ptr</h2><p>auto_ptr归根到底是一个模版类，那么这个类要实现哪些功能呢？如下：<br><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">一个智能指针应该有以下操作：</span></span><br><span class="line"><span class="hljs-comment">1.Auto_ptr&lt;T&gt; ap; 　　　　　　     //创建名为ap的为绑定Auto_ptr对象</span></span><br><span class="line"><span class="hljs-comment">2.Auto_ptr&lt;T&gt; ap(p); 　　　　　   //创建 ap 的Auto_ptr对象，ap用友指针 p 指向的对象。该构造函数为explicit</span></span><br><span class="line"><span class="hljs-comment">3.Auto_ptr&lt;T&gt; ap1(ap2)              //创建名为ap1的Auto_ptr对象，ap1保存原来存在ap2中的指针。将所有权转给ap1，ap2成为未绑定的Auto_ptr对象</span></span><br><span class="line"><span class="hljs-comment">4.ap1 = ap2　　　　　　　　　　　 //将所有权从ap2转给ap1。删除ap1指向的对象并且使ap1指向ap2指向的对象，使ap2成为未绑定的</span></span><br><span class="line"><span class="hljs-comment">5.~ap 　　　　　　　　　　　　　　 //析构函数。删除ap指向的对象</span></span><br><span class="line"><span class="hljs-comment">6.*ap                                            //返回对ap所绑定对象的引用</span></span><br><span class="line"><span class="hljs-comment">7.ap-&gt;                                          //返回ap保存的指针</span></span><br><span class="line"><span class="hljs-comment">8.ap.reset(p)                                //如果ap与p的值不同，则删除ap指向的独享并且将ap绑定到p</span></span><br><span class="line"><span class="hljs-comment">9.ap.release()                               //返回ap所保存的指针并且是ap成为未绑定的</span></span><br><span class="line"><span class="hljs-comment">10.ap.get()                                   //返回ap保存的指针</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure></p><p>具体代码如下：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Auto_ptr</span> &#123;</span></span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    T *ptr;        <span class="hljs-comment">//真正的指针值</span></span><br><span class="line">    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">bool</span> owns;    <span class="hljs-comment">//是否拥有该指针</span></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line">    <span class="hljs-comment">//不可以隐式转化的构造函数</span></span><br><span class="line">    explicit Auto_ptr(T *p = 0):ptr(p),owns((bool)p)&#123;&#125;    //不能隐式转化，例如Auto_ptr&lt;int&gt; Ap = new int(1024) //error</span><br><span class="line">    <span class="hljs-comment">//复制构造函数</span></span><br><span class="line">    <span class="hljs-comment">//Auto_ptr(const Auto_ptr&amp; a):ptr(a.ptr),owns(a.owns)&#123; a.owns = 0;&#125;</span></span><br><span class="line">    <span class="hljs-comment">//泛化版的复制构造函数</span></span><br><span class="line">    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-title">Auto_ptr</span>(<span class="hljs-title">const</span> <span class="hljs-title">Auto_ptr</span>&lt;U&gt;&amp; <span class="hljs-title">a</span>):</span>ptr(a.ptr),owns(a.owns)&#123; a.owns = <span class="hljs-number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//重载赋值操作符</span></span><br><span class="line">    Auto_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Auto_ptr&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(&amp;a != <span class="hljs-keyword">this</span>)    <span class="hljs-comment">//防止自身赋值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(owns)</span><br><span class="line">                <span class="hljs-keyword">delete</span> ptr;</span><br><span class="line">            owns = a.owns;</span><br><span class="line">            ptr  = a.ptr;</span><br><span class="line">            a.owns = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//泛化版的重载赋值操作符</span></span><br><span class="line">    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-title">Auto_ptr</span>&amp; <span class="hljs-title">operator</span>=(<span class="hljs-title">Auto_ptr</span>&lt;U&gt;&amp; <span class="hljs-title">a</span>)</span></span><br><span class="line"><span class="hljs-class">    &#123;</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (&amp;a != <span class="hljs-keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(owns)</span><br><span class="line">                <span class="hljs-keyword">delete</span> ptr;</span><br><span class="line">            owns = a.owns;</span><br><span class="line">            ptr  = a.ptr;</span><br><span class="line">            a.owns = <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="hljs-keyword">operator</span>  *() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> *ptr;&#125; </span><br><span class="line">    T* <span class="hljs-keyword">operator</span> -&gt;() <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">return</span> ptr;&#125;</span><br><span class="line">    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> ptr;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T *p = <span class="hljs-number">0</span>)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(owns)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(ptr != p)    <span class="hljs-comment">//如果p 和 ptr的值不同    </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">delete</span> ptr;    <span class="hljs-comment">//删除原来指向的对象</span></span><br><span class="line">            &#125;                <span class="hljs-comment">//else付过相同肯定不能删除啊</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr = p;            <span class="hljs-comment">//这里赋值时安全的，机试ptr和p原来相等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>&#123; owns = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> ptr;&#125;</span><br><span class="line">    ~Auto_ptr()&#123;<span class="hljs-keyword">if</span>(owns) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"析构！"</span>&lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">delete</span> ptr;&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>测试代码如下:<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    Auto_ptr&lt;<span class="hljs-keyword">int</span>&gt; Ap;</span><br><span class="line">    Auto_ptr&lt;<span class="hljs-keyword">int</span>&gt; Ap1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>));</span><br><span class="line">    <span class="hljs-comment">//Auto_ptr&lt;int&gt; Ap2 = new int(1024);    //error</span></span><br><span class="line">    <span class="hljs-comment">//if(Ap == NULL)        //error</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(Ap.get() == <span class="hljs-literal">NULL</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Ap is NULL!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Before = Ap1 value is:"</span> &lt;&lt; Ap1.get() &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    Auto_ptr&lt;<span class="hljs-keyword">int</span>&gt; Ap3 ;</span><br><span class="line">    Ap3 = Ap1;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After  = Ap1 value is:"</span> &lt;&lt; Ap1.get() &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> *p = Ap3.release();</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Ap3 value is:"</span> &lt;&lt; Ap3.get() &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">    Ap3.reset(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">12</span>));</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Ap3 value is:"</span> &lt;&lt; Ap3.get() &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试的结果:</p><p><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/cpp.jpg" alt></div><br>由上图我们可以看到Ap1在 赋值=之前和之后都指向的地址都是00620FB8，说明赋值并没有改变智能指针的指向，只是将拥有的标志owns改变了。通过reset函数可以重新绑定智能指针！</p><h2 id="c-中的smart-pointer-智能指针"><a href="#c-中的smart-pointer-智能指针" class="headerlink" title="c++中的smart pointer-智能指针"></a>c++中的smart pointer-智能指针</h2><p>智能指针有很多，其中最开始使用的是auto_ptr指针，但是这个指针因为有缺陷已经被废弃。所以在新的C++标准中我们建议使用unique_ptr、shared_ptr、weak_ptr以及intrusive_ptr，这几个指针都是比较常用的，都是轻量级对象，速度与原始的指针相差无几，都是异常安全的，而且对于所指向的类型T只有一个要求，类型T的析构函数不能抛出异常(但是在实际工程的时候，在嵌入式等cpu比较弱的平台使用这些智能指针需要好好考虑一下，另外如果你不懂得如何使用这些智能指针，那就别使用它们)。</p><h3 id="使用智能指针管理内存资源，RAII"><a href="#使用智能指针管理内存资源，RAII" class="headerlink" title="使用智能指针管理内存资源，RAII"></a>使用智能指针管理内存资源，RAII</h3><ol><li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</li><li>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</li></ol><h3 id="智能指针的作用"><a href="#智能指针的作用" class="headerlink" title="智能指针的作用"></a>智能指针的作用</h3><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>shared_ptr多个指针指向相同的对象，调用一个名为make_shared的标准库函数，shared_ptr<int> p = make_shared<int>(42);通常用auto更方便，auto p = …;shared_ptr<int> p2(new int(2));<br>每个shared_ptr都有一个关联的计数器，通常称为引用计数，一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象；shared_ptr的析构函数就会递减它所指的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。</int></int></int></p><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>一个unique_ptr拥有它所指向的对象。某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放。</p><p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p><h2 id="关于赋值操作与自我赋值"><a href="#关于赋值操作与自我赋值" class="headerlink" title="关于赋值操作与自我赋值"></a>关于赋值操作与自我赋值</h2><ul><li>赋值操作的返回值应该是一个引用，也就是operator=返回一个reference to *this，这样可以保证连续赋值。</li><li>传入赋值函数的参数应该声明为常量引用，并且加上const关键字。<br>-赋值操作中自身内存空间的问题，在赋值新的内存空间之后之前的空间是否已经释放，否则会造成空间泄漏。</li><li>要留意自我赋值的操作，如果发生了自我赋值，直接返回原本的指针即可。<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;str)   <span class="hljs-comment">// 如果不等于自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        CMyString strTemp(str);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">char</span>* pTemp = strTemp.m_pdata;</span><br><span class="line">        strTemp.m_pdata = m_pdata;</span><br><span class="line">        m_pdata = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新中。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>AdaBoost、GBDT、RF、XGboost、LightGBM的对比</title>
    <link href="http://www.cygao.xyz/2019/09/21/difference/"/>
    <id>http://www.cygao.xyz/2019/09/21/difference/</id>
    <published>2019-09-21T14:39:52.000Z</published>
    <updated>2019-09-22T03:46:43.581Z</updated>
    
    <content type="html"><![CDATA[<p>覆盖优缺点和对比。<br><a id="more"></a></p><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>AdaBoost是基于boosting的思想，通过多个弱分类器的线性组合来得到强分类器，训练时重点关注被错分的样本，准确率高的弱分类器权重大。</p><h3 id="更深一步的介绍"><a href="#更深一步的介绍" class="headerlink" title="更深一步的介绍"></a>更深一步的介绍</h3><p>在训练过程中，它不改变所给的训练数据，而是不断改变训练数据权值的分布，使得被误分类的数据再后一轮的分类中受到更大的关注。<br>同时采用加权多数表决的方法，加大分类误差率小的弱分类器的权值，使其在最后的表决中起更大的作用，减小分类误差率大的弱分类器的权值，使其在最后的表决中起较小的作用。所有弱分类器的权值之和并不为1，是通过最后结果的符号来决定实例的类别，该结果的绝对值表示分类的确信度。（参考《统计学习方法》P140）<br>Adaboost 还有另外一种理解，即可以认为其模型是加法模型、损失函数为指数函数、学习算法为前向分步算法的二类分类学习方法。(参考《统计学习方法》P143)<br>加法模型就是多个基函数线性组合得到的模型<br>前向分步算法：对于加法模型，从前往后，每一步只学习一个基函数及其系数，而不是一次性学习所有的基函数，从而简化优化的复杂度。<br>损失函数是根据 adaboost 算法特点推导而来的。</p><h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><h3 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>GBDT是基于boosting的思想，串行地构造多棵决策树来进行数据的预测，它是在损失函数所在的函数空间中做梯度下降，即把待求的决策树模型当作参数，每轮迭代都去拟合损失函数在当前模型下的负梯度，从而使得参数朝着最小化损失函数的方向更新。</p><h3 id="更深一步的介绍-1"><a href="#更深一步的介绍-1" class="headerlink" title="更深一步的介绍"></a>更深一步的介绍</h3><p>GBDT可以看作是AdaBoost的一个推广，AdaBoost是通过错分数据点来识别问题，通过调整错分数据点的权重来改进模型，GBDT是通过负梯度来识别问题，通过计算负梯度来改进模型，实际上，负梯度绝对值大的样例同样会在之后的训练中受到更大的关注，因为它造成的损失更容易在最后的损失函数中占很大的比重，因此，需要更多地偏向于它去减小损失。这也是GBDT和AdaBoost相似的一个点，而相比AdaBoost, Gradient Boosting可以使用更多类型的损失函数，因此可以解决更多的问题。<br>最常见的损失函数是平方损失函数，square loss的优点是便于理解和实现，它的负梯度就是残差，而其他损失函数的负梯度只能看作残差的近似值，它的缺点在于对于异常值它的鲁棒性较差，因此会常用absolute loss或Huber loss来代替。</p><h2 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h2><h3 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>随机森林算法背后的思想是群体智慧的体现，它通过随机的行采样(bagging)和列采样(feature bagging)构造不同的训练集，建立一个决策树森林，利用加权平均方式或多数表决的方式得到最后的预测结果，能够并行学习，对噪声和异常数据具有很好的过滤作用，因此有很广泛的应用。</p><h3 id="更深一步的介绍-2"><a href="#更深一步的介绍-2" class="headerlink" title="更深一步的介绍"></a>更深一步的介绍</h3><p>随机森林的行采样(bagging)和列采样(feature bagging)都是为了减小模型之间的相关性使基学习器变得不同从而减小集成模型的方差，但这种随机性会导致随机森林的偏差有所增加（相比于单棵不随机树），因此随机森林的单棵树都会采用很深的决策树，并不进行剪枝操作，以减小每棵树的偏差，这使得每一棵决策树就是一个精通于某一个窄领域的专家（因为我们从全部特征中选择部分来让每一棵决策树学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终再通过投票或平均得到结果。这也正是群体智慧的体现。</p><h2 id="XGboost"><a href="#XGboost" class="headerlink" title="XGboost"></a>XGboost</h2><h3 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>xgboost是梯度提升树的一种高效系统实现，是对GBDT进一步的改进，包括对代价函数进行了二阶泰勒展开，在代价函数里加入了正则项，借鉴了随机森林的列采样方法，支持并行计算等</p><h3 id="更深一步的介绍-3"><a href="#更深一步的介绍-3" class="headerlink" title="更深一步的介绍"></a>更深一步的介绍</h3><ul><li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li><li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</li><li>Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率）</li><li>列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。<br>对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。</li><li>xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</li><li>可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。<h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><h3 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h3>LightGBM是一个实现GBDT算法的分布式高效框架。它通过leaf-wise分裂方法进行决策树的生成，通过基于直方图的算法寻找特征分割点，并支持并行学习，能够更高效的处理大数据，也得到了越来越广泛的应用。<h3 id="更深一步的介绍-4"><a href="#更深一步的介绍-4" class="headerlink" title="更深一步的介绍"></a>更深一步的介绍</h3>要减少训练的复杂度，可以通过减少特征量和数据量来实现，即从行和列两个角度来减少数据，同时要尽可能少的影响最后的精度。在LightGBM中，就是这样做的，对应着GOSS和EFB<br><strong><em>Gradient-based One-Side Sampling (GOSS)</em></strong>：GBDT虽然没有数据权重，但每个数据实例有不同的梯度，根据计算信息增益的定义，梯度大的实例对信息增益有更大的影响，因此在下采样时，我们应该尽量保留梯度大的样本（预先设定阈值，或者最高百分位间），随机去掉梯度小的样本。此措施在相同的采样率下比随机采样获得更准确的结果，尤其是在信息增益范围较大时。<br><strong><em>Exclusive Feature Bundling (EFB)</em></strong>：通常在真实应用中，虽然特征量比较多，但是由于特征空间十分稀疏，许多特征几乎是互斥的（例如许多特征不会同时为非零值，像one-hot），EFB通过捆绑互斥的特征，并将捆绑问题归约到图着色问题，通过贪心算法求得近似解，以减少特征数量。<br>对于树的分裂方法，它通过leaf-wise分裂产生比level-wise分裂更复杂的树，能够实现更高的准确率。虽然这样有时候会导致过拟合，但可以通过设置 max-depth 参数来防止过拟合的发生。（每一次的生长都是选取分裂增益最高的节点，而不是对一层中的所有节点都进行分裂）。<br>其次，它使用基于直方图的算法，将连续的特征值分桶(buckets)装进离散的箱子(bins)，并通过直方图做差加速计算兄弟节点的直方图，能够加速训练过程，并实现更少的内存占用。<br>另外，它支持并行学习，包括<strong>特征并行</strong>和<strong>数据并行</strong></li><li>特征并行的主要思想是不同机器在不同的特征集合上分别寻找最优的分割点，然后在机器间同步最优的分割点。（mapreduce思想）</li><li>数据并行则是让不同的机器先在不同的记录集合上构造直方图，然后进行全局的合并，最后在合并的直方图上面寻找最优分割点。</li></ul><p>它还支持直接输入类别特征，在对离散类别特征分裂时，每个取值都当作一个桶，分裂时的增益算的是”是否属于某个类别“的增益，对于类别特征的操作类似于one-hot编码。<br>CatBoost<br>简单介绍<br>CatBoost是Category 和 Boosting的缩写，最大的特点就是可以直接处理类别特征，不需要任何预处理来将类别转换为数字。</p><h2 id="随机森林的优缺点："><a href="#随机森林的优缺点：" class="headerlink" title="随机森林的优缺点："></a>随机森林的优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>训练可以高度并行化，对于大数据时代的大样本训练速度有优势。<br>由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。<br>在训练后，可以给出各个特征对于输出的重要性<br>由于采用了随机采样，训练出的模型的方差小，泛化能力强。<br>相对于 Boosting 系列的 Adaboost 和 GBDT， RF 实现比较简单。<br>对部分特征缺失不敏感。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>在某些噪音比较大的样本集上，RF 模型容易陷入过拟合。<br>取值划分比较多的特征容易对 RF 的决策产生更大的影响，从而影响拟合的模型的效果。</p><h2 id="随机森林-和-GBDT-的区别："><a href="#随机森林-和-GBDT-的区别：" class="headerlink" title="随机森林 和 GBDT 的区别："></a>随机森林 和 GBDT 的区别：</h2><ol><li>组成随机森林的树可以是分类树，也可以是回归树；而 GBDT 只由回归树组成。</li><li>组成随机森林的树可以并行生成（Bagging）；而 GBDT 只能是串行生成（Boosting）。</li><li>对于最终的输出结果而言，随机森林采用多数投票；而 GBDT 则是将所有结果加权累加起来。</li><li>随机森林对异常值不敏感，GBDT 对异常值非常敏感。</li><li>随机森林对训练集一视同仁，GBDT 是基于权值的弱分类器的集成。</li><li>随机森林是通过减少模型方差提高性能，GBDT 是通过减少模型偏差提高性能。</li></ol><h2 id="GBDT-和-DT（决策树）区别："><a href="#GBDT-和-DT（决策树）区别：" class="headerlink" title="GBDT 和 DT（决策树）区别："></a>GBDT 和 DT（决策树）区别：</h2><ol><li>GBDT 是一种 boosting 集成算法，是由多个 CART 回归树集成得到，CART 树是决策树的其中一种；</li><li>决策树是针对样本的预测正确率进行构建，而 GBDT 是针对之前生成的树的残差进行拟合而构建一系列树；<br>GBDT 和 XGBoost 区别：</li><li>优化方法：GBDT 利用梯度下降法进行优化，而 XGBoost 利用牛顿法进行优化；前者只计算一阶梯度，而后者同时用到了一阶梯度和二阶梯度，能加快收敛速度。</li><li>正则项：GBDT 没有正则项，XGBoost 中加入了正则项来防止过拟合，正则项中包含了树的叶结点个数和每个叶结点的得分值的 L2 的平方和。</li><li>XGBoost 增加了处理缺失值的方案，能够自动学习缺失值的处理策略。</li><li>XGBoost 借鉴了随机森林的做法，支持特征抽样，防止过拟合，并减少计算量。</li><li>XGBoost 支持特征粒度上的并行(不是树粒度上并行，因为整体还是boosting算法，需要串行生成树)，在确定最佳分割点之前，提前对特征进行预排序。</li><li>GBDT 以 CART 回归树作为基学习器，XGBoost 不仅如此还支持线性分类器，此时 XGBoost 就相当于带正则项的逻辑斯蒂回归或线性回归。</li><li>XGBoost 带有 Shrinkage 参数，相当于学习率的作用。<h2 id="XGBoost-和-LightGBM-区别："><a href="#XGBoost-和-LightGBM-区别：" class="headerlink" title="XGBoost 和 LightGBM 区别："></a>XGBoost 和 LightGBM 区别：</h2></li><li><p>树的切分策略不同：XGB 是 level-wise，而 LGB 是leaf-wise。level-wise 的建树方式对当前层的所有叶节点一视同仁，有些叶节点的分裂收益很小仍然需要进行分裂，增加了计算代价。leaf-wise 方式的精度更高，但容易过拟合，所以要控制树的最大深度。</p></li><li><p>在选择数据分割点时：XGB 是通过预排序的方式，空间消耗较大；LGB是通过直方图算法，不需要进行预排序，内存占用更低。</p></li><li><p>在并行策略上，XGB 主要集中在特征并行上，而 LGB 的并行策略包含特征并行、数据并行和投票并行（Data parallel，Feature parallel， Voting parallel）。</p></li></ol><h2 id="xgb是对gbdt的优化改进"><a href="#xgb是对gbdt的优化改进" class="headerlink" title="xgb是对gbdt的优化改进"></a>xgb是对gbdt的优化改进</h2><ol><li>目标函数中加入了正则项来控制模型的复杂度，替代原来的剪枝方法。</li><li>利用了one-hot编码等情况中的特征稀疏性。（仅对特征值为非缺失值的样本的特征进行遍历）</li><li>支持列抽样（同random forest）。</li><li>数据事先排序并按block结构保存，有利于并行运算（树的生成还是串行的，这里说的并行计算指并行计算各个特征的增益或是基尼系数）。除此之外，xgb还通过一种可并行的近似直方图算法来高效生成候选的分割点。</li><li>对损失函数进行了优化，gbdt只用到了其一阶导数信息，而xgb同时用到其一阶导与二阶导。</li></ol><h2 id="lgb则是在xgb基础上进一步改进"><a href="#lgb则是在xgb基础上进一步改进" class="headerlink" title="lgb则是在xgb基础上进一步改进"></a>lgb则是在xgb基础上进一步改进</h2><ol><li>内存需求小：xgb使用基于pre-sorted的决策树算法，而lgb使用基于histogram的决策树算法。histogram算法占用的内存很小：pre-sorted需要两倍数据大小的内存空间，一半用于数据（float32），一半用于存放排好序的索引，而histogram不需要存放索引，且特征值只需要存放离散后的值，用uint8即可，故内存需求仅为pre-sorted的1/8。</li><li>计算速度快：决策树算法的主要操作包括“寻找分割点”与“数据分割”两步，pre-sorted算法和histogram算法在“寻找分割点”上的时间复杂度是一致的；但是在“数据分割”上histogram要快，histogram所有特征共享一张索引，而pre-sorted一个特征对应一张索引，若集合level-wise，pre-sorted也可以共用一张索引，但是会带来很多随机访问的问题，速度仍不及histogram。此外，histogram算法还减少了计算分割点增益的次数。</li><li>通信代价小：histogram算法的通信代价远远小于pre-sorted，可用于分布式计算。<br>但是，histogram不能找到很精确的分割点，训练误差不如pre-sorted算法，可以说是牺牲一定精度来换取速度。需要指出的是，这种粗犷的分割相当于自带正则效果，所以测试集的误差两种决策树算法差距不大。</li></ol><h2 id="关键两点差别"><a href="#关键两点差别" class="headerlink" title="关键两点差别"></a>关键两点差别</h2><ol><li>决策树算法</li></ol><p>XGBoost使用的是pre-sorted算法，能够更精确的找到数据分隔点；LightGBM使用的是histogram算法，占用的内存更低，数据分隔的复杂度更低。</p><ol start="2"><li>决策树生长策略</li></ol><p>XGBoost采用的是level（depth）-wise生长策略，能够同时分裂同一层的叶子，从而进行多线程优化，不容易过拟合；但不加区分的对待同一层的叶子，带来了很多没必要的开销。</p><p>LightGBM采用leaf-wise生长策略，每次从当前所有叶子中找到分裂增益最大（一般也是数据量最大）的一个叶子，然后分裂，如此循环；但会生长出比较深的决策树，产生过拟合。因此，LightGBM 在leaf-wise 之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/56137208" target="_blank" rel="noopener">AdaBoost、GBDT、RF、XGboost、LightGBM的对比分析</a></p><p><a href="https://zhuanlan.zhihu.com/p/72247243" target="_blank" rel="noopener">RF、GBDT、XGBoost、LightGBM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;覆盖优缺点和对比。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>L1正则&amp;L2正则常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/05/l1l2/"/>
    <id>http://www.cygao.xyz/2019/09/05/l1l2/</id>
    <published>2019-09-05T13:01:50.000Z</published>
    <updated>2019-09-05T13:23:22.929Z</updated>
    
    <content type="html"><![CDATA[<p>L1正则&amp;L2正则常考题目及解答。<br><a id="more"></a></p><ol><li>过拟合的解决方式有哪些，l1和l2正则化都有哪些不同，各自有什么优缺点(爱奇艺)</li><li>L1和L2正则化来避免过拟合是大家都知道的事情，而且我们都知道L1正则化可以得到稀疏解，L2正则化可以得到平滑解，这是为什么呢？</li><li>L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。（美团）</li><li>L1和L2的区别，以及各自的使用场景（头条）</li></ol><h2 id="什么是L1正则-amp-L2正则？"><a href="#什么是L1正则-amp-L2正则？" class="headerlink" title="什么是L1正则&amp;L2正则？"></a>什么是L1正则&amp;L2正则？</h2><p>L1正则即将参数的绝对值之和加入到损失函数中，以二元线性回归为例，损失函数变为：</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l11.png" alt></div><br>L2正则即将参数的平方之和加入到损失函数中，以二元线性回归为例，损失函数变为：<br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l12.png" alt></div> <h2 id="L1正则-amp-L2正则的区别是什么？"><a href="#L1正则-amp-L2正则的区别是什么？" class="headerlink" title="L1正则&amp;L2正则的区别是什么？"></a>L1正则&amp;L2正则的区别是什么？</h2><ol><li>L1正则化是指在损失函数中加入权值向量w的绝对值之和，即各个元素的绝对值之和，L2正则化指在损失函数中加入权值向量w的平方和。</li><li>L1的功能是使权重稀疏，而L2的功能是使权重平滑。</li></ol><h2 id="L1正则为什么可以得到稀疏解？"><a href="#L1正则为什么可以得到稀疏解？" class="headerlink" title="L1正则为什么可以得到稀疏解？"></a>L1正则为什么可以得到稀疏解？</h2><h3 id="解空间形状"><a href="#解空间形状" class="headerlink" title="解空间形状"></a>解空间形状</h3><p>L2正则化相当于为参数定义了一个圆形的解空间，而L1正则化相当于为参数定义了一个菱形的解空间。L1“棱角分明”的解空间显然更容易与目标函数等高线在脚点碰撞。从而产生稀疏解。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l13.jpg" alt></div> <p>其中变量 w 是动态参数，如果我们调节 w 就会得到一系列的圆，这也是你在上图中看到这么多圆线的原因，上图中其实假设了 w 参数只有二维，这样方便在图中表示，与此同时 L 的图像是一个旋转 90 度的矩形，图像中二者交点的位置就是可能出现最优解的地方，你会发现二者相交出现极大可能的位置就是顶点处，矩形顶点的地方肯定是由其中一个 w 为 0 的，w 为 0 则表示其中一个特征并不是我们需要的特征可以忽略不计，这就说明了 L1 会产生稀疏解的原因。</p><h2 id="L2为什么可以解决过拟合"><a href="#L2为什么可以解决过拟合" class="headerlink" title="L2为什么可以解决过拟合"></a>L2为什么可以解决过拟合</h2><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数 w 都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。若某个 w 参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果 w 参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。L2正则化就是可以使权重平滑。</p><h2 id="L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验"><a href="#L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验" class="headerlink" title="L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验"></a>L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;L1正则&amp;amp;L2正则常考题目及解答。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【python】冒泡，选择，插入，希尔，快速，归并排序的实现及图解</title>
    <link href="http://www.cygao.xyz/2019/08/13/sort/"/>
    <id>http://www.cygao.xyz/2019/08/13/sort/</id>
    <published>2019-08-13T04:54:16.000Z</published>
    <updated>2019-09-26T08:52:58.076Z</updated>
    
    <content type="html"><![CDATA[<p>总结基本的排序算法。<br><a id="more"></a></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>冒泡排序</strong>（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了<strong>最后一个</strong>。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  </li></ul><p>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示： </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort1.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>):</span><br><span class="line">        count = <span class="hljs-number">0</span>  <span class="hljs-comment">#利用count进行优化，如果中间有一次不交换了，则证明已经排序完毕</span></span><br><span class="line">        <span class="hljs-comment"># j表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>-j):</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[i] &gt; alist[i+<span class="hljs-number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="hljs-number">1</span>] = alist[i+<span class="hljs-number">1</span>], alist[i]</span><br><span class="line">                count+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）需要加上count进行判断。</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定<h2 id="冒泡排序的演示"><a href="#冒泡排序的演示" class="headerlink" title="冒泡排序的演示"></a>冒泡排序的演示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort2.gif" alt></div> </li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="hljs-comment"># 需要进行n-1次选择操作</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>):</span><br><span class="line">        <span class="hljs-comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="hljs-comment"># 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, n):</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="hljs-comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n2)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定（考虑升序每次选择最大的情况）</li></ul><h2 id="选择排序的演示"><a href="#选择排序的演示" class="headerlink" title="选择排序的演示"></a>选择排序的演示</h2><p>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort3.gif" alt></div> <h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(alist)):</span><br><span class="line">        <span class="hljs-comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[j] &lt; alist[j<span class="hljs-number">-1</span>]:</span><br><span class="line">                alist[j], alist[j<span class="hljs-number">-1</span>] = alist[j<span class="hljs-number">-1</span>], alist[j]</span><br><span class="line">                j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）每次都直接break，跳出循环</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定</li></ul><h2 id="插入排序的演示"><a href="#插入排序的演示" class="headerlink" title="插入排序的演示"></a>插入排序的演示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort4.gif" alt></div><br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort5.gif" alt></div> <h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>希尔排序</strong>(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><blockquote><p>python2和python3里的整除分别对应 <strong>/</strong> 和 <strong>//</strong>。</p></blockquote><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="hljs-comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-keyword">while</span> gap &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="hljs-comment"># 插入排序</span></span><br><span class="line">            <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> alist[j-gap] &gt; alist[j]:</span><br><span class="line">                    alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n2)</li><li>稳定想：不稳定</li></ul><h2 id="希尔排序的图示"><a href="#希尔排序的图示" class="headerlink" title="希尔排序的图示"></a>希尔排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/shellsort.png" alt></div> <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序</strong>（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(alist, start, end)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""快速排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 递归的退出条件</span></span><br><span class="line">    <span class="hljs-keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="hljs-comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="hljs-comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low<span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="hljs-number">1</span>, end)</span><br><span class="line"></span><br><span class="line">alist = [<span class="hljs-number">54</span>,<span class="hljs-number">26</span>,<span class="hljs-number">93</span>,<span class="hljs-number">17</span>,<span class="hljs-number">77</span>,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">20</span>]</span><br><span class="line">quick_sort(alist,<span class="hljs-number">0</span>,len(alist)<span class="hljs-number">-1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure><p>另外一种更加直观的<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> alist</span><br><span class="line">    mid = alist[<span class="hljs-number">0</span>]</span><br><span class="line">    left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> alist[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> x &lt; mid]</span><br><span class="line">    right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> alist[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> x &gt; mid]</span><br><span class="line">    <span class="hljs-keyword">return</span> quicksort(left) + [mid] + quicksort(right)</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p><h2 id="快速排序的图示"><a href="#快速排序的图示" class="headerlink" title="快速排序的图示"></a>快速排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/quicksort.jpg" alt></div> <h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>归并排序</strong>是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p><p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) &lt;= <span class="hljs-number">1</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> alist</span><br><span class="line">    <span class="hljs-comment"># 二分分解</span></span><br><span class="line">    num = len(alist)/<span class="hljs-number">2</span></span><br><span class="line">    left = merge_sort(alist[:num])</span><br><span class="line">    right = merge_sort(alist[num:])</span><br><span class="line">    <span class="hljs-comment"># 合并</span></span><br><span class="line">    <span class="hljs-keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right)</span>:</span></span><br><span class="line">    <span class="hljs-string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    <span class="hljs-comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="hljs-keyword">while</span> l&lt;len(left) <span class="hljs-keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="hljs-keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="hljs-number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line"></span><br><span class="line">alist = [<span class="hljs-number">54</span>,<span class="hljs-number">26</span>,<span class="hljs-number">93</span>,<span class="hljs-number">17</span>,<span class="hljs-number">77</span>,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">20</span>]</span><br><span class="line">sorted_alist = mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(nlogn)</li><li>稳定性：稳定</li></ul><h2 id="归并排序的图示"><a href="#归并排序的图示" class="headerlink" title="归并排序的图示"></a>归并排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/mergesort.gif" alt></div> <h1 id="常见排序算法效率比较"><a href="#常见排序算法效率比较" class="headerlink" title="常见排序算法效率比较"></a>常见排序算法效率比较</h1><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/compare.png" alt></div> <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找</p><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(alist, item)</span>:</span></span><br><span class="line">      first = <span class="hljs-number">0</span></span><br><span class="line">      last = len(alist)<span class="hljs-number">-1</span></span><br><span class="line">      <span class="hljs-keyword">while</span> first&lt;=last:</span><br><span class="line">          midpoint = (first + last)/<span class="hljs-number">2</span></span><br><span class="line">          <span class="hljs-keyword">if</span> alist[midpoint] == item:</span><br><span class="line">              <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">          <span class="hljs-keyword">elif</span> item &lt; alist[midpoint]:</span><br><span class="line">              last = midpoint<span class="hljs-number">-1</span></span><br><span class="line">          <span class="hljs-keyword">else</span>:</span><br><span class="line">              first = midpoint+<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">testlist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">13</span>))</span><br></pre></td></tr></table></figure><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(alist, item)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) == <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        midpoint = len(alist)//<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">if</span> alist[midpoint]==item:</span><br><span class="line">          <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">          <span class="hljs-keyword">if</span> item&lt;alist[midpoint]:</span><br><span class="line">            <span class="hljs-keyword">return</span> binary_search(alist[:midpoint],item)</span><br><span class="line">          <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> binary_search(alist[midpoint+<span class="hljs-number">1</span>:],item)</span><br><span class="line"></span><br><span class="line">testlist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">13</span>))</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(1)</li><li>最坏时间复杂度：O(logn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结基本的排序算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="基本算法" scheme="http://www.cygao.xyz/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【python】 多种链表的实现及python中“=”的解读</title>
    <link href="http://www.cygao.xyz/2019/08/12/linked%20list/"/>
    <id>http://www.cygao.xyz/2019/08/12/linked list/</id>
    <published>2019-08-12T08:54:16.000Z</published>
    <updated>2019-09-02T01:52:29.519Z</updated>
    
    <content type="html"><![CDATA[<p>python中“=”的正确、简单好记的理解以及python链表的实现。<br><a id="more"></a></p><h1 id="python中“-”的理解"><a href="#python中“-”的理解" class="headerlink" title="python中“=”的理解"></a>python中“=”的理解</h1><p>python并不像是c/c++，c++中新建一个变量，比如<code>int a = 3</code>，此时必须申明变量的类型，找一块内存空间存储3，这个内存空间的别名是a，占4个字节且a只能存整数。</p><p>python中并不需要申明类型，<code>a  = 10</code>这种隐式申明的的原因是，a是另外一个内存，保存的是一个地址，地址指向什么就代表a是什么。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def C():</span><br><span class="line">    pass</span><br><span class="line">a = C</span><br></pre></td></tr></table></figure></p><p>a可以重新指向一个方法，类或是对象中的元素都行。所以 <strong>=</strong> 只能代表把指向更改，指向了什么。</p><h1 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleNode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单链表的结点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># _item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="hljs-comment"># _next是下一个节点的标识</span></span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><h1 id="单链表的实现及部分操作"><a href="#单链表的实现及部分操作" class="headerlink" title="单链表的实现及部分操作"></a>单链表的实现及部分操作</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkList</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.__head = <span class="hljs-literal">None</span> </span><br><span class="line">        <span class="hljs-comment">#__双下划线代表私有变量/方法</span></span><br><span class="line">        <span class="hljs-comment">#_但下划线代表保护变量/方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.__head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""链表长度"""</span></span><br><span class="line">        <span class="hljs-comment"># cur初始时指向头节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 尾节点指向None，当未到达尾部时</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment"># 将cur后移一个节点</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            print(cur.item,end=<span class="hljs-string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line"> ```       </span><br><span class="line"><span class="hljs-comment">## 头部添加元素 </span></span><br><span class="line">```python</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部添加元素"""</span></span><br><span class="line">        <span class="hljs-comment"># 先创建一个保存item值的节点</span></span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        <span class="hljs-comment"># 将新节点的链接域next指向头节点，即_head指向的位置</span></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        <span class="hljs-comment"># 将链表的头_head指向新节点</span></span><br><span class="line">        self.__head = node</span><br></pre></td></tr></table></figure><h2 id="尾部添加元素"><a href="#尾部添加元素" class="headerlink" title="尾部添加元素"></a>尾部添加元素</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""尾部添加元素"""</span></span><br><span class="line">    node = SingleNode(item)</span><br><span class="line">    <span class="hljs-comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="hljs-comment"># 若不为空，则找到尾部，将尾节点的next指向新节点</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != <span class="hljs-literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br></pre></td></tr></table></figure><h2 id="指定位置添加元素"><a href="#指定位置添加元素" class="headerlink" title="指定位置添加元素"></a>指定位置添加元素</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link1.png" alt></div><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""指定位置添加元素"""</span></span><br><span class="line">    <span class="hljs-comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">    <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">        self.add(item)</span><br><span class="line">    <span class="hljs-comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">        self.append(item)</span><br><span class="line">    <span class="hljs-comment"># 找到指定位置</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="hljs-comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">        node.next = pre.next</span><br><span class="line">        <span class="hljs-comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">        pre.next = node</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link2.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""删除节点"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    pre = <span class="hljs-literal">None</span></span><br><span class="line">    <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-comment"># 找到了指定元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-comment"># 如果第一个就是删除的节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre:</span><br><span class="line">                <span class="hljs-comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                self.__head = cur.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 继续按链表后移节点</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br></pre></td></tr></table></figure><h2 id="查找节点是否存在"><a href="#查找节点是否存在" class="headerlink" title="查找节点是否存在"></a>查找节点是否存在</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""链表查找节点是否存在，并返回True或者False"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><h1 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h1><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。<br>链表与顺序表的各种操作复杂度如下所示：</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link3.png" alt></div> <p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p><h1 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h1><p>单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link4.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""节点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinCycLinkedlist</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单向循环链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""返回链表的长度"""</span></span><br><span class="line">        <span class="hljs-comment"># 如果链表为空，返回长度0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment">#添加的节点指向_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="hljs-comment"># 移到链表尾部，将尾部节点的next指向node</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment">#_head指向添加node的</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""尾部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 移到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将尾节点指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment"># 将node指向头节点_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""删除一个节点"""</span></span><br><span class="line">        <span class="hljs-comment"># 若链表为空，则直接返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        <span class="hljs-comment"># 将cur指向头节点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 若头节点的元素就是要查找的元素item</span></span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-comment"># 如果链表不止一个节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> cur.next != self._head:</span><br><span class="line">                <span class="hljs-comment"># 先找到尾节点，将尾节点的next指向第二个节点</span></span><br><span class="line">                <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="hljs-comment"># cur指向了尾节点</span></span><br><span class="line">                cur.next = self._head.next</span><br><span class="line">                self._head = self._head.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 链表只有一个节点</span></span><br><span class="line">                self._head = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="hljs-comment"># 第一个节点不是要删除的</span></span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                <span class="hljs-comment"># 找到了要删除的元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="hljs-comment"># 删除</span></span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="hljs-keyword">return</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># cur 指向尾节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-comment"># 尾部删除</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""查找节点是否存在"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    ll = SinCycLinkedlist()</span><br><span class="line">    ll.add(<span class="hljs-number">1</span>)</span><br><span class="line">    ll.add(<span class="hljs-number">2</span>)</span><br><span class="line">    ll.append(<span class="hljs-number">3</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">3</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">7</span>)</span><br><span class="line">    ll.remove(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。  </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link5.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""双向链表节点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br><span class="line">        self.prev = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkList</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""双向链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""返回链表的长度"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="hljs-comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head.prev = node</span><br><span class="line">            <span class="hljs-comment"># 将_head 指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""尾部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 移动到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != <span class="hljs-literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""查找元素是否存在"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line">            <span class="hljs-comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            node.next = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            <span class="hljs-comment"># 将cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""删除元素"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> cur.next == <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-comment"># 如果链表只有这一个节点</span></span><br><span class="line">                    self._head = <span class="hljs-literal">None</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    cur.next.prev = <span class="hljs-literal">None</span></span><br><span class="line">                    <span class="hljs-comment"># 将_head指向第二个节点</span></span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                <span class="hljs-keyword">return</span></span><br><span class="line">            <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="hljs-comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="hljs-comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                cur = cur.next</span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="hljs-number">1</span>)</span><br><span class="line">    ll.add(<span class="hljs-number">2</span>)</span><br><span class="line">    ll.append(<span class="hljs-number">3</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">3</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">4</span>)</span><br><span class="line">    ll.remove(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中“=”的正确、简单好记的理解以及python链表的实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 list的基本实现</title>
    <link href="http://www.cygao.xyz/2019/08/12/list/"/>
    <id>http://www.cygao.xyz/2019/08/12/list/</id>
    <published>2019-08-12T08:26:12.000Z</published>
    <updated>2019-09-02T01:52:33.732Z</updated>
    
    <content type="html"><![CDATA[<p>总结python在list中的原理和实现。<br><a id="more"></a></p><h1 id="python中list的基本实现技术"><a href="#python中list的基本实现技术" class="headerlink" title="python中list的基本实现技术"></a>python中list的基本实现技术</h1><h2 id="元素外置的顺序表"><a href="#元素外置的顺序表" class="headerlink" title="元素外置的顺序表"></a>元素外置的顺序表</h2><p>python中的list可以存放不同类型的数据，比如int，char，float等等，这些数据元素大小不同，所以得用到外置顺序表。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="hljs-number">1</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-number">2.2</span>]</span><br></pre></td></tr></table></figure></p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list1.png" alt></div>  <blockquote><p>Loc(li) = Loc(l0) + c*i </p></blockquote><p>元素的大小不统一，则须采用如图的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。<br>如图这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h2><p>一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list2.png" alt></div><br>python中的list主要采用分离式结构，如图<br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list3.png" alt></div>  <p>表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。这样在进行扩充的时候，数据的迁移，不用迁徙表头，指针指向的地址改变就行。</p><h2 id="list的数据扩充"><a href="#list的数据扩充" class="headerlink" title="list的数据扩充"></a>list的数据扩充</h2><p>在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结python在list中的原理和实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>linux的个人向常用操作</title>
    <link href="http://www.cygao.xyz/2019/08/10/linux/"/>
    <id>http://www.cygao.xyz/2019/08/10/linux/</id>
    <published>2019-08-10T06:46:44.000Z</published>
    <updated>2019-09-20T06:51:43.148Z</updated>
    
    <content type="html"><![CDATA[<p>纯个人向认为比较重要的，需要熟记。<br><a id="more"></a></p><h2 id="四种通配符："><a href="#四种通配符：" class="headerlink" title="四种通配符："></a>四种通配符：</h2><ol><li>*可以匹配0个或多个任意字符</li><li>？只可以匹配单个字符，但是例如 rm a.*，可以匹配a.jpg，a.txt</li><li>[] 匹配一组单个字符，例如[12]匹配1或2，不匹配12；或者使用连字符分隔一定范围内的字符，例如[1-3]，它匹配1、2或3</li><li>{} 进行两种匹配：字符串和范围。如果用字符串必须用逗号分隔。比如 ls a.{jpg,txt}匹配 a.jpg和a.txt；ls {a,b}.jpg 匹配a.jpg和b.jpg。可以用 mkdir{a,b,c}快速创建多个目录。</li></ol><h2 id="clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。"><a href="#clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。" class="headerlink" title="clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。"></a>clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。</h2><h2 id="ls及其衍生"><a href="#ls及其衍生" class="headerlink" title="ls及其衍生"></a>ls及其衍生</h2><ol><li>ls -R Documents/ 查看该文件夹中的所有文件列表</li><li>比较常用 -l，显示内容列表</li><li>-a查看隐藏文件和文件夹</li><li>-l是默认字母排序 -r倒叙排列，可以搭配-lr，不实用</li><li>-S按照文件大小，可以搭配-laS</li><li>-h人性化显示文件大小，做常用的是-lh</li></ol><h2 id="cd及其衍生"><a href="#cd及其衍生" class="headerlink" title="cd及其衍生"></a>cd及其衍生</h2><ol><li>cd - 改为之前目录</li></ol><h2 id="touch创建空文件，mkdir创建空目录"><a href="#touch创建空文件，mkdir创建空目录" class="headerlink" title="touch创建空文件，mkdir创建空目录"></a>touch创建空文件，mkdir创建空目录</h2><h2 id="cp-源文件-目标文件"><a href="#cp-源文件-目标文件" class="headerlink" title="cp 源文件 目标文件"></a>cp 源文件 目标文件</h2><ol><li>搭配 . 当前目录</li><li>搭配四种通配符</li><li>-v 显示复制文件的过程</li><li>-i 防止在复制时覆盖重要文件</li><li>-r 复制文件夹</li><li>-a等价于-dpr，可以确保备份时不会复制软连接的内容（这可能极大地增加复制量），只保留关键地文件属性（如所有者，时间戳），并递归处理子目录</li></ol><h2 id="mv-源文件-目标文件"><a href="#mv-源文件-目标文件" class="headerlink" title="mv 源文件 目标文件"></a>mv 源文件 目标文件</h2><ol><li>-v,-i,-r等同于cp</li><li>可以用来重命名文件或文件夹</li><li><strong>移动软连接时，例如dogs为~底下的软连接，指向/home/my/pictures/dogs，而现在要将这个链接移动到/home/my/libby下。一下命令只移动软连接：</strong><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv dogs ~/libby</span><br></pre></td></tr></table></figure></li></ol><p><strong>然而，下面的命令移动的时软连接指向的目录：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv dogs/ ~/libby</span><br></pre></td></tr></table></figure></p><p><strong>多了一个”/“！！！</strong></p><h2 id="ln-要链接的文件-硬链接名"><a href="#ln-要链接的文件-硬链接名" class="headerlink" title="ln 要链接的文件 硬链接名"></a>ln 要链接的文件 硬链接名</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxr--r-- 2 root root 4096 abc/</span><br></pre></td></tr></table></figure><p>此处abc为目录，则2代表其下有多少子目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-rw-r--r-- 1 root root a.txt</span><br><span class="line">$ ln a.txt b.txt</span><br><span class="line">$ ls -l</span><br><span class="line">-rw-r--r-- 2 root root a.txt</span><br><span class="line">-rw-r--r-- 2 root root b.txt</span><br></pre></td></tr></table></figure><p>此处1变成2，显示了该文件有多少硬链接。<br>使用 ls -i还会发现其索引号时相同的。a.txt和b.txt内容时一致的，实际在处理同一的数据。</p><p>硬链接的限制：无法指向目录，硬链接和源文件必须处于同一文件系统，因为每个分区都有各自的索引节点。</p><p>使用软连接<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s 源文件 连接名称</span><br></pre></td></tr></table></figure></p><p>硬链接索引节点相同，但软连接不同，因为他们是完全不同的文件。</p><h2 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h2><ol><li>搭配通配符</li><li>-i 提示功能，确认删除</li><li>-rf -r指的是递归每个子目录，删除所有文件，-f直接删除。</li></ol><h2 id="man-有问题找那个男人"><a href="#man-有问题找那个男人" class="headerlink" title="man 有问题找那个男人"></a>man 有问题找那个男人</h2><ol><li>man ls查看ls及其option</li><li>man -f ls 简单查看这个命令的说明</li><li>whatis ls 也是简单查看</li></ol><h2 id="info-查询手册，内容有点乱"><a href="#info-查询手册，内容有点乱" class="headerlink" title="info 查询手册，内容有点乱"></a>info 查询手册，内容有点乱</h2><h2 id="whereis-查找命令的可执行文件、源文件和手册页面的路径"><a href="#whereis-查找命令的可执行文件、源文件和手册页面的路径" class="headerlink" title="whereis 查找命令的可执行文件、源文件和手册页面的路径"></a>whereis 查找命令的可执行文件、源文件和手册页面的路径</h2><p>报告的顺序是:源文件位置–&gt;任何二进制可执行文件的位置–&gt;最后找到的是手册页面的位置。</p><ul><li>只想搜索二进制文件路径 -b whereis -b gcc</li><li>只想搜索手册页面路径 -m whereis -m ls</li><li>只想搜索源路径 -s whereis -s gcc</li></ul><p>非常好用的方法！！！一定得记住！！！</p><h2 id="which-找出将要运行的命令的版本"><a href="#which-找出将要运行的命令的版本" class="headerlink" title="which 找出将要运行的命令的版本"></a>which 找出将要运行的命令的版本</h2><p>比如gcc有多个版本，当前使用的哪个版本会先运行，即whereis -b gcc时发现有多个可执行文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which gcc</span><br></pre></td></tr></table></figure></p><p>同时也是快速判断系统是否有改特定命令的方法。</p><h2 id="type-揭示shell是如何解释命令"><a href="#type-揭示shell是如何解释命令" class="headerlink" title="type 揭示shell是如何解释命令"></a>type 揭示shell是如何解释命令</h2><p>不是常用命令，但如果想知道为什么命令没有按照预期的方式执行操作，type可以帮助你了解到问题所在。</p><h2 id="连续运行多个命令"><a href="#连续运行多个命令" class="headerlink" title="; 连续运行多个命令"></a>; 连续运行多个命令</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd a ;cd ..</span><br></pre></td></tr></table></figure><p>又回到了原目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3;</span><br><span class="line">``` </span><br><span class="line">会等待延迟3秒钟。</span><br><span class="line"></span><br><span class="line">## &amp;&amp; 仅在前面的命令成功运行时才运行下一条命令</span><br></pre></td></tr></table></figure><p>$ cd a &amp;&amp; cd ..<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最好还是用&amp;&amp;，这要处理更加安全。</span><br><span class="line"></span><br><span class="line">## || 仅在前面的命令运行失败时，才运行下一条命令</span><br><span class="line"></span><br><span class="line">## $() 将一条命令的输出插入另一条命令</span><br></pre></td></tr></table></figure></p><p>$ date “+%Y-%m-%d”</p><blockquote><blockquote><p>2019-9-10<br>$ mkdir $(date “+%Y-%m-%d”)<br>2019-9-10/ #创建了日期命名的目录<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个是极为强大的功能，无处不在。</span><br><span class="line"></span><br><span class="line">## | 将一条命令的输出用作另外一条命令的输入</span><br><span class="line">```linux</span><br><span class="line">$ ps ux | grep firefox</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><h2 id="gt-将命令的输出重定向到文件"><a href="#gt-将命令的输出重定向到文件" class="headerlink" title="&gt; 将命令的输出重定向到文件"></a>&gt; 将命令的输出重定向到文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l abc/ &gt; a.txt</span><br><span class="line">$ cat a.txt</span><br><span class="line"># abc目录下的文件</span><br></pre></td></tr></table></figure><p>若文件a.txt不存在则会被创建，已存在则会被完全覆盖。所以使用重定向要十分谨慎。</p><h2 id="gt-gt-将命令的输出追加到文件中"><a href="#gt-gt-将命令的输出追加到文件中" class="headerlink" title="&gt;&gt; 将命令的输出追加到文件中"></a>&gt;&gt; 将命令的输出追加到文件中</h2><p>如果文件不存在，会创建新的文件；<br>但是，如果使用 &gt;&gt; 代替 &gt;，就会把输出追加到指定文件按的结尾。</p><p><strong>如果无意间输入 &gt; ，就不是追加了，而是覆盖了。</strong></p><h2 id="lt-将文件用作命令的输入"><a href="#lt-将文件用作命令的输入" class="headerlink" title="&lt; 将文件用作命令的输入"></a>&lt; 将文件用作命令的输入</h2><p>不常用，举例<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tr &apos;A-Z&apos; &apos;a-z&apos; &lt; commands.txt</span><br></pre></td></tr></table></figure></p><p>将txt用于输入，tr用来进行处理。</p><h2 id="结合使用输入和输出重定向"><a href="#结合使用输入和输出重定向" class="headerlink" title="结合使用输入和输出重定向"></a>结合使用输入和输出重定向</h2><p>[command] &lt; [file] &gt;[output]<br>了解一下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tr &apos;A-Z&apos; &apos;a-z&apos; &lt; commands.txt &gt; a.txt</span><br></pre></td></tr></table></figure></p><p>tr处理后的commands.txt的内容输出到a.txt</p><h2 id="tee-将输出同时发送到文件和stdout"><a href="#tee-将输出同时发送到文件和stdout" class="headerlink" title="tee 将输出同时发送到文件和stdout"></a>tee 将输出同时发送到文件和stdout</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l a/ | tee b.txt</span><br></pre></td></tr></table></figure><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><ol><li>查看文件</li><li>拼接文件至标准输出设备 cat file1 file2</li><li>拼接文件到其他文件 cat file1 file2 &gt; file3</li><li>追加到其他文件上 cat file1 &gt;&gt; file2</li><li>拼接文件并显示行号 cat -n file1 file2</li></ol><h2 id="less-逐屏查看文本文件"><a href="#less-逐屏查看文本文件" class="headerlink" title="less 逐屏查看文本文件"></a>less 逐屏查看文本文件</h2><ol><li>PageDn、e或空格键 前进一页</li><li>PageUp或b 后退一页</li><li>上下箭头对应 前进和后退一行</li><li>Q 退出</li></ol><h2 id="head-查看文件前十行"><a href="#head-查看文件前十行" class="headerlink" title="head 查看文件前十行"></a>head 查看文件前十行</h2><ol><li>head file1 file2也可以查看多个文件的前十行内容。</li><li>head -n 5 file1 只看前五行</li></ol><h2 id="tail-查看最后十行"><a href="#tail-查看最后十行" class="headerlink" title="tail 查看最后十行"></a>tail 查看最后十行</h2><p>大部分与head相同</p><ol><li>tail -f 查看一个或多个文件中经常更新的最后几行内容。</li></ol><h2 id="wc-计算文件中的单词数，行数和字符数"><a href="#wc-计算文件中的单词数，行数和字符数" class="headerlink" title="wc 计算文件中的单词数，行数和字符数"></a>wc 计算文件中的单词数，行数和字符数</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc a.txt</span><br><span class="line">&gt;&gt; 192 11134 70923 a.txt</span><br></pre></td></tr></table></figure><p>按顺序给出了行数、单词数和字符数。</p><ol><li>-l -w -m 分别对应行数、单词数和字符数。</li></ol><p>更重要的是理解这是一个<strong>过滤器</strong>。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep JerkyJerks sever_access.log | wc -l</span><br><span class="line">&gt;&gt; 11542</span><br></pre></td></tr></table></figure></p><p>使用wc -l来计算这些网络黑客对计算机攻击了多少次。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep [/]usr/bin.cronolog | wc -l</span><br><span class="line">&gt;&gt; 83</span><br></pre></td></tr></table></figure></p><p>多少个cronolog实例征在运行。</p><h2 id="nl对文件中的行进行编号"><a href="#nl对文件中的行进行编号" class="headerlink" title="nl对文件中的行进行编号"></a>nl对文件中的行进行编号</h2><ol><li>nl a.txt 不给空行编号</li><li>nl -b a a.txt 也会给空行进行编号</li></ol><h2 id="cut-选择分隔文件中的整列数据"><a href="#cut-选择分隔文件中的整列数据" class="headerlink" title="cut 选择分隔文件中的整列数据"></a>cut 选择分隔文件中的整列数据</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -f 1,3 a.txt</span><br></pre></td></tr></table></figure><p>提取数据的第一列和第三列<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo wu.images.ccc.com | cut -d &apos;.&apos; -f 2-4</span><br><span class="line">&gt;&gt; images.ccc.com</span><br></pre></td></tr></table></figure></p><h2 id="sort-排序文件中的内容"><a href="#sort-排序文件中的内容" class="headerlink" title="sort 排序文件中的内容"></a>sort 排序文件中的内容</h2><h2 id="uniq-删除文件中重复的行"><a href="#uniq-删除文件中重复的行" class="headerlink" title="uniq 删除文件中重复的行"></a>uniq 删除文件中重复的行</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history | awl &apos;&#123;print $2&#125;&apos;| uniq</span><br></pre></td></tr></table></figure><p>删除重复的命令</p><h2 id="tr-使用其他字符替换选择的字符"><a href="#tr-使用其他字符替换选择的字符" class="headerlink" title="tr 使用其他字符替换选择的字符"></a>tr 使用其他字符替换选择的字符</h2><ol><li>tr -s 使用单个实例替换重复的字符</li><li>tr -d 删除匹配的字符</li></ol><h2 id="sed-转变文件中的文本"><a href="#sed-转变文件中的文本" class="headerlink" title="sed 转变文件中的文本"></a>sed 转变文件中的文本</h2><p>搭配正则表达式，功能强大，stream editor的简写</p><h2 id="awk-打印文件中的特定字段"><a href="#awk-打印文件中的特定字段" class="headerlink" title="awk 打印文件中的特定字段"></a>awk 打印文件中的特定字段</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h | awk &apos;NR&gt;1 &#123;print $6 &quot;has&quot; $4 &quot; of &quot; $2 &quot;left&#125;&apos;</span><br></pre></td></tr></table></figure><p>df -h可以显示计算机上文件系统的磁盘使用情况，NR&gt;1告诉awk跳过第一行。</p><h2 id="su-username-切换用户"><a href="#su-username-切换用户" class="headerlink" title="su username 切换用户"></a>su username 切换用户</h2><h2 id="su-成为root用户"><a href="#su-成为root用户" class="headerlink" title="su 成为root用户"></a>su 成为root用户</h2><p>whoami可以查看当前用户名称</p><h2 id="su-成为root用户并使用其环境变量"><a href="#su-成为root用户并使用其环境变量" class="headerlink" title="su - 成为root用户并使用其环境变量"></a>su - 成为root用户并使用其环境变量</h2><p>只是用su，可以拥有root用户的权限，但是在后台，非root用户环境变量仍然在起作用。所以需要使用su -</p><h2 id="chgrp-更改用户或目录所属用户组"><a href="#chgrp-更改用户或目录所属用户组" class="headerlink" title="chgrp 更改用户或目录所属用户组"></a>chgrp 更改用户或目录所属用户组</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chgrp admins a.sh</span><br></pre></td></tr></table></figure><p>使用 cat/etc/group 查看用户组的情况。</p><ol><li>-R 递归更改目录所属的用户组</li></ol><h2 id="chown-更改文件和目录的拥有者"><a href="#chown-更改文件和目录的拥有者" class="headerlink" title="chown 更改文件和目录的拥有者"></a>chown 更改文件和目录的拥有者</h2><p>只有root用户，或使用sudo拥有root身份的用户，才可以更改文件的拥有者。</p><ol><li>-R 同样可以递归</li></ol><h2 id="chown-owner-group-同时更改文件和目录的拥有者和用户组"><a href="#chown-owner-group-同时更改文件和目录的拥有者和用户组" class="headerlink" title="chown owner:group  同时更改文件和目录的拥有者和用户组"></a>chown owner:group  同时更改文件和目录的拥有者和用户组</h2><p>root用户可以一直能够对任何文件或目录进行任意操作</p><h2 id="chmod-修改文件和目录的权限"><a href="#chmod-修改文件和目录的权限" class="headerlink" title="chmod 修改文件和目录的权限"></a>chmod 修改文件和目录的权限</h2><ol><li>chmod [ugo][+-=][rwx] </li><li>chmod a[+-=][rwx]影响所有用户组</li><li>-R 递归地修改全年</li></ol><h2 id="suid-设置和清除"><a href="#suid-设置和清除" class="headerlink" title="suid 设置和清除"></a>suid 设置和清除</h2><ol><li>chmod u[+-]s 设置和清除，用户就可以使用拥有者的权限执行这个文件。</li></ol><h2 id="zip-压缩文件"><a href="#zip-压缩文件" class="headerlink" title="zip 压缩文件"></a>zip 压缩文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip 压缩后的文件名.zip 需要压缩的文件</span><br></pre></td></tr></table></figure><ol><li><p>zip -[0-9]，-9获得的压缩率最大</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -9 mo.zip *.txt</span><br></pre></td></tr></table></figure></li><li><p>-P和-e 可以用密码来保护压缩的zip文档。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zip -P 123 mo.zip *.txt</span><br><span class="line">$ zip -e  mo.zip *.txt</span><br></pre></td></tr></table></figure></li></ol><p>-e 密码不可见，不会存在shell事件的历史记录之中。</p><h2 id="unzip解压缩文件"><a href="#unzip解压缩文件" class="headerlink" title="unzip解压缩文件"></a>unzip解压缩文件</h2><ol><li>unzip -t 测试将要解压缩的文件。因为有时候zip压缩文档会损毁，最好在解压缩之前，都进行一次测试。</li></ol><h2 id="gzip-归档和压缩文件"><a href="#gzip-归档和压缩文件" class="headerlink" title="gzip 归档和压缩文件"></a>gzip 归档和压缩文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gzip a.txt</span><br><span class="line">&gt;&gt; a.txt.gz #原来的a.txt不存在了</span><br></pre></td></tr></table></figure><p>如果想让gzip保留原始文件，需要使用-c，且要搭配重定向。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gzip -c a.txt &gt; a.txt.gz</span><br></pre></td></tr></table></figure></p><p>现在既有原始文件，也有压缩文件。</p><ol><li>-r 递归</li><li>也可以用-[0-9] 指定压缩率<h2 id="gunzip-解压缩gzip压缩的文件"><a href="#gunzip-解压缩gzip压缩的文件" class="headerlink" title="gunzip 解压缩gzip压缩的文件"></a>gunzip 解压缩gzip压缩的文件</h2>操作和gzip相同，如果要保留.gz文件，也需要用上述的重定向和-c。<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gunzip -c a.txt.gz &gt; a.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="bzip2-压缩"><a href="#bzip2-压缩" class="headerlink" title="bzip2 压缩"></a>bzip2 压缩</h2><p>和gzip几乎一样，但保留原始文件，使用-k，且不用重定向<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -k a.txt</span><br></pre></td></tr></table></figure></p><h2 id="bunzip2-解压缩bzip2压缩的文件"><a href="#bunzip2-解压缩bzip2压缩的文件" class="headerlink" title="bunzip2 解压缩bzip2压缩的文件"></a>bunzip2 解压缩bzip2压缩的文件</h2><ol><li>-t 最好解压缩前测试一下</li></ol><h2 id="tar-cf-归档文件"><a href="#tar-cf-归档文件" class="headerlink" title="tar -cf 归档文件"></a>tar -cf 归档文件</h2><p>tar不执行压缩 必须接着-cf，-c告诉tar命令正在创建原始码，-f则用于为原始码指定文件名<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf moby.tar *.txt</span><br><span class="line"># 压缩所有.txt文件</span><br></pre></td></tr></table></figure></p><p>也可以用于压缩整个目录结构，使用该命令可以批量归档大量的文件和子目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf moby.tar abc/</span><br></pre></td></tr></table></figure><p>归档了abc目录</p><h2 id="tar-pzcvf结合tar和gzip归档和压缩文件"><a href="#tar-pzcvf结合tar和gzip归档和压缩文件" class="headerlink" title="tar -pzcvf结合tar和gzip归档和压缩文件"></a>tar -pzcvf结合tar和gzip归档和压缩文件</h2><ol><li>-p 确保保留权限 -z 能够在tar中调用gzip -v 运行时告知你执行的操作<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -pzcvf moby.tar.gz abc/</span><br></pre></td></tr></table></figure></li></ol><p>最后的扩展名是.tar.gz，也可以使用.tgz或是tar.gzip</p><ol start="2"><li>当然也可以使用tar结合bzip2<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -pjcvf moby.tar.bz2 abc/</span><br></pre></td></tr></table></figure></li></ol><p>注意 -j 选项。</p><h2 id="tar-zvtf-测试将要解开和解压缩的文件"><a href="#tar-zvtf-测试将要解开和解压缩的文件" class="headerlink" title="tar -zvtf 测试将要解开和解压缩的文件"></a>tar -zvtf 测试将要解开和解压缩的文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zvtf moby.tar.gz</span><br></pre></td></tr></table></figure><ol><li>-t 测试</li><li>-f 必须是放在最后一个选项</li><li>tar -jvtf moby.tar.gz 解压缩bzip2压缩的文件</li></ol><h2 id="grep-在文本文件中搜索匹配的模式"><a href="#grep-在文本文件中搜索匹配的模式" class="headerlink" title="grep 在文本文件中搜索匹配的模式"></a>grep 在文本文件中搜索匹配的模式</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep trian *</span><br><span class="line">$ grep &apos;hello wolrd!&apos; * #遇到有空格的字符串，用单引号，不要用双引号</span><br></pre></td></tr></table></figure><ol><li>-R 递归地搜索文件中的文本。</li><li>-i 忽略大小写</li><li>-w 只搜索完整单词</li><li>-n 显示搜索单词在文件中的对应行号</li><li>-v 显示文件中没有包含匹配单词的行</li><li>-l 列出包含搜索词的文件名</li><li>-c 列出文件中单词的出现次数</li></ol><h2 id="find-搜索文件"><a href="#find-搜索文件" class="headerlink" title="find 搜索文件"></a>find 搜索文件</h2><ol><li><p>-name</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name shaggs</span><br><span class="line">$ find . -name &quot;*shaggs*&quot; #最好搭配一些通配符</span><br></pre></td></tr></table></figure></li><li><p>-user 根据拥有者</p></li><li>-group 根据拥有组</li><li>-size 根据文件大小</li><li>-type 根据文件类型</li><li>-a 组合选项时 均为ture (And) </li><li>-o 任一表达式为 （OR）</li></ol><h2 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history 查看历史命令"></a>history 查看历史命令</h2><h2 id="再次运行最近输入的命令"><a href="#再次运行最近输入的命令" class="headerlink" title="!! 再次运行最近输入的命令"></a>!! 再次运行最近输入的命令</h2><h2 id="！使用数字再次运行之前的命令"><a href="#！使用数字再次运行之前的命令" class="headerlink" title="！使用数字再次运行之前的命令"></a>！使用数字再次运行之前的命令</h2><p>history可以查到命令的编号，!499。</p><h2 id="使用字符串再次运行之前的命令"><a href="#使用字符串再次运行之前的命令" class="headerlink" title="使用字符串再次运行之前的命令"></a>使用字符串再次运行之前的命令</h2><p>!cat /ect，部分信息就行</p><h2 id="搜索之前输入的命令并运行"><a href="#搜索之前输入的命令并运行" class="headerlink" title="搜索之前输入的命令并运行"></a>搜索之前输入的命令并运行</h2><ol><li>按Crtl+r键,r代表反向搜索和匹配</li></ol><h2 id="uptime-显示计算机的持续运行时间"><a href="#uptime-显示计算机的持续运行时间" class="headerlink" title="uptime 显示计算机的持续运行时间"></a>uptime 显示计算机的持续运行时间</h2><p>有趣的命令</p><h2 id="ps-aux查看正在运行的所有进程"><a href="#ps-aux查看正在运行的所有进程" class="headerlink" title="ps aux查看正在运行的所有进程"></a>ps aux查看正在运行的所有进程</h2><ol><li>a 表示所有用户</li><li>u 以面向用户的格式显示，或显示拥有每个进程的用户</li><li>x 没有控制终端设备或终端屏幕的进程，“显示每个进程”的另外一个说法</li><li>-w 默认情况下输出会在终端窗口的边缘被切断，为了完整地查看输出行，可添加 -w 换行</li></ol><p>ps命令提供很多信息，包括拥有进程地用户、唯一地进程ID编号（PID，用于标识进程）、进程正在使用的CPU百分比（%CPU）和内存百分比（%MEM）、已经运行了多长时间、进程的当前状态STAT以及进程自身的名称。</p><ul><li>R 正在运行</li><li>S 正在休眠</li><li>T 已停止</li><li>Z 僵尸进程 意味着该进程一直处于挂起状态，不能停止。只有重启计算机才能完全关闭这个程序。</li></ul><h2 id="ps-axjf-查看进程树"><a href="#ps-axjf-查看进程树" class="headerlink" title="ps axjf 查看进程树"></a>ps axjf 查看进程树</h2><h2 id="ps-U-username-查看特定用户拥有的进程"><a href="#ps-U-username-查看特定用户拥有的进程" class="headerlink" title="ps U username 查看特定用户拥有的进程"></a>ps U username 查看特定用户拥有的进程</h2><h2 id="kill-终止正在运行的程序"><a href="#kill-终止正在运行的程序" class="headerlink" title="kill 终止正在运行的程序"></a>kill 终止正在运行的程序</h2><ol><li>-1 控制程序已停止运行，关闭进程</li><li>-15 正常终止进程，清除将要失控的进程和文件</li><li>-9 停止任何正在进行的处理工作，立即关闭进程<br>通常，先试试-15（实际上，这是默认值），没有响应，则使用-9</li></ol><h2 id="top-查看运行中进程的动态更新列表"><a href="#top-查看运行中进程的动态更新列表" class="headerlink" title="top 查看运行中进程的动态更新列表"></a>top 查看运行中进程的动态更新列表</h2><h2 id="df-显示文件系统的磁盘使用情况"><a href="#df-显示文件系统的磁盘使用情况" class="headerlink" title="df 显示文件系统的磁盘使用情况"></a>df 显示文件系统的磁盘使用情况</h2><h2 id="du-报告目录使用的文件空间"><a href="#du-报告目录使用的文件空间" class="headerlink" title="du 报告目录使用的文件空间"></a>du 报告目录使用的文件空间</h2><ol><li>-hs 只报告占用空间的总量</li></ol><h2 id="rpm-安装软件包"><a href="#rpm-安装软件包" class="headerlink" title="rpm 安装软件包"></a>rpm 安装软件包</h2><p>用于安装以.rpm为后缀的软件安装程序。</p><ol><li>-ihv [package]  i 安装软件包，h 显示hash标记，以便观察安装进度，v 显示命令执行的操作</li><li>-Uhv [package] 更好的选择 U 可以进行安装和升级。如果已经存在软件包，会自动更新。</li><li>-e [package] 删除软件包</li></ol><h2 id="yum-安装软件包及其依赖程序-RPM"><a href="#yum-安装软件包及其依赖程序-RPM" class="headerlink" title="yum 安装软件包及其依赖程序(RPM)"></a>yum 安装软件包及其依赖程序(RPM)</h2><p>yum命令通过充当RPM的包装器来安装、升级和卸载软件包。</p><ol><li>install </li><li>remove 删除软件包及其依赖程序</li><li>update 更新升级</li><li>list avaliable 查看可供下载的软件包<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list avaliable | grep wireshark</span><br></pre></td></tr></table></figure></li></ol><h2 id="dpkg-安装软件包-DEB"><a href="#dpkg-安装软件包-DEB" class="headerlink" title="dpkg 安装软件包(DEB)"></a>dpkg 安装软件包(DEB)</h2><ol><li>-i [package] 就是这么简单</li><li>-r [package] 删除</li></ol><h2 id="apt-get-install-安装软件包及其依赖程序-DEB"><a href="#apt-get-install-安装软件包及其依赖程序-DEB" class="headerlink" title="apt-get install 安装软件包及其依赖程序(DEB)"></a>apt-get install 安装软件包及其依赖程序(DEB)</h2><ol><li>apt-get update 该命令会从APT服务器（称为仓库）下载当前的软件包列表，在APT配置文件（/etc/apt/sources.list）中列出了这些仓库（可以使用cat查看）。</li><li>apt-get remove [package] 删除软件包及其依赖程序（DEB)</li><li>–purge 卸载软件包不会删除这个包的所有数据，被删除软件的配置文件还会残留在计算机中。如果想要删除所有数据，使用 –purge，表示与这个包相关的配置文件包也要被删除。</li><li>apt-cache search [package] 查找可供下载的软件包</li><li>apt-get clean 清楚不再需要的安装包</li></ol><h2 id="ping-验证计算机是否正在运行和能否接受请求"><a href="#ping-验证计算机是否正在运行和能否接受请求" class="headerlink" title="ping 验证计算机是否正在运行和能否接受请求"></a>ping 验证计算机是否正在运行和能否接受请求</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping ww.baidu.com</span><br></pre></td></tr></table></figure><p>直到按下Ctrl + C组合键，ping命令才会停止。</p><h2 id="ssh-安全登录到另外一台服务器"><a href="#ssh-安全登录到另外一台服务器" class="headerlink" title="ssh 安全登录到另外一台服务器"></a>ssh 安全登录到另外一台服务器</h2><h2 id="sftp-在计算机之间安全地传输文件"><a href="#sftp-在计算机之间安全地传输文件" class="headerlink" title="sftp 在计算机之间安全地传输文件"></a>sftp 在计算机之间安全地传输文件</h2><h2 id="scp-在主机之间安全地复制文件"><a href="#scp-在主机之间安全地复制文件" class="headerlink" title="scp 在主机之间安全地复制文件"></a>scp 在主机之间安全地复制文件</h2><h2 id="wget-非交互式下载文件或非交互式下载整个网站"><a href="#wget-非交互式下载文件或非交互式下载整个网站" class="headerlink" title="wget 非交互式下载文件或非交互式下载整个网站"></a>wget 非交互式下载文件或非交互式下载整个网站</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纯个人向认为比较重要的，需要熟记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作日常" scheme="http://www.cygao.xyz/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="linux" scheme="http://www.cygao.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python实现剑指offer1-31题</title>
    <link href="http://www.cygao.xyz/2019/07/25/jian%20offer/"/>
    <id>http://www.cygao.xyz/2019/07/25/jian offer/</id>
    <published>2019-07-25T05:23:45.000Z</published>
    <updated>2019-09-02T02:05:21.970Z</updated>
    
    <content type="html"><![CDATA[<p>详细地分析剑指offer1-31题的解题思路，代码及代码注释。<br><a id="more"></a></p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</strong></p><p>对列的添加       insert              append </p><p>队列的取值      列表[-1]            列表[0]</p><p>队列的删除       pop()            pop(0)</p><hr><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</strong></p><p>只允许在栈的栈顶来操作。</p><p>添加元素用append(push)，称作是进栈，入栈或者压栈</p><p>取值列表[-1]，因为它只能从栈顶来取值，相当于取列表的最后一个值，所以用索引-1.</p><p>删除元素pop()从后端开始删除。称作是出栈或者退栈。</p><hr><h2 id="1-两个栈实现一个队列：-本题考点-队列-栈"><a href="#1-两个栈实现一个队列：-本题考点-队列-栈" class="headerlink" title="1. 两个栈实现一个队列：[^本题考点 队列 栈]"></a>1. 两个栈实现一个队列：[^本题考点 队列 栈]</h2><p><strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</strong></p><p>……解析：</p><p>定义一个类，首先这个类要具备两个属性，一个是压栈，一个是出栈。</p><p>因为要两个栈来实现一个队列：进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p>那么如何用：两个栈实现一个队列？</p><p>栈： 先进后出</p><p>队列：先进先出</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianggezhan.png" alt></p><h4 id="如图所示："><a href="#如图所示：" class="headerlink" title="如图所示："></a>如图所示：</h4><p>队列从一头添加数据，从一头删除数据。</p><p>所以我们需要让两个栈</p><p>一个栈实现添加数据 </p><p>​    即：<code>self.acceptStack=[]</code>它拥有一个<code>push</code>的方法，用来作为队列的一端的添加数据 功能 用append来实现</p><p>​        <code>self.acceptStack.append(node)</code></p><p>另一个栈实现删除数据：</p><p>​    即：<code>self.outputStack = []</code>它拥有pop 的方法，用来作为队列的另一端的删除数据的功能 用pop 来实现</p><p>​    但是我们要实现的是队列的先进先出，也就意味着 如果说我们添加数据的栈中添加了一个数据，那么我们另一个删除数据的栈中，也要相应的删除这个数据，所以说这两个栈中的数据的顺序是相反的。</p><p>以上的需求我们通过，删除<code>acceptStack</code>栈中的数据，在<code>outputStack</code>中添加这个数据，那么先在<code>acceptStack</code>中删除的数据，就会进入到<code>outputStack</code>的栈底，后在<code>acceptStack</code>中删除的数据，会后进入<code>outputStack</code>，那么它就会先出来。</p><p>那么两个栈，这样来合作，就会实现队列的先进先出，如图：1 是先进的（栈1） 那么1 就会先出来（栈2）。</p><p>进而实现了 题目的需求。</p><p>在pop 的方法中，如果说 <code>self.outputStack</code>是空 没有数据，那么 就给它 while 循环我们的 作为添加数据的栈 </p><p><code>acceptStack</code>，删除这个栈中的内容，它会弹出，然后把它添加到 <code>栈2 outputStack</code>  中，它就会有数据，有数据的话就返回 （如果 调用了 删除 数据的这个方法的话）。如果说 做了循环，我们的<code>栈2 outputStack</code> 中还没有数据，就明 <code>acceptStack</code>中，没有数据压入，也就说明这个 队列 没有添加数据，也就不会有删除的数据，所以返回一个None。</p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#添加数据栈</span></span><br><span class="line">        self.acceptStack=[]</span><br><span class="line">        <span class="hljs-comment">#删除数据栈</span></span><br><span class="line">        self.outputStack = []</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#向添加数据的栈中添加数据</span></span><br><span class="line">        self.acceptStack.append(node)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#判断删除数据的栈中是否有数据，没有的话，就添加数据，添加数据时，要添加栈1 中删除的数据</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.outputStack:</span><br><span class="line">            <span class="hljs-keyword">while</span> self.acceptStack:</span><br><span class="line">            self.outputStack.append(self.acceptStack.pop())</span><br><span class="line">        <span class="hljs-comment">#如果有数据的话，就返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.outputStack:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.outputStack.pop()</span><br><span class="line">        <span class="hljs-comment">#如果没有数据，说明没有数据添加进去，也就不需要删除数据，所以返回none</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><h5 id="分析查找：首先快速的查找方法-有二分查找法，那么什么是二分查找法？"><a href="#分析查找：首先快速的查找方法-有二分查找法，那么什么是二分查找法？" class="headerlink" title="分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？"></a><strong>分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？</strong></h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找法什么情况下用。有序的数组中。首先 肯定是在有序的 数组中的！！！！！</span><br></pre></td></tr></table></figure><p>算法：二分法查找适用于数据量较大时，但是数据需要先排好顺序。主要思想是：（设查找的数组区间为array[low, high]）</p><p>（1）确定该区间的中间位置K（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：a.array[k]&gt;T 由数组的有序性可知array[k,k+1,……,high]&gt;T;故新的区间为array[low,……，K-1]b.array[k]&lt;T 类似上面查找区间为array[k+1,……，high]。每一次查找与中间值比较，可以确定是否查找成功，不成功当前查找区间将缩小一半，递归查找即可。</p><p>时间复杂度为:<code>O(log2n)</code>。</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)所以T(n)=O(log2n)</p><p>2.最好情况查找中间元素O(1)查找的元素即为中间元素（奇数长度数列的正中间，偶数长度数列的中间靠左的元素）</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ol><li>S(n)=n</li></ol><h5 id="二分法代码实现："><a href="#二分法代码实现：" class="headerlink" title="二分法代码实现："></a>二分法代码实现：</h5><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(array,target)</span>:</span></span><br><span class="line">    left= <span class="hljs-number">0</span></span><br><span class="line">    right= len(array)<span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">while</span> left &lt;= right :</span><br><span class="line">        <span class="hljs-comment">#除法没有移位的快</span></span><br><span class="line">        <span class="hljs-comment"># mid = (left + right)//2</span></span><br><span class="line">        <span class="hljs-comment"># 101 = 5 =&gt; 10 = 2</span></span><br><span class="line">        <span class="hljs-comment">#1100 = 12 =&gt; 110 = 6</span></span><br><span class="line">        <span class="hljs-comment">#一下用了 向右 移一位， 那么上面是解释，它就相当于 除以2 。</span></span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#如果中间的数等于我们要找的数，那么就返回。</span></span><br><span class="line">        <span class="hljs-keyword">if</span>  array[mid] == target:</span><br><span class="line">            <span class="hljs-keyword">return</span> mid</span><br><span class="line">        <span class="hljs-comment">#如果说中间的数 &lt; 目标的数，那么就说明，我们要找的数在右侧，所以左侧取值的索引需要改变为中间的索引+1；</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> array[mid]&lt; target:</span><br><span class="line">            left = mid + <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#如果说中间的数 &gt; 目标的数，那么就说明，我们要找的数在左侧，所以左侧取值的索引需要改变为中间的索引-1； 因为越往左索引值越小</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            right = mid<span class="hljs-number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><p>把数组内的数据一分为二，然后计算出中间数据的 索引值。</p><p>数组中 最左侧的  索引为 0  ；最右侧的索引为 len(array)-1，数组的长度 减 1 就是 最后一个数的索引。</p><p>先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，如果相等那么就返回，如果不相等，那么就继续判断。如果说我们找到的 array[mid] 小于  target 这个数; 那么 就说明 我们要查找的数在右侧的一半数据中，那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。如果说我们找到的 array[mid]  大于 target 这个数 ，那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。</p><p>以上为二分法的原理。</p><hr><h2 id="2-旋转数组的最小数字-本题考点-查找"><a href="#2-旋转数组的最小数字-本题考点-查找" class="headerlink" title="2. 旋转数组的最小数字 [^本题考点 查找]"></a>2. 旋转数组的最小数字 [^本题考点 查找]</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#最小值 一定比前面的要小</span></span><br><span class="line">        <span class="hljs-comment"># 二分法查找数据  找左右的方法是：</span></span><br><span class="line">        <span class="hljs-comment">#右边的值大于中值，就说明最小值在左边</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rotateArray:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        right = len(rotateArray) - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果说中间的数的上一个数 &gt; 中间数，那么就说明，我们要找的数就是这个中间的数，返回这个数。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> rotateArray[mid - <span class="hljs-number">1</span>] &gt; rotateArray[mid]:</span><br><span class="line">                <span class="hljs-keyword">return</span> rotateArray[mid]</span><br><span class="line">            <span class="hljs-comment">#如果说中间的数 &lt; 中间数的上一个数，那么就说明，我们要找的数在二分法的左侧，所以右侧取值的索引需要改变为中间的索引-1；因为越往左索引值越小</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                right = mid - <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#否则就说明，我们要找的数在二分法的右侧，所以左侧取值的索引需要改变为中间的索引+1；因为越往右索引值越小</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><hr><h5 id="什么叫做数组？"><a href="#什么叫做数组？" class="headerlink" title="什么叫做数组？"></a>什么叫做数组？</h5><p><em>所谓数组，是有序的元素序列。 [1]  若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。 [1]  这些无序排列的同类数据元素的集合称为数组。</em></p><p>例如：</p><p>int (32 位)      int         int         这三个就会组成一个数组，类型相同的变量。<br>a(0)             a(1)          a(2)</p><p>数组与python中的 列表比较相似， 用索引去查找。<br>数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。<br>数组还和元组比较像，元组是初始化后，长度指定了就不可以变。<br>但是元组在初始化时给的值，确定了以后就不可以变了。<br>所以可以理解为数组与list 列表很相似。</p><hr><h2 id="3-在二维数组中的查找-本题考点-查找"><a href="#3-在二维数组中的查找-本题考点-查找" class="headerlink" title="3.在二维数组中的查找[^本题考点 查找]"></a>3.在二维数组中的查找[^本题考点 <em>查找</em>]</h2><p><strong>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># array 二维列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Find</span><span class="hljs-params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># 1 2 3 4</span></span><br><span class="line">        <span class="hljs-comment"># 3 4 5 6</span></span><br><span class="line">        <span class="hljs-comment"># 4 6 8 10</span></span><br><span class="line">        <span class="hljs-comment"># 9 11 13 15</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度 o(n**n)</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># for i in range(len(array)):</span></span><br><span class="line">        <span class="hljs-comment">#     for j in range(len(array[i])):</span></span><br><span class="line">        <span class="hljs-comment">#         if target == array[i][j]:</span></span><br><span class="line">        <span class="hljs-comment">#             return True</span></span><br><span class="line">        <span class="hljs-comment"># return False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#时间复杂度</span></span><br><span class="line">        <span class="hljs-comment">#O（n)</span></span><br><span class="line">        <span class="hljs-comment">#这个二维数组的长度是多少，也就是说这个数组有几行；</span></span><br><span class="line">        row_count = len(array)</span><br><span class="line">        i = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列</span></span><br><span class="line">        column_count = len(array[<span class="hljs-number">0</span>])</span><br><span class="line">        <span class="hljs-comment">#给j 一个值，就是数组列数的值-1，即为j 的最大值。</span></span><br><span class="line">        j = len(array[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment">#循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。</span></span><br><span class="line">        <span class="hljs-comment">#我们要取到每行的最后一个数，即对应的那一列的第一个数，来与我们的目标数来对比，这个数是这一行的最大数，是这一列的最小数。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> i &lt; row_count <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#根据两个索引下标可以取到 对应的在数组中的值</span></span><br><span class="line">            value = array[i][j]</span><br><span class="line">            <span class="hljs-comment">#如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回就好。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> value == target:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-comment">#如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，给它减-1，找前一列的数做比较</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> target &lt; value:</span><br><span class="line">                j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果说取到的值 &lt; 我们的目标值。那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                i += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-包含min-函数的栈-本题考点-栈"><a href="#4-包含min-函数的栈-本题考点-栈" class="headerlink" title="4.包含min 函数的栈[^本题考点 栈]"></a>4.包含min 函数的栈[^本题考点 <em>栈</em>]</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</strong></p><p>原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：考虑两个栈的长度相同，添加一个，另一个栈也会删除一个</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment">#给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []</span><br><span class="line">    <span class="hljs-comment">#给栈中推进去数值，推进去元素node，添加函数</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="hljs-comment">#如果最小值列表里有值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue:</span><br><span class="line">            <span class="hljs-comment">#如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="hljs-comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.minValue[<span class="hljs-number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">             <span class="hljs-comment">#如果列表里面的最后一个值，小于node值，那么就说明node这个值大；那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                self.minValue.append(self.minValue[<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-comment">#如果最小值列表里面没有值，就在最小值列表里添加node</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">    <span class="hljs-comment">#给栈中做删除操作</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个</span></span><br><span class="line">        self.minValue.pop()</span><br><span class="line">        <span class="hljs-comment">#有值得话，就需要删除一个，删除做pop 操作；返回我们删除的那个数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="hljs-comment">#栈顶 </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]</span><br><span class="line">   <span class="hljs-comment">#取出最小值，那么就是我们minvalue 中的最后一个值为最小值</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.minValue[<span class="hljs-number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">#第二种方法：不考虑两个栈的长度必须要保持一致，那么在栈删除值的时候，判断一下删除的值，是不是与装最小值的栈里的最后一个最小值相同，如果相同就删掉，如果不同，就不删除。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue:</span><br><span class="line">            <span class="hljs-comment">#如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="hljs-comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.minValue[<span class="hljs-number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">             <span class="hljs-comment">#最后一个值不大于node这个值得话；不做操作，不需要把它两个做的长度一致</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#删除的时候，做个判断，它是不是与栈里面的最后一个值，与我们最小值栈里的最后一个值相等，那么就删除双方的这个值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack[<span class="hljs-number">-1</span>] == self.minValue[<span class="hljs-number">-1</span>]:</span><br><span class="line">            self.minValue.pop()</span><br><span class="line">            <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="hljs-comment">#如果不等的话，就只要删除栈 里最后一个值就可以</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.minValue[<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="5-替换空格-本题考点-字符串"><a href="#5-替换空格-本题考点-字符串" class="headerlink" title="5.替换空格[^本题考点 字符串]"></a>5.替换空格[^本题考点 <em>字符串</em>]</h2><p><strong>请实现一个函数，将一个字符串中的每个空格替换成<code>“%20”</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># s 源字符串</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">    <span class="hljs-comment">#第一种：python中自带的一个替换的函数</span></span><br><span class="line">        <span class="hljs-comment"># return s.replace(' ','%20')</span></span><br><span class="line">        <span class="hljs-comment">#第二种遍历来替换字符串中的空格</span></span><br><span class="line">        strlen = len(s)</span><br><span class="line">        <span class="hljs-comment">#借助第三方的列表来实现时间的节省。</span></span><br><span class="line">        aaa = []</span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(strlen):</span><br><span class="line">            <span class="hljs-comment">#如果是空格的话那就替换为%20.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">" "</span>:</span><br><span class="line">            <span class="hljs-comment">#if s[i] isspace:</span></span><br><span class="line">                aaa.append(<span class="hljs-string">"%"</span>)</span><br><span class="line">                aaa.append(<span class="hljs-string">"2"</span>)</span><br><span class="line">                aaa.append(<span class="hljs-string">"0"</span>)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                aaa.append(s[i])</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(aaa)</span><br></pre></td></tr></table></figure><hr><h2 id="6-斐波那契数列"><a href="#6-斐波那契数列" class="headerlink" title="6.斐波那契数列"></a>6.斐波那契数列</h2><p><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：下面是使用了for循环，</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># 如果是按照递归来写的话， 时间复杂度就是随着n的变化 增长率是 2^n</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-string">''' 递归实现</span></span><br><span class="line"><span class="hljs-string">        # n = 0 f(0) = 0</span></span><br><span class="line"><span class="hljs-string">        if n == 0:</span></span><br><span class="line"><span class="hljs-string">            return 0</span></span><br><span class="line"><span class="hljs-string">        # n = 1 f(1) = 1</span></span><br><span class="line"><span class="hljs-string">        if n == 1:</span></span><br><span class="line"><span class="hljs-string">            return 1</span></span><br><span class="line"><span class="hljs-string">        # if n &gt; 1  f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="hljs-string">        if n &gt; 1:</span></span><br><span class="line"><span class="hljs-string">            num = self.Fibonacci(n-1) + self.Fibonacci(n-2)</span></span><br><span class="line"><span class="hljs-string">            return num</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        return None</span></span><br><span class="line"><span class="hljs-string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># n = 0 f(0) = 0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># n = 1 f(1) = 1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        b = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># if n &gt; 1  f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="hljs-comment"># h = a + b</span></span><br><span class="line">        <span class="hljs-comment"># 当 n = 2 h = 0 + 1</span></span><br><span class="line">        ret = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#三个变量，互相转换 来实现</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>):</span><br><span class="line">            ret = a + b</span><br><span class="line">            b = a</span><br><span class="line">            a = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"><span class="hljs-comment">#第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n</span></span><br><span class="line"></span><br><span class="line"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#初始列表值 为 0 1 第三项为 0+1 = 1；</span></span><br><span class="line">         res = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</span><br><span class="line">         <span class="hljs-comment">#临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。</span></span><br><span class="line">         <span class="hljs-keyword">while</span> len(res) &lt;= n:</span><br><span class="line">                <span class="hljs-comment">#取出列表的最后两项，然后求和，并添加到列表中。</span></span><br><span class="line">             res.append(res[<span class="hljs-number">-1</span>] + res[<span class="hljs-number">-2</span>])</span><br><span class="line">         <span class="hljs-keyword">return</span> res[n]</span><br></pre></td></tr></table></figure><hr><h2 id="7-青蛙跳台阶"><a href="#7-青蛙跳台阶" class="headerlink" title="7.青蛙跳台阶"></a>7.青蛙跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/qinwa.png" alt></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 (1)</span></span><br><span class="line"><span class="hljs-string">2 (11,2)</span></span><br><span class="line"><span class="hljs-string">3 (12,21,111)</span></span><br><span class="line"><span class="hljs-string">4 (1111,22,112,121,211)</span></span><br><span class="line"><span class="hljs-string">5 (11111,221,212,122,1121,2111,1112,1211)</span></span><br><span class="line"><span class="hljs-string">6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(self, number)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第一种方法：</span></span><br><span class="line">         res = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span><br><span class="line">         <span class="hljs-keyword">while</span> len(res) &lt;= number:</span><br><span class="line">             res.append(res[<span class="hljs-number">-1</span>] + res[<span class="hljs-number">-2</span>])</span><br><span class="line">         <span class="hljs-keyword">return</span> res[number]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         a = <span class="hljs-number">1</span></span><br><span class="line">         b = <span class="hljs-number">1</span></span><br><span class="line">         <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,number):</span><br><span class="line">             a,b = b,a+b</span><br><span class="line">         <span class="hljs-keyword">return</span> a</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number ==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number == <span class="hljs-number">2</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span></span><br><span class="line">        ret = <span class="hljs-number">0</span></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        b = <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,number+<span class="hljs-number">1</span>):</span><br><span class="line">            ret = a+b</span><br><span class="line">            a = b</span><br><span class="line">            b = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h2 id="8-变态跳台阶"><a href="#8-变态跳台阶" class="headerlink" title="8.变态跳台阶"></a>8.变态跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 (1)</span></span><br><span class="line"><span class="hljs-string">2 (11,2)</span></span><br><span class="line"><span class="hljs-string">3 (111,21,3,12)</span></span><br><span class="line"><span class="hljs-string">4 (1111,22,13,31,211,112,121,4)</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">n  2^(n-1)</span></span><br><span class="line"><span class="hljs-string">f(n)  = f(n-1) + f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="hljs-string">f(n-1) = f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="hljs-string">f(n) = 2f(n-1)  n &gt; 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">f(1) = 1 n = 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(self, number)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#第一种方法：</span></span><br><span class="line">        <span class="hljs-comment"># return pow(2,number-1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第二种方法：</span></span><br><span class="line">        <span class="hljs-comment"># return 2 ** (number - 1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第三种方法：</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number ==<span class="hljs-number">1</span> :</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        ret = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,number+<span class="hljs-number">1</span>):</span><br><span class="line">            a,ret = ret,<span class="hljs-number">2</span>*ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h2 id="9-调整数组顺序使奇数位于偶数前面-本题知识点-数组"><a href="#9-调整数组顺序使奇数位于偶数前面-本题知识点-数组" class="headerlink" title="9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]"></a>9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 <em>数组</em>]</h2><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(self, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度是o(n)</span></span><br><span class="line">        <span class="hljs-comment">#空间复杂度o(n)</span></span><br><span class="line">        <span class="hljs-comment"># ret = []</span></span><br><span class="line">        <span class="hljs-comment"># for i in array:</span></span><br><span class="line">        <span class="hljs-comment">#     if i % 2 == 1:</span></span><br><span class="line">        <span class="hljs-comment">#         ret.append(i)</span></span><br><span class="line">        <span class="hljs-comment"># for i in array:</span></span><br><span class="line">        <span class="hljs-comment">#     if i % 2 == 0:</span></span><br><span class="line">        <span class="hljs-comment">#         ret.append(i)</span></span><br><span class="line">        <span class="hljs-comment"># return ret</span></span><br><span class="line"><span class="hljs-comment">#用了冒泡排序的原理，判断奇偶数，如果一个是偶数而且下一个是奇数，那么两个就互换位置。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(array) - i - <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> array[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> array[j + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">                    array[j], array[j + <span class="hljs-number">1</span>] = array[j + <span class="hljs-number">1</span>], array[j]</span><br><span class="line">        <span class="hljs-keyword">return</span> array</span><br></pre></td></tr></table></figure><hr><h3 id="知识点：冒泡排序法"><a href="#知识点：冒泡排序法" class="headerlink" title="知识点：冒泡排序法"></a>知识点：冒泡排序法</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(array)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">#一共 需要 n 次 的循环，每一个都要找到没排好序的最大值。</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="hljs-comment">#将没有排好序的数组 找最大值，并一直将最大值换到最顶端。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(array)-i<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-comment">#判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> array[j] &gt; array[j+<span class="hljs-number">1</span>]:</span><br><span class="line">                array[j],array[j+<span class="hljs-number">1</span>] = array[j+<span class="hljs-number">1</span>],array[j]</span><br><span class="line">    <span class="hljs-keyword">return</span> array</span><br></pre></td></tr></table></figure><hr><h2 id="10-栈的压入，弹出序列-本题考点-栈"><a href="#10-栈的压入，弹出序列-本题考点-栈" class="headerlink" title="10.栈的压入，弹出序列  [^本题考点 栈]"></a>10.栈的压入，弹出序列  [^本题考点 <em>栈</em>]</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先要先有一个栈，列表</span></span><br><span class="line">        <span class="hljs-comment">#按照 pushV 的方式去压入栈，</span></span><br><span class="line">        <span class="hljs-comment"># 弹出的时候是需要循环判断是否需要弹出</span></span><br><span class="line">        <span class="hljs-comment">#判断是否需要弹出的时机，刚刚压入过后就判断</span></span><br><span class="line">        <span class="hljs-comment">#判断需要弹出的情况的条件，压入栈的顶部和弹出栈的顶部数据相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#先判断pushV 这个栈里是否为空，如果是空的话返回none，或者说这两个序列的长度不相同。那也返回none。</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pushV == [] <span class="hljs-keyword">or</span> len(pushV ) != len(popV):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"><span class="hljs-comment">#首先有个栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="hljs-comment">#定义一个变量，它作为弹出序列的索引存在。</span></span><br><span class="line">        index = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#遍历 pushV 的这个列表里的元素，并把它每个都添加进stack 这个列表中</span></span><br><span class="line">        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> pushV:</span><br><span class="line">            stack.append(item)</span><br><span class="line">            <span class="hljs-comment">#做判断 1，stack 里有元素 并且 stack里的最后一个元素 等于 popV 这个序列里 第一个元素，那么就进去这个循环，然后把stack里的这个元素删掉，这样下次还会添加新的元素，然后再和 popV 里的下一个元素 做判断，所以这个时候 index  这个索引值就要发生变化了，这个时候比较的是 它的下一个值。往右移动一位。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>] == popV[index]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                index += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        if stack == []:</span></span><br><span class="line"><span class="hljs-string">            return True</span></span><br><span class="line"><span class="hljs-string">        else:</span></span><br><span class="line"><span class="hljs-string">            return False</span></span><br><span class="line"><span class="hljs-string">            </span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-comment">#最后 直到 把 pushV 里的元素都遍历完，然后stack内的元素都比较完，并都删除完，就返回True，如果说 它不为空：说明 pushV 里有的元素 是popV 中所没有的，这个时候就说明他们不相等，那么这个情况，就需要返回 False。</span></span><br><span class="line">        <span class="hljs-comment">#以下代码与以上代码 共同实现的相同的功能，但是下面的代码相对来说等 “装B” 一点。节省代码空间。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> stack == [] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><hr><h4 id="知识点链表："><a href="#知识点链表：" class="headerlink" title="知识点链表："></a><code>知识点</code>链表：</h4><p>链表是一种物理<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/8727749" target="_blank" rel="noopener">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782" target="_blank" rel="noopener">存储结构</a>，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313" target="_blank" rel="noopener">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>域。 相比于<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081" target="_blank" rel="noopener">线性表</a><a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/9845234" target="_blank" rel="noopener">顺序结构</a>，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiao.png" alt></p><p>数组 就是连续的 同一个类型的 元素，而且必须是固定的长度。</p><p>如果我们想要非固定的长度来存储数据。这个时候就出现了链表。</p><hr><h2 id="11-从栈尾到栈头打印链表-本题知识点-链表"><a href="#11-从栈尾到栈头打印链表-本题知识点-链表" class="headerlink" title="11. 从栈尾到栈头打印链表 [^本题知识点 链表]"></a>11. 从栈尾到栈头打印链表 [^本题知识点 <em>链表</em>]</h2><p><strong>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># pointer 指针 temporary临时数据;node 结点</span></span><br><span class="line">        <span class="hljs-comment">#给一个 arraylist 空列表，然后向这个里面压入数据，来输出 这个链表值 的一个从尾到头 的顺序值。</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="hljs-comment">#把 listNode 这个链表 传给一个 变量</span></span><br><span class="line">        pTemp = listNode</span><br><span class="line">        <span class="hljs-comment">#当这个变量 存在时 有值时：</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pTemp:</span><br><span class="line">            <span class="hljs-comment">#使用 insert 的原因是：insert 可以在指定位置之前插入元素，列表.insert(索引，值)</span></span><br><span class="line">            <span class="hljs-comment">#在空列表中起始位置，插入 pTemp的第一个值，然后 给pTemp 赋值 为 pTemp.next （下一个值） </span></span><br><span class="line">            ret.insert(<span class="hljs-number">0</span>, pTemp.val)</span><br><span class="line">            <span class="hljs-comment">#更改 指针，使指针指向下一个 元素</span></span><br><span class="line">            pTemp = pTemp.next</span><br><span class="line"><span class="hljs-comment">#最后返回我们 这个 插入值的 列表 </span></span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/congtou.png" alt></p><p>如图所示：打印出 3 2 1 即为我们的目标。</p><hr><h2 id="12-链表中的倒数第k个结点-本题考点-链表"><a href="#12-链表中的倒数第k个结点-本题考点-链表" class="headerlink" title="12.链表中的倒数第k个结点[^本题考点 链表]"></a>12.链表中的倒数第k个结点[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(self, head, k)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># k 如果 比我们的链表的长度还要大的话，我们直接返回None</span></span><br><span class="line">        <span class="hljs-comment"># k 如果小于链表的长度，我们可以定义两个变量，这两个变量中间间隔k</span></span><br><span class="line">        <span class="hljs-comment">#用两个指针做一个尺子，然后让尺子在跳跳，然后就会找到 第k 个结点</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#起始位置 第一个和第二个指针 都是从头开始的。</span></span><br><span class="line">        firstPoint = head</span><br><span class="line">        secondPoint = head</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#首先让一个指针先开始移动，那么就是遍历我们的k 值，让我们的 第一个指针移动 k 步。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):</span><br><span class="line">            <span class="hljs-comment">#如果第一个指针为空的话，那么说明我们的k值为空，那么我们的这个链表就为空。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> firstPoint == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">            <span class="hljs-comment">#第一个指针 移动一步 </span></span><br><span class="line">            firstPoint = firstPoint.next</span><br><span class="line"><span class="hljs-comment">#当 第一个指针不为空的时候，</span></span><br><span class="line">        <span class="hljs-keyword">while</span> firstPoint != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-comment">#移动尺子，移动距离为  k 的长度， 直到 第一个指针点 为空的时候 ，就到了 这个链表的结尾，此时就返回 第二个指针 那么就为 倒数第 k 个结点。</span></span><br><span class="line">            firstPoint = firstPoint.next</span><br><span class="line">            secondPoint = secondPoint.next</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> secondPoint</span><br></pre></td></tr></table></figure><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiaozhong.png" alt></p><hr><p>如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。</p><h2 id="13-反转链表-本题考点-链表"><a href="#13-反转链表-本题考点-链表" class="headerlink" title="13.反转链表[^本题考点 链表]"></a>13.反转链表[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，反转链表后，输出新链表的表头。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"> pHead始终指向要反转的结点</span></span><br><span class="line"><span class="hljs-string">last 指向反转后的首结点</span></span><br><span class="line"><span class="hljs-string">每反转一个结点，</span></span><br><span class="line"><span class="hljs-string">把pHead结点的下一个结点指向last,</span></span><br><span class="line"><span class="hljs-string">last指向pHead成为反转后首结点,</span></span><br><span class="line"><span class="hljs-string">再把pHead向前移动一个结点直至None结束</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回ListNode</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#首先判断这个链表里是否只有一个结点，只有一个结点那么它就不需要发生变化，它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="hljs-comment"># 这个时候就直接返回这个 pHead</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pHead <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> pHead.next:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead</span><br><span class="line">        <span class="hljs-comment">#首先要明白 反转过后，第一个数值的指针的结点指向的是none 也就是一个指向反转后的首结点 为none</span></span><br><span class="line">        last = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#当 要反转的结点 pHead 存在的时候</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pHead:</span><br><span class="line">            <span class="hljs-comment">#先找到第一个元素的结点指向的元素，赋值给一个临时变量</span></span><br><span class="line">            temp = pHead.next</span><br><span class="line">            <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">            本来一个元素的结点 是要指向它的下一个 元素的 .</span></span><br><span class="line"><span class="hljs-string">            反转后 就是  这个元素 要指向它的 上一个 元素 .</span></span><br><span class="line"><span class="hljs-string">            </span></span><br><span class="line"><span class="hljs-string">            """</span></span><br><span class="line">            <span class="hljs-comment">#然后第一次循环 把这第一个元素的结点 改为 none last 第一个值 是 none (此时还没有发生改变的last)</span></span><br><span class="line">            <span class="hljs-comment"># 之后循环 就是 每 反转一个结点 把pHead结点的下一个结点指向last,</span></span><br><span class="line">            pHead.next = last</span><br><span class="line">            <span class="hljs-comment">#下一步 是把 pHead 这个 元素的 赋值给last</span></span><br><span class="line">            <span class="hljs-comment"># last指向pHead成为反转后首结点,</span></span><br><span class="line">            last = pHead</span><br><span class="line">            <span class="hljs-comment"># 再把pHead向前移动一个结点直至None结束</span></span><br><span class="line">            pHead = temp</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> last</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">反转需要两步 ，第一步找到它的 结点，第二步改变结点就可以了；</span></span><br><span class="line"><span class="hljs-string">之后需要 把结点 赋值为 这个元素的 本身 ；</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">循环：</span></span><br><span class="line"><span class="hljs-string"> 找到 元素结点指向的元素，</span></span><br><span class="line"><span class="hljs-string">目标是 让元素结点指向的元素 改为 自己本身。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#第二种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 将现有的头换成尾，尾部的next为空</span></span><br><span class="line"><span class="hljs-string">2 将从第二个node开始，循环将next指向前一个</span></span><br><span class="line"><span class="hljs-string">3 需要一直有一个指针指向还没有反转的链表的头部</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回ListNode</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#判断是否为空值，没有元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#判断是否只有一个元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead.next == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead</span><br><span class="line"><span class="hljs-comment">#左边指针为 头 第一个 指针</span></span><br><span class="line">        leftPointer = pHead</span><br><span class="line">        <span class="hljs-comment">#中间 的指针 为 第二个指针</span></span><br><span class="line">        midPointer = pHead.next</span><br><span class="line">        <span class="hljs-comment">#右边的指针  为 指向 中间 指针后的 所有的元素 </span></span><br><span class="line">        rightPointer = midPointer.next</span><br><span class="line">        <span class="hljs-comment">#左边的指针为 起始 的 元素， 反转后 它的next 为 None；</span></span><br><span class="line">        leftPointer.next = <span class="hljs-literal">None</span></span><br><span class="line"><span class="hljs-comment">#循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> rightPointer:</span><br><span class="line">            <span class="hljs-comment">#中间指针指向的为上一个 元素 即 leftPointer</span></span><br><span class="line">            midPointer.next = leftPointer</span><br><span class="line">            <span class="hljs-comment">#三个指针开始往右移。每次移一个。</span></span><br><span class="line">            <span class="hljs-comment">#左边指针 往右移一个 就是中间指针的位置</span></span><br><span class="line">            leftPointer = midPointer</span><br><span class="line">            <span class="hljs-comment">#中间指针 往 右 移 一个，就时 右边指针的位置</span></span><br><span class="line">            midPointer = rightPointer</span><br><span class="line">            <span class="hljs-comment">#右边指针往右移 一个 ，就时 右边指针的下一个。</span></span><br><span class="line">            rightPointer = rightPointer.next</span><br><span class="line"><span class="hljs-comment">#当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。</span></span><br><span class="line">        midPointer.next = leftPointer</span><br><span class="line">        <span class="hljs-comment">#最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> midPointer</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/fanzhuan.png" alt></p><hr><h2 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14.复杂链表的复制"></a>14.复杂链表的复制</h2><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/复杂链表的复制.png" alt></p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class RandomListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.label = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-comment">#         self.random = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回 RandomListNode</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Clone</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#判断当pHead 为空值的时候 返回的是none</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#把第一个 A 的值 赋给 node 为A‘</span></span><br><span class="line">            node = RandomListNode(pTmp.label)</span><br><span class="line">            <span class="hljs-comment">#此时 node A' 的结点指向的是 原来A 的结点指向的 值</span></span><br><span class="line">            node.next = pTmp.next</span><br><span class="line">            <span class="hljs-comment">#将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">            pTmp.next = node</span><br><span class="line">            <span class="hljs-comment">#将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素</span></span><br><span class="line">            pTmp = node.next</span><br><span class="line">        <span class="hljs-comment"># 实现新建的node的random的指向</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp.random:</span><br><span class="line">                <span class="hljs-comment">#那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。</span></span><br><span class="line">                pTmp.next.random = pTmp.random.next</span><br><span class="line">            <span class="hljs-comment">#建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="hljs-comment">#当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。</span></span><br><span class="line">            pTmp = pTmp.next.next</span><br><span class="line">        <span class="hljs-comment"># 断开原来的node 和 新的node 之间的链接</span></span><br><span class="line">        <span class="hljs-comment">#最后 为断开 链接 的操作</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-comment">#复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        <span class="hljs-comment">#复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        pNewTmp = pHead.next</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#print(pTmp.label)</span></span><br><span class="line">            <span class="hljs-comment">#将旧链表 A 的指向结点 改为  A‘ 的指向的下一个 的B。</span></span><br><span class="line">            pTmp.next = pTmp.next.next</span><br><span class="line">            <span class="hljs-comment">#如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pNewTmp.next:</span><br><span class="line">                <span class="hljs-comment">#那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’</span></span><br><span class="line">                pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                <span class="hljs-comment">#然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘ </span></span><br><span class="line">                pNewTmp = pNewTmp.next</span><br><span class="line">            <span class="hljs-comment">#上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B </span></span><br><span class="line">            pTmp = pTmp.next</span><br><span class="line">            <span class="hljs-comment">#如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line">        <span class="hljs-comment">#最后返回这个复制好的新链表。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> newHead</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">#第二种方法：</span></span><br><span class="line">     <span class="hljs-keyword">import</span> copy</span><br><span class="line">         chead=copy.deepcopy(pHead)</span><br><span class="line">         <span class="hljs-keyword">return</span> chead</span><br></pre></td></tr></table></figure><hr><h2 id="15-两个链表之间的第一个公共结点"><a href="#15-两个链表之间的第一个公共结点" class="headerlink" title="15.两个链表之间的第一个公共结点"></a>15.两个链表之间的第一个公共结点</h2><p><strong>输入两个链表，找出它们的第一个公共结点</strong></p><p>如图：</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/liangge.png" alt></p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="hljs-comment">#当链表1 和链表2 同时存在的时候</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp1 <span class="hljs-keyword">and</span> pTmp2:</span><br><span class="line">            <span class="hljs-comment">#当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp1 == pTmp2:</span><br><span class="line">                <span class="hljs-keyword">return</span> pTmp1</span><br><span class="line">            <span class="hljs-comment">#移动指针的位置，两个同时移动，</span></span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">            </span><br><span class="line">        <span class="hljs-comment">#第一个参数给比较短的那个链表的值</span></span><br><span class="line">        <span class="hljs-comment">#第二个参数给比较长的链表的值</span></span><br><span class="line">        <span class="hljs-comment">#第三个参数是比较短的那个链表头</span></span><br><span class="line">        <span class="hljs-comment">#第四个参数是比较长的那个链表头</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findEqual</span><span class="hljs-params">(longPointer, shorPointer, longHead, shortHead)</span>:</span></span><br><span class="line">            k = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> longPointer:</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">                k += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#然后：</span></span><br><span class="line">            <span class="hljs-comment"># 先让长的那个去走k步</span></span><br><span class="line">            longPointer = longHead</span><br><span class="line">            shortPointer = shortHead</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line"><span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> longPointer != shortPointer:</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">                shortPointer = shortPointer.next</span><br><span class="line">            <span class="hljs-keyword">return</span> shortPointer</span><br><span class="line"><span class="hljs-comment">#如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp1:</span><br><span class="line">            <span class="hljs-keyword">return</span> findEqual(pTmp1,pTmp2,pHead1,pHead2)</span><br><span class="line">            <span class="hljs-comment"># k = 0</span></span><br><span class="line">            <span class="hljs-comment"># #寻找出链表长度之间的差值</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     k += 1</span></span><br><span class="line">            <span class="hljs-comment"># #先让长的那个去走k步</span></span><br><span class="line">            <span class="hljs-comment"># pTmp2 = pHead2</span></span><br><span class="line">            <span class="hljs-comment"># pTmp1 = pHead1</span></span><br><span class="line">            <span class="hljs-comment"># for  i in range(k):</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1=pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1 != pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment"># return pTmp1</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp2:</span><br><span class="line">            <span class="hljs-keyword">return</span> findEqual(pTmp1, pTmp2, pHead1, pHead2)</span><br><span class="line">            <span class="hljs-comment"># k = 0</span></span><br><span class="line">            <span class="hljs-comment"># # 寻找出链表长度之间的差值</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment">#     k += 1</span></span><br><span class="line">            <span class="hljs-comment"># # 先让长的那个去走k步</span></span><br><span class="line">            <span class="hljs-comment"># pTmp2 = pHead2</span></span><br><span class="line">            <span class="hljs-comment"># pTmp1 = pHead1</span></span><br><span class="line">            <span class="hljs-comment"># for i in range(k):</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1 != pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment"># return pTmp2</span></span><br></pre></td></tr></table></figure><hr><h2 id="16-合并两个排序的链表-本题考点-链表"><a href="#16-合并两个排序的链表-本题考点-链表" class="headerlink" title="16.合并两个排序的链表 [^本题考点  链表]"></a>16.合并两个排序的链表 [^本题考点  链表]</h2><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong></p><p>如图：为两个递增的链表</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/liang.png" alt></p><p>如下图，合并成一个单调不减链表</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/hecheng.png" alt></p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">比较两个链表的首结点，哪个小的的结点则合并到第三个链表尾结点，并向前移动一个结点。</span></span><br><span class="line"><span class="hljs-string">步骤一结果会有一个链表先遍历结束，或者没有</span></span><br><span class="line"><span class="hljs-string">第三个链表尾结点指向剩余未遍历结束的链表</span></span><br><span class="line"><span class="hljs-string">返回第三个链表首结点</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回合并后列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="hljs-number">0</span>)</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="hljs-keyword">while</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="hljs-keyword">if</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="hljs-keyword">elif</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next</span><br><span class="line">        </span><br><span class="line"><span class="hljs-comment">#第二种方法：</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回合并后列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先判断两个链表是不是为空。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead2</span><br><span class="line">        <span class="hljs-keyword">if</span> pHead2 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead1</span><br><span class="line"><span class="hljs-comment">#比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。</span></span><br><span class="line">        newHead = pHead1 <span class="hljs-keyword">if</span> pHead1.val &lt; pHead2.val <span class="hljs-keyword">else</span> pHead2</span><br><span class="line"></span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="hljs-comment">#判断 如果新表头 是 表1 的头的话 那么 新表头</span></span><br><span class="line">        <span class="hljs-keyword">if</span> newHead == pTmp1:</span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">        <span class="hljs-comment">#</span></span><br><span class="line">        previousPointer = newHead</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp1 <span class="hljs-keyword">and</span> pTmp2:</span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp1.val &lt; pTmp2.val:</span><br><span class="line">                previousPointer.next = pTmp1</span><br><span class="line">                previousPointer = pTmp1</span><br><span class="line">                pTmp1 = pTmp1.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                previousPointer.next = pTmp2</span><br><span class="line">                previousPointer = pTmp2</span><br><span class="line">                pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp1 == <span class="hljs-literal">None</span>:</span><br><span class="line">        </span><br><span class="line">            previousPointer.next = pTmp2</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            previousPointer.next = pTmp1</span><br><span class="line">            </span><br><span class="line">        <span class="hljs-keyword">return</span> newHead</span><br></pre></td></tr></table></figure><hr><h2 id="17-圆圈中最后剩下的数-本题考点-模拟"><a href="#17-圆圈中最后剩下的数-本题考点-模拟" class="headerlink" title="17.圆圈中最后剩下的数 [^本题考点 模拟]"></a>17.圆圈中最后剩下的数 [^本题考点 <em>模拟</em>]</h2><p><strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/xiao.png" alt></p><hr><p>思路分析：</p><p>这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。</p><p>链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).</p><p>链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).</p><p>这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。</p><p>链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)</p><p>  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。</p><p>但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：</p><p>(iii+m)%n    我们一共是 n 个值，从0-(n-1);</p><p>f(n-1) = iii</p><p>所以 f(n) = f `(n-1) = (iii+m)%n</p><p>所以 f(n) = (f(n-1)+m)</p><p>那么这个通项表达式我们就找到了，再去编写代码。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#通过推导公式可得 f(n) = (f(n-1)+m)%n</span></span><br><span class="line">        <span class="hljs-comment">#首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment">#只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        value = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度 o(n)</span></span><br><span class="line">        <span class="hljs-comment">#从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 </span></span><br><span class="line">        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-comment">#现在数到的 m-1 这个值 的索引。对应上上面的公式。</span></span><br><span class="line">            currentValue = (value+m) % index</span><br><span class="line">            <span class="hljs-comment">#把找到的这个下标值 赋值给 value</span></span><br><span class="line">            value = currentValue</span><br><span class="line">        <span class="hljs-comment">#返回编号</span></span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></table></figure><hr><h2 id="18-链表中环的入口点-本题知识点-链表"><a href="#18-链表中环的入口点-本题知识点-链表" class="headerlink" title="18.链表中环的入口点 [^本题知识点  链表]"></a>18.链表中环的入口点 [^本题知识点  链表]</h2><p><strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiaozhonghuan.png" alt></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。</span></span><br><span class="line">        <span class="hljs-comment">#循环跳</span></span><br><span class="line">        <span class="hljs-comment">#要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> </span><br><span class="line"><span class="hljs-comment">#定义两个指针，一个快的一个慢的。</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        slowPointer = pHead</span><br><span class="line"><span class="hljs-comment">#当快指针存在时，而且快指针的结点指向的下一个也存在</span></span><br><span class="line">        <span class="hljs-keyword">while</span> fastPointer <span class="hljs-keyword">and</span> fastPointer.next :</span><br><span class="line">            <span class="hljs-comment">#那么让快指针走两步</span></span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            <span class="hljs-comment">#让慢指针走一步</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">            <span class="hljs-comment">#如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break</span></span><br><span class="line">            <span class="hljs-keyword">if</span> fastPointer == slowPointer:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment">#如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> fastPointer == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> fastPointer.next == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度</span></span><br><span class="line">        <span class="hljs-comment">#假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 那么  L = s + d</span></span><br><span class="line">        <span class="hljs-comment">#假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少</span></span><br><span class="line">        <span class="hljs-comment"># fast 走的长度 就是 ( m + d ) * n + d + s = 2 L</span></span><br><span class="line">        <span class="hljs-comment">#带入 ( m + d ) * n + d + s = 2 （s + d ）</span></span><br><span class="line">        <span class="hljs-comment"># s = m + (n-1)(m+d)</span></span><br><span class="line"><span class="hljs-comment">#有环的话，那么就让快指针从头开始走，这次一次走一步，</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line"><span class="hljs-comment">#此时慢指针还在环里走着，没有走到结点</span></span><br><span class="line">        <span class="hljs-keyword">while</span> fastPointer != slowPointer:</span><br><span class="line">            fastPointer = fastPointer.next</span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        <span class="hljs-comment">#当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> fastPointer</span><br></pre></td></tr></table></figure><p>定义：</p><p>假设 slow 走了 L 步，那么 fast 就走了 2L 步。</p><p> 我们 链表的头部 到 链表的环的入口结点处 的距离是 S</p><p>那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 </p><p>链表的环中，慢指针走过的距离是d，那么没走过的距离是M。</p><p>我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。</p><p>那么 L = s + d</p><p>2L = 2(s+d) = n*(m + d) + d + s</p><p>由上面公式 推导出 n(m+d) = s + d</p><p>得到：s = n(m+d) -d；</p><p>s = nm + (n-1)(d)<br>s = m + (n-1)(m+d)</p><hr><h2 id="19-二进制中的1的个数"><a href="#19-二进制中的1的个数" class="headerlink" title="19.二进制中的1的个数"></a>19.二进制中的1的个数</h2><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</strong></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a><code>知识点:</code></h4><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>特性：</p><p>1、一个负整数（或原码）与其补数（或补码）相加，和为模。</p><p>2、对一个整数的补码再求补码，等于该整数自身。</p><p>3、补码的正零与负零表示方法相同</p><h4 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 ~"></a>按位取反 ~</h4><p>~，用法只有一个那就是按位取反，需要注意的是：</p><ul><li>~的按位取反，包括符号位</li><li>正数各位取反变为负数，显示时转化为其补码</li><li>负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位去反</li></ul><h5 id="1-5"><a href="#1-5" class="headerlink" title="1. ~5"></a>1. ~5</h5><p>5 的二进制为 0101，</p><p>~5</p><ul><li>（1）各位取反，1010</li><li>（2）变为负数，转化为其补码形式（符号位保持不变），各位取反 1（1101），再加1（1110），也即 -6</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~<span class="hljs-number">5</span></span><br><span class="line">&gt;&gt; <span class="hljs-number">-6</span></span><br></pre></td></tr></table></figure><h5 id="2-5"><a href="#2-5" class="headerlink" title="2. ~(-5)"></a>2. ~(-5)</h5><p>-5 因为是负数，存储时存储的是其补码：</p><ul><li>-5 的补码是：1011，</li><li>~(-5)将其各位取反（包括符号位），也即 0100（4）</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~(<span class="hljs-number">-5</span>)</span><br><span class="line">&gt;&gt; <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#第一种：</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#补码：正数不变，负数是它的正数的反码 + 1</span></span><br><span class="line">        <span class="hljs-comment"># -2 补码： -2 的 1 0000.。。000010，</span></span><br><span class="line">        <span class="hljs-comment">#                 1 1111.。。111101 + 1</span></span><br><span class="line">        <span class="hljs-comment">#-2 的补码就是    1 1111.。。111110</span></span><br><span class="line">        <span class="hljs-comment">#把输入的正数n转化为二进制的数，并把0b 替换掉，计算1的数量，如果输入的值不是正数的话</span></span><br><span class="line">        <span class="hljs-comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。</span></span><br><span class="line">        <span class="hljs-comment">#那么就是 2 的32 次方 然后 + n  这是在取一个负数的补码  就相当于  n &amp; 0xffffffff</span></span><br><span class="line">        <span class="hljs-comment">#然后计算 这个数里面 1 的 数量</span></span><br><span class="line">        <span class="hljs-keyword">return</span> bin(n).replace(<span class="hljs-string">"0b"</span>, <span class="hljs-string">""</span>).count(<span class="hljs-string">"1"</span>) <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> bin(<span class="hljs-number">2</span> ** <span class="hljs-number">32</span> + n).replace(<span class="hljs-string">"0b"</span>, <span class="hljs-string">""</span>).count(<span class="hljs-string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">#第二种：</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># 1 出现的次数为0 次</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#判断 这个数 n 是不是负数，如果是负数的话 求其补码：</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:</span><br><span class="line">            n = n &amp; <span class="hljs-number">0xffffffff</span></span><br><span class="line">        <span class="hljs-comment">#如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.</span></span><br><span class="line">        <span class="hljs-keyword">while</span> n:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line">            n = (n - <span class="hljs-number">1</span>) &amp; n</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.</span></span><br><span class="line"><span class="hljs-string">    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。</span></span><br><span class="line"><span class="hljs-string">    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.</span></span><br><span class="line"><span class="hljs-string">    </span></span><br><span class="line"><span class="hljs-string">    """</span></span><br></pre></td></tr></table></figure><hr><h2 id="20-不用加减乘除做加法-本题考点-按位运算"><a href="#20-不用加减乘除做加法-本题考点-按位运算" class="headerlink" title="20.不用加减乘除做加法[^本题考点 按位运算]"></a>20.不用加减乘除做加法[^本题考点 <em>按位运算</em>]</h2><p><strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/buyong.png" alt></p><p>分析：</p><p>对于数字运算，如果说四则运算不能用的话，那么我们只能用位运算来做了。</p><p>我们以 5 + 17 为例 结果为 22，那么 22 的计算结果，我们可以分为三步 来进行：</p><p>​    第一步： 只做各位相加不进位  也就是说 没一位上的数字 相应的来相加 但是不进位，那么  5 + 7 为 12 </p><p>​    个位数 5 和 7 相加 不进位 是2  十位是0 和1  相加 为 1 </p><p>​    第二步： 5 + 7 中有进位，进位值 是10 ;</p><p>​    第三步： 把前面两个结果 加起来： 12 + 10 = 22</p><p>以上为我们用十进制计算的 策略，那么 我们用于位运算中是不是也合适，我们来举个栗子：</p><p>还是以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；</p><p>第一步：各位相加 但不进位： 101 + 10001 = 10110  不进位的话  结果为 10100 （最后一位两个数都是1，相加的结果需要进位，但是这一位不进位，意味着结果仍然是0）</p><p>第二步： 记下进位，它只在最后一位相加时产生了一个进位。</p><p>第三步： 把前面两个结果相加，得到的结果是 10110.</p><p><strong>那么现在我们把前面的 二进制的加法用位运算来替代的话</strong></p><p>第一步的 求 和 运算就是 不考虑 进位的话，对每一位来相加，0 和0 1 和1 的结果都是0,0+1，或者1+0 的结果 都是1；那么我们会看出它与我们学过的异或运算相同，就是相同为假，不同为真，所以叫 异  或  XOR 。</p><p>第二步： 对0 加 0、1加0、0加1 而言，都不会产生进位，只有1+1 的时候，会产生一个进位。此时 我们可以想象成两个数 先做了一个 位 与 &amp; 运算，然后再向 左移 一位。只有两个数是1 的时候，位与 &amp; 得到的结果是 1，其余的都是0。</p><p>第三步：把前面两个步骤的结果再相加，然后在继续判断是否有进位，直到没有进位为止，那么此时的相加的过程，依然是重复前面的两步，直到不产生进位为止。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Add</span><span class="hljs-params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#第一种代码：循环。简洁但是原理相同，那么我们以下面第二段代码为例；来解析。</span></span><br><span class="line">        <span class="hljs-comment"># while (num2):</span></span><br><span class="line">        <span class="hljs-comment">#     num1, num2 = (num1 ^ num2) &amp; 0xFFFFFFFF, ((num1 &amp; num2) &lt;&lt; 1) &amp; 0xFFFFFFFF</span></span><br><span class="line">        <span class="hljs-comment"># return num1 if num1 &lt;= 0x7FFFFFFF else ~(num1 ^ 0xFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#第二种代码：</span></span><br><span class="line">        <span class="hljs-comment">#首先两个数做 一个 异或 运算^ 那就是 在不进位的情况下，让两个相加 求和。</span></span><br><span class="line">        xorNum = num1 ^ num2</span><br><span class="line">        <span class="hljs-comment">#让两个数 做 位与 操作，然后再向 左 移 一位，得到它 向前进位的值。</span></span><br><span class="line">        andNum = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> andNum != <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#那么我们就继续上面的操作。但是这次的 数值 改为上次的两个结果，</span></span><br><span class="line">            <span class="hljs-comment">#一个 是异或的结果，一个是 与 操作 &amp; 以后 左移一位的 结果。</span></span><br><span class="line">            tmp1 = xorNum ^ andNum</span><br><span class="line">            tmp2 = (xorNum &amp; andNum) &lt;&lt; <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#因为如果这个数为负数的话，那么负数 左移 一位与正数 不同，负数 是数值变小，正数 数值变大</span></span><br><span class="line">            <span class="hljs-comment">#如果是正数的话那么这一步就 不变，如果是负数的话，这一步就对负数来起作用。</span></span><br><span class="line">            <span class="hljs-comment">#对于python来说  负数的 二进制 可能会有无数个1，我们用这个方法让它变成一个可数的数字长度。</span></span><br><span class="line">            tmp1 = tmp1 &amp; <span class="hljs-number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">            xorNum = tmp1</span><br><span class="line">            andNum = tmp2</span><br><span class="line">         <span class="hljs-comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。 0xffffffff </span></span><br><span class="line"><span class="hljs-comment"># ~(xorNum ^ 0xFFFFFFFF)  这个是 异或数  与  模 来 异或，最后 按位 取反 来求得 负数的补码。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> xorNum <span class="hljs-keyword">if</span> xorNum &lt;= <span class="hljs-number">0x7ffffff</span> <span class="hljs-keyword">else</span> ~(xorNum ^ <span class="hljs-number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure><h2 id="21-数组中出现次数超过一半的数字-本题考点-数组"><a href="#21-数组中出现次数超过一半的数字-本题考点-数组" class="headerlink" title="21.数组中出现次数超过一半的数字[^本题考点 数组]"></a>21.数组中出现次数超过一半的数字[^本题考点 数组]</h2><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</strong></p><p>  思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。<br>        首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。</p><p>我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#dict [key] = count</span></span><br><span class="line">        <span class="hljs-comment">#o(n) 空间复杂度为O(n)</span></span><br><span class="line">     <span class="hljs-comment">#第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。</span></span><br><span class="line">        numsCount = &#123;&#125;</span><br><span class="line">        numLen = len(numbers)</span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> numsCount:</span><br><span class="line">                numsCount[num] += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                numsCount[num] = <span class="hljs-number">1</span></span><br><span class="line">             <span class="hljs-comment">#如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> numsCount[num] &gt; (numLen &gt;&gt; <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">return</span> num</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#想要空间复杂度为O（1），时间复杂度为o(n)</span></span><br><span class="line"><span class="hljs-comment">#第二种：</span></span><br><span class="line">        <span class="hljs-comment">#定义变量 上次出现的数字为0</span></span><br><span class="line">        last = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#上次出现的数字的数量为0 </span></span><br><span class="line">        lastCount = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment">#遍历数组中的数字</span></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">            <span class="hljs-comment">#如果说这个数字出现的次数为0了。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> lastCount == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-comment">#那么就把上次出现的数字，变为需要保存的那个数字。</span></span><br><span class="line">                last = num</span><br><span class="line">                <span class="hljs-comment">#并把次数设置为1 次，出现了这一次。</span></span><br><span class="line">                lastCount = <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.</span></span><br><span class="line">                <span class="hljs-keyword">if</span> num == last:</span><br><span class="line">                    lastCount += <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-comment">#如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    lastCount -= <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉</span></span><br><span class="line">        <span class="hljs-keyword">if</span> lastCount == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#否则的话，就说明 数组里面 留下了没有抵消掉的数</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment">#这种情况是last可能是大于一半的数字</span></span><br><span class="line">            <span class="hljs-comment">#这个时候把 记录数字次数的变量 计数 为0 </span></span><br><span class="line">            lastCount = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment">#遍历数组中的数</span></span><br><span class="line">            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">                <span class="hljs-comment">#如果这个数与我们记录的数相等的话</span></span><br><span class="line">                <span class="hljs-keyword">if</span> num == last:</span><br><span class="line">                    <span class="hljs-comment">#让这个计数加1</span></span><br><span class="line">                    lastCount += <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> lastCount &gt; (len(numbers)&gt;&gt; <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">return</span> last</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="22-数组中只出现一次的数字-数组"><a href="#22-数组中只出现一次的数字-数组" class="headerlink" title="22.数组中只出现一次的数字[^数组]"></a>22.数组中只出现一次的数字[^数组]</h2><p><strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</strong></p><p>思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(self, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#如果两个数相同那么两个数的异或操作为0</span></span><br><span class="line">        <span class="hljs-comment">#数组的长度如果小于2，那么就就不会有数字出现了偶数次。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(array) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#变量赋值 两个数的异或为none</span></span><br><span class="line">        twoNumXor = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#遍历 数组中的数字</span></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:</span><br><span class="line">            <span class="hljs-comment">#判断 如果 两个数的数字异或的结果为0 的话，</span></span><br><span class="line">            <span class="hljs-keyword">if</span> twoNumXor == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-comment">#那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。</span></span><br><span class="line">                twoNumXor = num</span><br><span class="line">            <span class="hljs-comment">#如果数 这个数不为 空 的话</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。</span></span><br><span class="line">                twoNumXor = twoNumXor ^ num</span><br><span class="line">        <span class="hljs-comment">#变量  计数 为 0 </span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#当异或的 结果 为偶数时</span></span><br><span class="line">        <span class="hljs-keyword">while</span> twoNumXor % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> :</span><br><span class="line">            <span class="hljs-comment">#那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。</span></span><br><span class="line">            twoNumXor  = twoNumXor &gt;&gt; <span class="hljs-number">1</span>  <span class="hljs-comment"># 右移以为 相当于 除以2</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1</span></span><br><span class="line">        </span><br><span class="line">        mask = <span class="hljs-number">1</span> &lt;&lt; count   <span class="hljs-comment">#向左 移 位 count 位。</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。</span></span><br><span class="line">        </span><br><span class="line">        firstNum = <span class="hljs-literal">None</span></span><br><span class="line">        secondNum = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:</span><br><span class="line">            <span class="hljs-keyword">if</span> mask &amp; num == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> firstNum == <span class="hljs-literal">None</span>:</span><br><span class="line">                    firstNum = num</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    firstNum = firstNum ^ num</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> secondNum == <span class="hljs-literal">None</span>:</span><br><span class="line">                    secondNum = num</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    secondNum = secondNum ^ num</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> firstNum,secondNum</span><br></pre></td></tr></table></figure><hr><h2 id="23-整数中1出现的次数-本题考点-数组"><a href="#23-整数中1出现的次数-本题考点-数组" class="headerlink" title="23.整数中1出现的次数[^本题考点 数组]"></a>23.整数中1出现的次数[^本题考点 数组]</h2><p><strong>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</strong></p><p> <img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/zhengshu.png" alt></p><hr><p>如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。</p><p>那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。</p><p><strong>若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ </strong></p><p>​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有</p><p><code>0-3458</code> 个数 那么就一共是 3459 中可能性。</p><p>​    <strong>那么十万位 后面 出现1 的情况有多少种 可能性 ？</strong></p><p>​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 <code>10^5</code>. </p><p>那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。</p><p>​    <strong>接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？</strong></p><p>如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共<code>34591</code>种情况，后面 是一共 4 位，那么就有        <code>10^4</code>种情况。</p><p>那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。</p><p>​    <strong>我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？</strong></p><p>如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是</p><p>3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有</p><p>3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。</p><p>分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#循环的出口是 highValue = 0</span></span><br><span class="line">        <span class="hljs-comment">#我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。</span></span><br><span class="line">        <span class="hljs-comment"># 一开始 精准度为1.高位低位中位 先赋值为1.</span></span><br><span class="line">        preceise = <span class="hljs-number">1</span></span><br><span class="line">        highValue = <span class="hljs-number">1</span></span><br><span class="line">        lowValue = <span class="hljs-number">1</span></span><br><span class="line">        midValue =<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#计数 后面的位数。</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#计数 1 的次数和</span></span><br><span class="line">        sumNum = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> highValue != <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#高位 先将这个数 除以10 得到高位</span></span><br><span class="line">            highValue = n // (preceise * <span class="hljs-number">10</span>)</span><br><span class="line">            <span class="hljs-comment">#中位 先将这个数  与 10 取余。</span></span><br><span class="line">            midValue = (n // preceise)%<span class="hljs-number">10</span></span><br><span class="line">            <span class="hljs-comment">#低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.</span></span><br><span class="line">            lowValue = n % preceise</span><br><span class="line">            <span class="hljs-comment">#每遍历一次 向右移一位，那么就是说 精准度要乘以10.</span></span><br><span class="line">            preceise *= <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-comment">#如果这个数是0 的话，</span></span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">if</span> midValue == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-comment">#那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，</span></span><br><span class="line">                num = (highValue)* pow(<span class="hljs-number">10</span>,count)</span><br><span class="line">            <span class="hljs-comment">#如果这个数 大于1 的话，</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> midValue &gt; <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-comment">#那么它 就是 最高位加1 乘以 10^后面的位数 次方，</span></span><br><span class="line">                num = (highValue+<span class="hljs-number">1</span>)*pow(<span class="hljs-number">10</span>,count)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。</span></span><br><span class="line">                num = highValue*pow(<span class="hljs-number">10</span>,count)+(lowValue+<span class="hljs-number">1</span>)</span><br><span class="line">            <span class="hljs-comment">#最后 我们1 出现的 次数 就是这 三个 num 的和，。</span></span><br><span class="line">            sumNum += num</span><br><span class="line">            <span class="hljs-comment">#没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#最后返回这个  次数和。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> sumNum</span><br></pre></td></tr></table></figure><hr><h2 id="24-丑数"><a href="#24-丑数" class="headerlink" title="24.丑数"></a>24.丑数</h2><p><strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p><p>思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？</p><p>因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(self, index)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#死循环，找丑数</span></span><br><span class="line">        <span class="hljs-comment">#判断一个数是不是丑数，先循环除以2，直到不能整除，</span></span><br><span class="line">        <span class="hljs-comment">#循环除以3 直到不能整除，循环除以5 直到不能整除</span></span><br><span class="line">        <span class="hljs-comment">#这时如果剩余的值是1  我们就说它是丑数</span></span><br><span class="line">        <span class="hljs-comment">#其他情况就都不是丑数</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isUglyNumber</span><span class="hljs-params">(num)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">3</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">5</span></span><br><span class="line">            <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        num = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> isUglyNumber(num):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> count == index:</span><br><span class="line">                <span class="hljs-keyword">return</span> num</span><br><span class="line">            num += <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><p>第二种方法分析:</p><p>我们可以保存已经找到的丑数，然后 用空间环时间 来 找出丑数。</p><p>如何用空间换时间？</p><p>我们找一种，只需要计算丑数的办法,根据上面丑数的定义，我们可以知道，丑数应该是另一个丑数 乘以 2,3，或者5 的结果（1除外）。因此我们 可以创建一个 列表，里面的数字是排好序的 丑数，每个丑数都是前面的丑数乘以2,3，或者5得到的。</p><p>那么我们就可以在一个列表中，给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，第一个丑数为1，那么我们在这个列表的起始位置 设置三个指针，这三个指针代表的值  分别为2,3,5.又由于这个列表中的所有的丑数 是有序的，从小到大排列的，那么我们在每次 给一个丑数 乘以 2,3,5 以后要与前面的丑数比较大小，然后在根据大小值 来放入列表中。由于一开始第一个丑数是1，那么 1 <em> 2 得到的是2,1</em>3 得到的是3，1 乘以5 得到的是5，那么三个数中比较大小，最小的是 1 乘以2，那么 肯定第一个先放置的是2，然后是 2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，以此类推，那么现在的到的丑数的顺序就是1,2,3,4.。。。。。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(self, index)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#首先判断  要找的 丑数 是不是第0个 或者是负数，如果是的话，那么就返回0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#然后判断要找的丑数 是不是第一个，如果是第一个，那么就返回1.</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#在丑数 这个列表中 给出第一个丑数是1</span></span><br><span class="line">        numbers = [<span class="hljs-number">1</span>]</span><br><span class="line">        <span class="hljs-comment">#在列表的 一开始  设置三个 指针，也就是 三个指针的 索引位置是0，</span></span><br><span class="line">        two, three, five = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#丑数的个数 起始为 1</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#循环 当丑数的个数不等于我们要找到 那第 index 个 丑数时，就循环，等于的时候就跳出循环。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> count != index :</span><br><span class="line">            <span class="hljs-comment">#给列表中的 2,3,5 这三个指针所在位置的 丑数 分别 乘以2,3,5</span></span><br><span class="line">            n2, n3, n5 = numbers[two] * <span class="hljs-number">2</span>, numbers[three] * <span class="hljs-number">3</span>, numbers[five] * <span class="hljs-number">5</span></span><br><span class="line">            <span class="hljs-comment">#比较这三个丑数的大小</span></span><br><span class="line">            minValue = min(n2, n3, n5)</span><br><span class="line">            <span class="hljs-comment">#在丑数列表中，把三个中最小的那个 放进去。</span></span><br><span class="line">            numbers.append(minValue)</span><br><span class="line">            <span class="hljs-comment">#每放进去一个，丑数的数量就加1</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n2:</span><br><span class="line">                two += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果是 3 那个指针的话，那么3 这个指针就移一位。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n3:</span><br><span class="line">                three += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果是 5 那个指针的话，那么5这个指针就移一位。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n5:</span><br><span class="line">                five += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#最后输出这个丑数列表中的 最后一位，那么就是我们的计数的丑数的个数 -1，就是最后一个丑数的索引值。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> numbers[count<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="树的知识点："><a href="#树的知识点：" class="headerlink" title="树的知识点："></a>树的知识点：</h4><h5 id="什么叫做树？"><a href="#什么叫做树？" class="headerlink" title="什么叫做树？"></a>什么叫做树？</h5><p><strong>树状图</strong>是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">数据结构</a>，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88" target="_blank" rel="noopener">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><p>每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；</p><p>叶节点没有子节点，根节点没有父节点。</p><h5 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h5><p>每个节点最多含有两个子树的树称为二叉树。下图就是一个二叉树。</p><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/ercha.png" alt></p><h5 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h5><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，<a href="https://baike.baidu.com/item/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">树的遍历</a>实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p><p>设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">treeNode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="hljs-literal">None</span></span><br><span class="line">        self.right = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#1. 深度优先</span></span><br><span class="line"><span class="hljs-comment">#2. 广度优先</span></span><br><span class="line"><span class="hljs-comment">#对于深度优先来说：</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">1 先序遍历  先打印根 1,2,4,5,3,6,8,7</span></span><br><span class="line"><span class="hljs-string">2 中序遍历  先打印左侧的叶子节点 4，再输出 中节点  2 ；  4 2 5 1 6 8 3 7 </span></span><br><span class="line"><span class="hljs-string">3 先序遍历  输出顺序  4 5 2 8 6 7 3 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">注意：  先序   中序 后序  都是对应于根节点来说的，左右节点都是先左后右</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment">#递归</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    print(root.val)</span><br><span class="line">    preOrderRecusive(root.left)</span><br><span class="line">    preOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">midOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">    midOrderRecusive(root.left)</span><br><span class="line">    print(root.val)</span><br><span class="line">    midOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laterOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">    laterOrderRecusive(root.left)</span><br><span class="line">    laterOrderRecusive(root.right)</span><br><span class="line">    print(root.val)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#非递归的形式 去遍历数</span></span><br><span class="line"><span class="hljs-comment">#递归和循环是可以互相转换的</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">1 先根遍历 先访问根节点，再访问左子节点，最后访问右子节点</span></span><br><span class="line"><span class="hljs-string">2 中根遍历 先访问左子节点，再访问根节点，最后访问右子节点</span></span><br><span class="line"><span class="hljs-string">3 后跟遍历 先访问左子节点，再访问右子节点，最后访问根节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line">            print(tmpNode.val)</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node  = stack.pop()</span><br><span class="line">        tmpNode = node.right</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line"></span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node  = stack.pop()</span><br><span class="line">        print(node.val)</span><br><span class="line">        tmpNode = node.right</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laterOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node = stack[<span class="hljs-number">-1</span>]</span><br><span class="line">        tmpNode = node.right</span><br><span class="line">        <span class="hljs-keyword">if</span> node.right == <span class="hljs-literal">None</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            print(node.val)</span><br><span class="line">            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> node == stack[<span class="hljs-number">-1</span>].right:</span><br><span class="line">                node =  stack.pop()</span><br><span class="line">                print(node.val)</span><br></pre></td></tr></table></figure><h2 id="25-重建二叉树"><a href="#25-重建二叉树" class="headerlink" title="25.重建二叉树"></a>25.重建二叉树</h2><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> tin:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(pre) != len(tin):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 取出pre 的第一个值  就是根节点</span></span><br><span class="line">        root = pre[<span class="hljs-number">0</span>]</span><br><span class="line">        rootNode = TreeNode(root)</span><br><span class="line">        <span class="hljs-comment"># 找到在 tin  中序遍历中的根节点 所在的索引位置</span></span><br><span class="line">        pos = tin.index(root)</span><br><span class="line">        <span class="hljs-comment"># 中序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        tinLeft = tin[<span class="hljs-number">0</span>:pos]</span><br><span class="line">        tinRight = tin[pos + <span class="hljs-number">1</span>:]</span><br><span class="line">        <span class="hljs-comment"># 前序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        preLeft = pre[<span class="hljs-number">1</span>:pos + <span class="hljs-number">1</span>]</span><br><span class="line">        preRight = pre[pos + <span class="hljs-number">1</span>:]</span><br><span class="line"></span><br><span class="line">        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        rightNode = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line"></span><br><span class="line">        rootNode.left = leftNode</span><br><span class="line">        rootNode.right = rightNode</span><br><span class="line">        <span class="hljs-keyword">return</span> rootNode</span><br></pre></td></tr></table></figure><hr><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasEqual</span><span class="hljs-params">(pRoot1, pRoot2)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                <span class="hljs-keyword">if</span> pRoot2.left == <span class="hljs-literal">None</span>:</span><br><span class="line">                    leftEqual = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    leftEqual = hasEqual(pRoot1.left, pRoot2.left)</span><br><span class="line">                <span class="hljs-keyword">if</span> pRoot2.right == <span class="hljs-literal">None</span>:</span><br><span class="line">                    rightEqual = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    rightEqual = hasEqual(pRoot1.right, pRoot2.right)</span><br><span class="line">                <span class="hljs-keyword">return</span> leftEqual <span class="hljs-keyword">and</span> rightEqual</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">            ret = hasEqual(pRoot1, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> ret:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">if</span> ret:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">对于Python这道题，有些地方需要仔细考虑的。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">先说下算法实现思路：对于两棵二叉树来说，要判断B是不是A的子结构，首先第一步在树A中查找与B根节点的值一样的节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">通常对于查找树中某一个节点，我们都是采用递归的方法来遍历整棵树。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">第二步就是判断树A中以R为根节点的子树是不是和树B具有相同的结构。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">这里同样利用到了递归的方法，如果节点R的值和树的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">如果它们值是相同的，则递归的判断各自的左右节点的值是不是相同。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">递归的终止条件是我们达到了树A或者树B的叶节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">有地方要重点注意，DoesTree1haveTree2()函数中的两个 if 判断语句 不能颠倒顺序 。</span></span><br><span class="line"><span class="hljs-string">因为如果颠倒了顺序，会先判断pRoot1 是否为None, 其实这个时候，pRoot1 的节点已经遍历完成确认相等了，但是这个时候会返回 False，判断错误。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">有同学不相信的，可以去试试换个顺序，肯定不能AC。同时这个也是《剑指offer》书上没有写的，希望能引起大家的注意。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        result = <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1 != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pRoot2 != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                result = self.DoesTree1haveTree2(pRoot1, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:</span><br><span class="line">                result = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:</span><br><span class="line">                result = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br><span class="line">    <span class="hljs-comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">    <span class="hljs-comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">    <span class="hljs-comment"># 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DoesTree1haveTree2</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) <span class="hljs-keyword">and</span> self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure><hr><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><code>输入描述:</code></h5><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">        <span class="hljs-number">8</span></span><br><span class="line">       /  \</span><br><span class="line">      <span class="hljs-number">6</span>   <span class="hljs-number">10</span></span><br><span class="line">     / \  / \</span><br><span class="line">    <span class="hljs-number">5</span>  <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span></span><br><span class="line">    镜像二叉树</span><br><span class="line">        <span class="hljs-number">8</span></span><br><span class="line">       /  \</span><br><span class="line">      <span class="hljs-number">10</span>   <span class="hljs-number">6</span></span><br><span class="line">     / \  / \</span><br><span class="line">    <span class="hljs-number">11</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(self, root)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#处理根节点</span></span><br><span class="line">        root.left,root.right = root.right,root.left</span><br><span class="line">        self.Mirror(root.left)</span><br><span class="line">        self.Mirror(root.right)</span><br></pre></td></tr></table></figure><hr><h2 id="28-从上往下打印二叉树"><a href="#28-从上往下打印二叉树" class="headerlink" title="28.从上往下打印二叉树"></a>28.从上往下打印二叉树</h2><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(self, root)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line">        treeNodeTmp = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="hljs-keyword">while</span> treeNodeTmp:</span><br><span class="line">            tmpNode = treeNodeTmp[<span class="hljs-number">0</span>]</span><br><span class="line">            ret.append(tmpNode.val)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left:</span><br><span class="line">                treeNodeTmp.append(tmpNode.left)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.right:</span><br><span class="line">                treeNodeTmp.append(tmpNode.right)</span><br><span class="line">            <span class="hljs-keyword">del</span> treeNodeTmp[<span class="hljs-number">0</span>]</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h2 id="29-二叉搜索树的后序遍历序列"><a href="#29-二叉搜索树的后序遍历序列" class="headerlink" title="29.二叉搜索树的后序遍历序列"></a>29.二叉搜索树的后序遍历序列</h2><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">python:后序遍历 的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，后面用递归分别判断前后两部分 是否 符合以上原则</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> len(sequence)==<span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        length=len(sequence)</span><br><span class="line">        root=sequence[length<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># 在二叉搜索 树中 左子树节点小于根节点</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length):</span><br><span class="line">            <span class="hljs-keyword">if</span> sequence[i]&gt;root:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment"># 二叉搜索树中右子树的节点都大于根节点</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j  <span class="hljs-keyword">in</span> range(i,length):</span><br><span class="line">            <span class="hljs-keyword">if</span> sequence[j]&lt;root:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-comment"># 判断左子树是否为二叉树</span></span><br><span class="line">        left=<span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span>  i&gt;<span class="hljs-number">0</span>:</span><br><span class="line">            left=self.VerifySquenceOfBST(sequence[<span class="hljs-number">0</span>:i])</span><br><span class="line">        <span class="hljs-comment"># 判断 右子树是否为二叉树</span></span><br><span class="line">        right=<span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span> i&lt;length<span class="hljs-number">-1</span>:</span><br><span class="line">            right=self.VerifySquenceOfBST(sequence[i:<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-keyword">return</span> left <span class="hljs-keyword">and</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        rootNum = sequence[<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">del</span> sequence[<span class="hljs-number">-1</span>]</span><br><span class="line">        index = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(sequence)):</span><br><span class="line">            <span class="hljs-keyword">if</span> index == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> sequence[i] &gt; rootNum:</span><br><span class="line">                index = i</span><br><span class="line">            <span class="hljs-keyword">if</span> index != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> sequence[i] &lt; rootNum:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence[:index] == []:</span><br><span class="line">            leftRet = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            leftRet = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        <span class="hljs-keyword">if</span> sequence[index:] == []:</span><br><span class="line">            rightRet = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            rightRet = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> leftRet <span class="hljs-keyword">and</span> rightRet</span><br></pre></td></tr></table></figure><hr><h2 id="30-二叉树中和为某一值的路径"><a href="#30-二叉树中和为某一值的路径" class="headerlink" title="30.二叉树中和为某一值的路径"></a>30.二叉树中和为某一值的路径</h2><p><strong>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">递归先序遍历树， 把结点加入路径。</span></span><br><span class="line"><span class="hljs-string">若该结点是叶子结点则比较当前路径和是否等于期待和。</span></span><br><span class="line"><span class="hljs-string">弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        support = [root]</span><br><span class="line">        supportArrayList = [[root.val]]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> support:</span><br><span class="line">            tmpNode = support[<span class="hljs-number">0</span>]</span><br><span class="line">            tmpArrayList = supportArrayList[<span class="hljs-number">0</span>]</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> tmpNode.right == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> sum(tmpArrayList) == expectNumber:</span><br><span class="line">                    ret.insert(<span class="hljs-number">0</span>, tmpArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left:</span><br><span class="line">                support.append(tmpNode.left)</span><br><span class="line">                newTmpArrayList = copy.copy(tmpArrayList)</span><br><span class="line">                newTmpArrayList.append(tmpNode.left.val)</span><br><span class="line">                supportArrayList.append(newTmpArrayList)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.right:</span><br><span class="line">                support.append(tmpNode.right)</span><br><span class="line">                newTmpArrayList = copy.copy(tmpArrayList)</span><br><span class="line">                newTmpArrayList.append(tmpNode.right.val)</span><br><span class="line">                supportArrayList.append(newTmpArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">del</span> supportArrayList[<span class="hljs-number">0</span>]</span><br><span class="line">            <span class="hljs-keyword">del</span> support[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPathMain</span><span class="hljs-params">(root, path, currentSum)</span>:</span></span><br><span class="line">            currentSum += root.val</span><br><span class="line"></span><br><span class="line">            path.append(root)</span><br><span class="line">            isLeaf = root.left == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> currentSum == expectNumber <span class="hljs-keyword">and</span> isLeaf:</span><br><span class="line">                onePath = []</span><br><span class="line">                <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> path:</span><br><span class="line">                    onePath.append(node.val)</span><br><span class="line">                result.append(onePath)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> currentSum &lt; expectNumber:</span><br><span class="line">                <span class="hljs-keyword">if</span> root.left:</span><br><span class="line">                    FindPathMain(root.left, path, currentSum)</span><br><span class="line">                <span class="hljs-keyword">if</span> root.right:</span><br><span class="line">                    FindPathMain(root.right, path, currentSum)</span><br><span class="line"></span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        FindPathMain(root, [], <span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h2 id="31-二叉搜索树与双向链表"><a href="#31-二叉搜索树与双向链表" class="headerlink" title="31.二叉搜索树与双向链表"></a>31.二叉搜索树与双向链表</h2><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Convert</span><span class="hljs-params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRootOfTree == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_right</span><span class="hljs-params">(node)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">while</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="hljs-keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        leftNode = self.Convert(pRootOfTree.left)</span><br><span class="line">        rightNode = self.Convert(pRootOfTree.right)</span><br><span class="line"></span><br><span class="line">        retNode = leftNode</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> leftNode:</span><br><span class="line">            leftNode = find_right(leftNode)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            retNode = pRootOfTree</span><br><span class="line"></span><br><span class="line">        pRootOfTree.left = leftNode</span><br><span class="line">        pRootOfTree.right = rightNode</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">None</span>:</span><br><span class="line">            leftNode.right = pRootOfTree</span><br><span class="line">        <span class="hljs-keyword">if</span> rightNode != <span class="hljs-literal">None</span>:</span><br><span class="line">            rightNode.left = pRootOfTree</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> retNode</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详细地分析剑指offer1-31题的解题思路，代码及代码注释。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="刷题笔记" scheme="http://www.cygao.xyz/tags/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MobileNetv1~v3,ShufflNet等轻量级网络</title>
    <link href="http://www.cygao.xyz/2019/07/12/lightweight/"/>
    <id>http://www.cygao.xyz/2019/07/12/lightweight/</id>
    <published>2019-07-12T11:45:33.000Z</published>
    <updated>2019-09-22T03:43:20.469Z</updated>
    
    <content type="html"><![CDATA[<p>直接搬运知乎高质量文章，通俗易懂。<br><a id="more"></a><br><a href="https://zhuanlan.zhihu.com/p/45496826" target="_blank" rel="noopener">轻量化神经网络综述</a> </p><p><a href="https://zhuanlan.zhihu.com/p/67009992" target="_blank" rel="noopener">轻量级神经网络“巡礼”（一）—— ShuffleNetV2</a> </p><p><a href="https://zhuanlan.zhihu.com/p/70703846" target="_blank" rel="noopener">轻量级神经网络“巡礼”（二）—— MobileNet，从V1到V3</a> </p><h2 id="MobileNet-v1"><a href="#MobileNet-v1" class="headerlink" title="MobileNet v1"></a>MobileNet v1</h2><ol><li>深度可分离卷积（Depthwise separable convolution）代替标准的卷积，并使用宽度因子(width multiply)减少参数量。深度可分离卷积把标准的卷积因式分解成一个深度卷积(depthwise convolution)和一个逐点卷积(pointwise convolution)。</li></ol><h2 id="MobileNet-v2"><a href="#MobileNet-v2" class="headerlink" title="MobileNet v2"></a>MobileNet v2</h2><ol><li>继续使用Mobilenet V1的深度可分离卷积降低卷积计算量。</li><li>增加skip connection，使前向传播时提供特征复用。</li><li>采用Inverted residual block结构。该结构使用Point wise convolution先对feature map进行升维，再在升维后的特征接ReLU，减少ReLU对特征的破坏。</li></ol><h2 id="MobileNet-v3"><a href="#MobileNet-v3" class="headerlink" title="MobileNet v3"></a>MobileNet v3</h2><ol><li>网络的架构基于NAS实现的MnasNet，神经结构搜索（NAS）</li><li>引入MobileNetV1的深度可分离卷积</li><li>引入MobileNetV2的具有线性瓶颈的倒残差结构</li><li>引入基于squeeze and excitation结构的轻量级注意力模型(SE)</li><li>使用了一种新的激活函数h-swish(x)</li></ol><h2 id="ShuffleNet-v1"><a href="#ShuffleNet-v1" class="headerlink" title="ShuffleNet v1"></a>ShuffleNet v1</h2><ol><li>Group convolution。其中输入特征通道被为G组(图4)，并且对于每个分组的信道独立地执行卷积，则分组卷积计算量是HWNK²M/G，为标准卷积计算量的1/G。</li><li>Channel shuffle。Grouped Convlution导致模型的信息流限制在各个group内，组与组之间没有信息交换，这会影响模型的表示能力。因此，需要引入group之间信息交换的机制，即Channel Shuffle操作。</li></ol><p>引入的问题：</p><ol><li>channel shuffle在工程实现占用大量内存和指针跳转，这部分很耗时。</li><li>channel shuffle的规则是人工设计，分组之间信息交流存在随意性，没有理论指导。</li></ol><h2 id="ShuffleNet-v2"><a href="#ShuffleNet-v2" class="headerlink" title="ShuffleNet v2"></a>ShuffleNet v2</h2><ol><li>channel split，通道分割将输入的feature maps分为两部分：一个分支为shortcut流，另一个分支含三个卷积（且三个分支的通道数一样）。分支合并采用拼接（concat），让前后的channel数相同，最后进行Channel Shuffle（完成和ShuffleNet V1一样的功能）。元素级的三个运算channel split、concat、Channel Shuffle合并一个Element-wise，显著降低计算复杂度。</li><li>仍采用Depthwise和Pointwise降低计算量。</li></ol><h2 id="ShuffleNet和MobileNet系列的异同"><a href="#ShuffleNet和MobileNet系列的异同" class="headerlink" title="ShuffleNet和MobileNet系列的异同"></a>ShuffleNet和MobileNet系列的异同</h2><p>手工设计轻量化模型主要得益于depth-wise convolution减少计算量，而解决信息不流畅的问题，MobileNet 系列采用了 point-wise convolution，ShuffleNet 采用的是 channel shuffle。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接搬运知乎高质量文章，通俗易懂。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>NMS算法（NonMaximumSuppression）</title>
    <link href="http://www.cygao.xyz/2019/07/05/nms/"/>
    <id>http://www.cygao.xyz/2019/07/05/nms/</id>
    <published>2019-07-05T01:58:02.000Z</published>
    <updated>2019-09-20T06:54:12.318Z</updated>
    
    <content type="html"><![CDATA[<p>NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。</p><a id="more"></a><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><hr><p>非极大值抑制（NMS）顾名思义就是抑制不是极大值的元素，搜索局部的极大值。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。这里不讨论通用的NMS算法，而是用于在目标检测中用于提取分数最高的窗口的。<br>例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si ,  1&lt;=i&lt;=N。</p><ol><li><p>建造一个存放待处理候选框的集合H，初始化为包含全部N个框；建造一个存放最优框的集合M，初始化为空集。</p></li><li><p>将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p></li><li><p>遍历集合 H 中的框，分别与框m计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m重叠，将此框从集合 H 中去除。</p></li><li><p>回到第2步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p></li></ol><h3 id="需要优化的参数"><a href="#需要优化的参数" class="headerlink" title="需要优化的参数"></a>需要优化的参数</h3><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。</p><hr><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">py_cpu_nms</span><span class="hljs-params">(dets, thresh)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""Pure Python NMS baseline."""</span></span><br><span class="line">    <span class="hljs-comment">#x1、y1、x2、y2、以及score赋值</span></span><br><span class="line">    x1 = dets[:, <span class="hljs-number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="hljs-number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="hljs-number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="hljs-number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="hljs-number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">#每一个检测框的面积</span></span><br><span class="line">    areas = (x2 - x1 + <span class="hljs-number">1</span>) * (y2 - y1 + <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-comment">#按照score置信度降序排序</span></span><br><span class="line">    order = scores.argsort()[::<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">    keep = [] <span class="hljs-comment">#保留的结果框集合</span></span><br><span class="line">    <span class="hljs-keyword">while</span> order.size &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        i = order[<span class="hljs-number">0</span>]</span><br><span class="line">        keep.append(i) <span class="hljs-comment">#保留该类剩余box中得分最高的一个</span></span><br><span class="line">        <span class="hljs-comment">#得到相交区域,左上及右下</span></span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="hljs-number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#计算相交的面积,不重叠时面积为0</span></span><br><span class="line">        w = np.maximum(<span class="hljs-number">0.0</span>, xx2 - xx1 + <span class="hljs-number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="hljs-number">0.0</span>, yy2 - yy1 + <span class="hljs-number">1</span>)</span><br><span class="line">        inter = w * h</span><br><span class="line">        <span class="hljs-comment">#计算IoU：重叠面积 /（面积1+面积2-重叠面积）</span></span><br><span class="line">        ovr = inter / (areas[i] + areas[order[<span class="hljs-number">1</span>:]] - inter)</span><br><span class="line">        <span class="hljs-comment">#保留IoU小于阈值的box</span></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="hljs-number">0</span>]</span><br><span class="line">        order = order[inds + <span class="hljs-number">1</span>] <span class="hljs-comment">#因为ovr数组的长度比order数组少一个,所以这里要将所有下标后移一位</span></span><br><span class="line">       </span><br><span class="line">    <span class="hljs-keyword">return</span> keep</span><br><span class="line">`</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="检测算法" scheme="http://www.cygao.xyz/tags/%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>手推GBDT和常见问题</title>
    <link href="http://www.cygao.xyz/2019/06/08/gbdt/"/>
    <id>http://www.cygao.xyz/2019/06/08/gbdt/</id>
    <published>2019-06-08T09:48:01.000Z</published>
    <updated>2019-09-20T06:51:25.775Z</updated>
    
    <content type="html"><![CDATA[<p>主要是手推算法。<br><a id="more"></a></p><h2 id="手推GBDT"><a href="#手推GBDT" class="headerlink" title="手推GBDT"></a>手推GBDT</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/gbdt.jpg" alt></div> <h2 id="GBDT中的CART回归树每个叶子结点的输出值是什么"><a href="#GBDT中的CART回归树每个叶子结点的输出值是什么" class="headerlink" title="GBDT中的CART回归树每个叶子结点的输出值是什么"></a>GBDT中的CART回归树每个叶子结点的输出值是什么</h2><ol><li>对于分类树，其输出变量的众数就是分类结果。</li><li>对于回归树，其输出变量的平均值就是预测结果。​</li></ol><h2 id="GDBT的GB是什么意思，如何体现？"><a href="#GDBT的GB是什么意思，如何体现？" class="headerlink" title="GDBT的GB是什么意思，如何体现？"></a>GDBT的GB是什么意思，如何体现？</h2><p><strong>Gradient Boosting</strong><br>Boosting是一种可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴，</p><p>Gradient Boosting是一种实现Boosting的方法，它的主要思想是，每一次建立模型，是在之前建立模型损失函数的梯度下降方向。损失函数描述的是模型的不靠谱程度，损失函数越大，说明模型越容易出错。如果我们的模型能够让损失函数持续的下降，说明我们的模型在不停的改进，而最好的方式就是让损失函数在其梯度的方向下降。</p><h2 id="介绍一下GBDT的原理和推导"><a href="#介绍一下GBDT的原理和推导" class="headerlink" title="介绍一下GBDT的原理和推导"></a>介绍一下GBDT的原理和推导</h2><p>见手推GBDT</p><h2 id="GBDT是回归树还是分类树"><a href="#GBDT是回归树还是分类树" class="headerlink" title="GBDT是回归树还是分类树"></a>GBDT是回归树还是分类树</h2><p>CART决策树既可以用于分类也可以用于回归，决策树分为分类树和回归树，分类树的衡量标准是最大熵，回归树的衡量标准是最小化均方差，所以<strong>GBDT中的树都是回归树，不是分类树</strong>.<br><strong>回归树！！！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是手推算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>主成分分析PCA原理和执行步骤</title>
    <link href="http://www.cygao.xyz/2019/06/05/pca/"/>
    <id>http://www.cygao.xyz/2019/06/05/pca/</id>
    <published>2019-06-05T02:27:21.000Z</published>
    <updated>2019-09-20T06:54:05.795Z</updated>
    
    <content type="html"><![CDATA[<p>主成分分析（PCA）特征选择算法简介，包含适用场景。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PCA全称Principal Component Analysis，即主成分分析，是一种常用的数据降维方法。它可以通过<strong>线性变换</strong>将原始数据变换为一组各维度<strong>线性无关</strong>的表示，以此来提取数据的<strong>主要线性分量</strong>。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>我们在处理实际问题的时候，进行特征提取过程中，提取的特征维数太多经常会导致特征匹配时过于复杂，消耗计算资源。</p><hr><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><hr><ol><li>线性变换=&gt;新特征轴可由原始特征轴线性变换表征</li><li>线性无关=&gt;构建的特征轴是正交的</li><li>主要线性分量（或者说是主成分）=&gt;方差加大的方向</li><li>PCA算法的求解就是找到主要线性分量及其表征方式的过程</li></ol><hr><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>假设有m个样例，n维特征</p><ol><li>对每一维特征进行零均值化，即减去均值</li><li>再求特征协方差矩阵</li><li>求改协方差矩阵的特征值和特征向量</li><li>将特征值按照从大到小的顺序排序，并选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</li><li>将样本点投影到选取的特征向量上，假设有m个样例，n维特征，零均值化后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为:</li></ol><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/pca.png" alt></div> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主成分分析（PCA）特征选择算法简介，包含适用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Valse笔记「浓缩的都是精华」之网络压缩</title>
    <link href="http://www.cygao.xyz/2019/05/19/compression/"/>
    <id>http://www.cygao.xyz/2019/05/19/compression/</id>
    <published>2019-05-19T08:21:45.000Z</published>
    <updated>2019-09-20T06:51:06.490Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://valser.org/webinar/slide/slides/20190911/2019.9.11-神经网络量化压缩%EF%BC%9A从算法到芯片-webinar.pdf" target="_blank" rel="noopener">程建老师的PPT</a></p><p><a href="http://valser.org/webinar/slide/slides/20190911/2019.9.11-valse_DNN%20compression.pdf" target="_blank" rel="noopener">林绍辉老师的PPT</a><br><a id="more"></a></p><h2 id="DNN-compression-and-acceleration"><a href="#DNN-compression-and-acceleration" class="headerlink" title="DNN compression and acceleration"></a>DNN compression and acceleration</h2><h3 id="5-main-groups"><a href="#5-main-groups" class="headerlink" title="5 main groups"></a>5 main groups</h3><ul><li>Parameter pruning</li><li>Parameter sharing</li><li>Low-rank decomposition</li><li>Compact network design</li><li>Knowledge distillation<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3></li><li>FFT、DCT</li><li>Winograd </li><li>Neural architecure search </li></ul><h2 id="Parameter-pruning"><a href="#Parameter-pruning" class="headerlink" title="Parameter pruning"></a>Parameter pruning</h2><ol><li>Fine-grained</li><li>Vector-level</li><li>Kernel-level</li><li>Filter-level</li><li>Group-level</li></ol><h2 id="基于量化学习的模型压缩表示"><a href="#基于量化学习的模型压缩表示" class="headerlink" title="基于量化学习的模型压缩表示"></a>基于量化学习的模型压缩表示</h2><ol><li>基于哈希的二值量化方法，二值权重-1或1。</li></ol><p>Qinghao Hu, Peisong Wang, Jian Cheng. From Hashing to CNNs: Training Binary Weight Networks via Hashing. AAAI 2018</p><ol start="2"><li>基于三值定点量化方法。<br>提出一种定点分解网络（FFN），把CNN网络权重量化成[-1,0,1]，从<br>而把乘法计算转变成加法，有效提高网络inference速度。</li></ol><p>Peisong Wang and Jian Cheng, “Fixed-point Factorized Networks”. CVPR 2017</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://valser.org/webinar/slide/slides/20190911/2019.9.11-神经网络量化压缩%EF%BC%9A从算法到芯片-webinar.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;程建老师的PPT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://valser.org/webinar/slide/slides/20190911/2019.9.11-valse_DNN%20compression.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;林绍辉老师的PPT&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="valse" scheme="http://www.cygao.xyz/categories/valse/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手推SVM及常见面试问题</title>
    <link href="http://www.cygao.xyz/2019/05/07/svm/"/>
    <id>http://www.cygao.xyz/2019/05/07/svm/</id>
    <published>2019-05-07T11:45:39.000Z</published>
    <updated>2019-09-24T11:47:10.611Z</updated>
    
    <content type="html"><![CDATA[<p>面试必备<br><a id="more"></a></p><h2 id="1、手推SVM"><a href="#1、手推SVM" class="headerlink" title="1、手推SVM"></a>1、手推SVM</h2><p>差不多这个程度应该够了。</p><div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm1.jpg"></div>  <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm2.jpg"></div>  <h2 id="2、SVM为什么叫支持向量机"><a href="#2、SVM为什么叫支持向量机" class="headerlink" title="2、SVM为什么叫支持向量机"></a>2、SVM为什么叫支持向量机</h2><p>这个名字是强调了此类学习器的关键是如何从支持向量构建出解；同时也暗示了其复杂度主要与支持向量的数目有关。</p><h2 id="3、SVM的损失函数（求导省略了）"><a href="#3、SVM的损失函数（求导省略了）" class="headerlink" title="3、SVM的损失函数（求导省略了）"></a>3、SVM的损失函数（求导省略了）</h2><div align="center"><br><img width="400" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm4.png"><br></div> <h2 id="4、核函数了解哪些，为什么要用核函数"><a href="#4、核函数了解哪些，为什么要用核函数" class="headerlink" title="4、核函数了解哪些，为什么要用核函数"></a>4、核函数了解哪些，为什么要用核函数</h2><p>当样本在原始空间线性不可分时，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。</p><div align="center"><br><img width="400" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm3.jpg"><br></div> <ol><li><p>线性核，主要用于线性可分的情况，我们可以看到特征空间到输入空间的维度是一样的，其参数少速度快，对于线性可分数据，其分类效果很理想，因此我们通常首先尝试用线性核函数来做分类，看看效果如何，如果不行再换别的。</p></li><li><p>多项式核函数可以实现将低维的输入空间映射到高纬的特征空间，但是多项式核函数的参数多，当多项式的阶数比较高的时候，核矩阵的元素值将趋于无穷大或者无穷小，计算复杂度会大到无法计算。</p></li><li><p>高斯（RBF）核函数 是一种局部性强的核函数，其可以将一个样本映射到一个更高维的空间内，该核函数是应用最广的一个，无论大样本还是小样本都有比较好的性能，而且其相对于多项式核函数参数要少，因此大多数情况下在不知道用什么核函数的时候，优先使用高斯核函数。</p></li><li><p>采用sigmoid核函数，支持向量机实现的就是一种多层神经网络。<br>因此，在选用核函数的时候，如果我们对我们的数据有一定的先验知识，就利用先验来选择符合数据分布的核函数；如果不知道的话，通常使用交叉验证的方法，来试用不同的核函数，误差最下的即为效果最好的核函数，或者也可以将多个核函数结合起来，形成混合核函数。在吴恩达的课上，也曾经给出过一系列的选择核函数的方法.</p></li></ol><p><strong><em>如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；<br>如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；<br>如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况。</em></strong></p><h2 id="5、为什么要将求解SVM的原始问题转换为其对偶问题？"><a href="#5、为什么要将求解SVM的原始问题转换为其对偶问题？" class="headerlink" title="5、为什么要将求解SVM的原始问题转换为其对偶问题？"></a>5、为什么要将求解SVM的原始问题转换为其对偶问题？</h2><ol><li>是对偶问题往往更易求解（当我们寻找约束存在时的最优点的时候，约束的存在虽然减小了需要搜寻的范围，但是却使问题变得更加复杂。为了使问题变得易于处理，<strong>把目标函数和约束全部融入一个新的函数，即拉格朗日函数，再通过这个函数来寻找最优点。</strong>）</li><li>自然引入核函数，进而推广到非线性分类问题。</li></ol><h2 id="6、SVM为什么可以处理非线性问题"><a href="#6、SVM为什么可以处理非线性问题" class="headerlink" title="6、SVM为什么可以处理非线性问题"></a>6、SVM为什么可以处理非线性问题</h2><p>非线性的话通过核函数将其隐射到高维空间，在高维空间非线性问题转化为线性问题。 </p><h2 id="LR-与-SVM的区别"><a href="#LR-与-SVM的区别" class="headerlink" title="LR 与 SVM的区别"></a>LR 与 SVM的区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>LR和SVM都是分类算法。</li><li>如果不考虑核函数，LR和SVM都是线性分类算法，也就是说他们的分类决策面都是线性的。</li><li>LR和SVM都是监督学习算法。</li><li>LR和SVM都是判别模型。<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3></li><li>本质上是其损失函数（loss function）不同。lr的损失函数是 cross entropy loss。svm是hinge loss。</li><li>支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局（远离的点对边界线的确定也起作用）。</li><li>在解决非线性问题时，支持向量机采用核函数的机制，而LR通常不采用核函数的方法。</li><li>​线性SVM依赖数据表达的距离测度，所以需要对数据先做normalization，LR不受其影响。一个基于概率，一个基于距离！​</li><li>第五，SVM的损失函数就自带正则！！！（损失函数中的1/2||w||^2项），这就是为什么SVM是结构风险最小化算法的原因！！！而LR必须另外在损失函数上添加正则项！！！</li></ol><h4 id="机器学习中的各种损失函数（Hinge-loss，交叉熵，softmax）"><a href="#机器学习中的各种损失函数（Hinge-loss，交叉熵，softmax）" class="headerlink" title="机器学习中的各种损失函数（Hinge loss，交叉熵，softmax）"></a>机器学习中的各种损失函数（Hinge loss，交叉熵，softmax）</h4><p><a href="https://blog.csdn.net/edogawachia/article/details/80052884" target="_blank" rel="noopener">参考博客</a>，尤其是不熟悉的hinge loss。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>周志华的<br>《机器学习》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试必备&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
