<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy的学习日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cygao.xyz/"/>
  <updated>2019-09-19T08:57:29.452Z</updated>
  <id>http://www.cygao.xyz/</id>
  
  <author>
    <name>Cunyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Valse笔记「浓缩的都是精华」之网络压缩</title>
    <link href="http://www.cygao.xyz/2019/09/19/compression/"/>
    <id>http://www.cygao.xyz/2019/09/19/compression/</id>
    <published>2019-09-19T08:21:45.000Z</published>
    <updated>2019-09-19T08:57:29.452Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://valser.org/webinar/slide/slides/20190911/2019.9.11-神经网络量化压缩%EF%BC%9A从算法到芯片-webinar.pdf" target="_blank" rel="noopener">程建老师的PPT</a></p><p><a href="http://valser.org/webinar/slide/slides/20190911/2019.9.11-valse_DNN%20compression.pdf" target="_blank" rel="noopener">林绍辉老师的PPT</a></p><h2 id="DNN-compression-and-acceleration"><a href="#DNN-compression-and-acceleration" class="headerlink" title="DNN compression and acceleration"></a>DNN compression and acceleration</h2><h3 id="5-main-groups"><a href="#5-main-groups" class="headerlink" title="5 main groups"></a>5 main groups</h3><ul><li>Parameter pruning</li><li>Parameter sharing</li><li>Low-rank decomposition</li><li>Compact network design</li><li>Knowledge distillation<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3></li><li>FFT、DCT</li><li>Winograd </li><li>Neural architecure search </li></ul><h2 id="Parameter-pruning"><a href="#Parameter-pruning" class="headerlink" title="Parameter pruning"></a>Parameter pruning</h2><ol><li>Fine-grained</li><li>Vector-level</li><li>Kernel-level</li><li>Filter-level</li><li>Group-level</li></ol><h2 id="基于量化学习的模型压缩表示"><a href="#基于量化学习的模型压缩表示" class="headerlink" title="基于量化学习的模型压缩表示"></a>基于量化学习的模型压缩表示</h2><ol><li>基于哈希的二值量化方法，二值权重-1或1。</li></ol><p>Qinghao Hu, Peisong Wang, Jian Cheng. From Hashing to CNNs: Training Binary Weight Networks via Hashing. AAAI 2018</p><ol start="2"><li>基于三值定点量化方法。<br>提出一种定点分解网络（FFN），把CNN网络权重量化成[-1,0,1]，从<br>而把乘法计算转变成加法，有效提高网络inference速度。</li></ol><p>Peisong Wang and Jian Cheng, “Fixed-point Factorized Networks”. CVPR 2017</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://valser.org/webinar/slide/slides/20190911/2019.9.11-神经网络量化压缩%EF%BC%9A从算法到芯片-webinar.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;程建
      
    
    </summary>
    
      <category term="valse" scheme="http://www.cygao.xyz/categories/valse/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>经典卷积神经网络总结</title>
    <link href="http://www.cygao.xyz/2019/09/15/networks/"/>
    <id>http://www.cygao.xyz/2019/09/15/networks/</id>
    <published>2019-09-15T11:42:08.000Z</published>
    <updated>2019-09-15T12:20:37.025Z</updated>
    
    <content type="html"><![CDATA[<p>Inception v1\v2\v3\v4、ResNet、ResNext、DenseNet、SENet，详解其中的部分。<br><a id="more"></a></p><p><a href="https://blog.csdn.net/liuxiao214/article/details/81914743" target="_blank" rel="noopener">经典卷积神经网络总结：Inception v1\v2\v3\v4、ResNet、ResNext、DenseNet、SENet等</a></p><p><a href="https://blog.csdn.net/u014380165/article/details/71667916" target="_blank" rel="noopener">ResNeXt算法详解</a></p><p><a href="https://blog.csdn.net/wangkun1340378/article/details/79092001" target="_blank" rel="noopener">SENet详解</a></p><p><a href="https://blog.csdn.net/u014380165/article/details/75142664" target="_blank" rel="noopener">DenseNet算法详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Inception v1\v2\v3\v4、ResNet、ResNext、DenseNet、SENet，详解其中的部分。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MobileNetv1~v3,ShufflNet等轻量级网络</title>
    <link href="http://www.cygao.xyz/2019/09/12/lightweight/"/>
    <id>http://www.cygao.xyz/2019/09/12/lightweight/</id>
    <published>2019-09-12T11:45:33.000Z</published>
    <updated>2019-09-12T14:02:22.257Z</updated>
    
    <content type="html"><![CDATA[<p>直接搬运知乎高质量文章，通俗易懂。<br><a id="more"></a><br><a href="https://zhuanlan.zhihu.com/p/45496826" target="_blank" rel="noopener">轻量化神经网络综述</a> </p><p><a href="https://zhuanlan.zhihu.com/p/67009992" target="_blank" rel="noopener">轻量级神经网络“巡礼”（一）—— ShuffleNetV2</a> </p><p><a href="https://zhuanlan.zhihu.com/p/70703846" target="_blank" rel="noopener">轻量级神经网络“巡礼”（二）—— MobileNet，从V1到V3</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接搬运知乎高质量文章，通俗易懂。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv1到v3相关</title>
    <link href="http://www.cygao.xyz/2019/09/12/yolo/"/>
    <id>http://www.cygao.xyz/2019/09/12/yolo/</id>
    <published>2019-09-12T01:16:05.000Z</published>
    <updated>2019-09-15T11:42:22.755Z</updated>
    
    <content type="html"><![CDATA[<p>懒得搬运了，直接贴原博客地址。</p><a id="more"></a><h1 id="详解YOLOv1到YOLOv3"><a href="#详解YOLOv1到YOLOv3" class="headerlink" title="详解YOLOv1到YOLOv3"></a>详解YOLOv1到YOLOv3</h1><p><a href="https://blog.csdn.net/guleileo/article/details/80581858" target="_blank" rel="noopener">从YOLOv1到YOLOv3，目标检测的进化之路</a> </p><p><a href="https://blog.csdn.net/calvinpaean/article/details/84820323" target="_blank" rel="noopener">YOLOv1到YOLOv3之比较</a> </p><h1 id="YOLOv3的损失函数"><a href="#YOLOv3的损失函数" class="headerlink" title="YOLOv3的损失函数"></a>YOLOv3的损失函数</h1><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/yolo.png" alt></div> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;懒得搬运了，直接贴原博客地址。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://www.cygao.xyz/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux的个人向常用操作</title>
    <link href="http://www.cygao.xyz/2019/09/10/linux/"/>
    <id>http://www.cygao.xyz/2019/09/10/linux/</id>
    <published>2019-09-10T06:46:44.000Z</published>
    <updated>2019-09-11T10:02:54.513Z</updated>
    
    <content type="html"><![CDATA[<p>纯个人向认为比较重要的，需要熟记。<br><a id="more"></a></p><h2 id="四种通配符："><a href="#四种通配符：" class="headerlink" title="四种通配符："></a>四种通配符：</h2><ol><li>*可以匹配0个或多个任意字符</li><li>？只可以匹配单个字符，但是例如 rm a.*，可以匹配a.jpg，a.txt</li><li>[] 匹配一组单个字符，例如[12]匹配1或2，不匹配12；或者使用连字符分隔一定范围内的字符，例如[1-3]，它匹配1、2或3</li><li>{} 进行两种匹配：字符串和范围。如果用字符串必须用逗号分隔。比如 ls a.{jpg,txt}匹配 a.jpg和a.txt；ls {a,b}.jpg 匹配a.jpg和b.jpg。可以用 mkdir{a,b,c}快速创建多个目录。</li></ol><h2 id="clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。"><a href="#clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。" class="headerlink" title="clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。"></a>clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。</h2><h2 id="ls及其衍生"><a href="#ls及其衍生" class="headerlink" title="ls及其衍生"></a>ls及其衍生</h2><ol><li>ls -R Documents/ 查看该文件夹中的所有文件列表</li><li>比较常用 -l，显示内容列表</li><li>-a查看隐藏文件和文件夹</li><li>-l是默认字母排序 -r倒叙排列，可以搭配-lr，不实用</li><li>-S按照文件大小，可以搭配-laS</li><li>-h人性化显示文件大小，做常用的是-lh</li></ol><h2 id="cd及其衍生"><a href="#cd及其衍生" class="headerlink" title="cd及其衍生"></a>cd及其衍生</h2><ol><li>cd - 改为之前目录</li></ol><h2 id="touch创建空文件，mkdir创建空目录"><a href="#touch创建空文件，mkdir创建空目录" class="headerlink" title="touch创建空文件，mkdir创建空目录"></a>touch创建空文件，mkdir创建空目录</h2><h2 id="cp-源文件-目标文件"><a href="#cp-源文件-目标文件" class="headerlink" title="cp 源文件 目标文件"></a>cp 源文件 目标文件</h2><ol><li>搭配 . 当前目录</li><li>搭配四种通配符</li><li>-v 显示复制文件的过程</li><li>-i 防止在复制时覆盖重要文件</li><li>-r 复制文件夹</li><li>-a等价于-dpr，可以确保备份时不会复制软连接的内容（这可能极大地增加复制量），只保留关键地文件属性（如所有者，时间戳），并递归处理子目录</li></ol><h2 id="mv-源文件-目标文件"><a href="#mv-源文件-目标文件" class="headerlink" title="mv 源文件 目标文件"></a>mv 源文件 目标文件</h2><ol><li>-v,-i,-r等同于cp</li><li>可以用来重命名文件或文件夹</li><li><strong>移动软连接时，例如dogs为~底下的软连接，指向/home/my/pictures/dogs，而现在要将这个链接移动到/home/my/libby下。一下命令只移动软连接：</strong><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv dogs ~/libby</span><br></pre></td></tr></table></figure></li></ol><p><strong>然而，下面的命令移动的时软连接指向的目录：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv dogs/ ~/libby</span><br></pre></td></tr></table></figure></p><p><strong>多了一个”/“！！！</strong></p><h2 id="ln-要链接的文件-硬链接名"><a href="#ln-要链接的文件-硬链接名" class="headerlink" title="ln 要链接的文件 硬链接名"></a>ln 要链接的文件 硬链接名</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxr--r-- 2 root root 4096 abc/</span><br></pre></td></tr></table></figure><p>此处abc为目录，则2代表其下有多少子目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-rw-r--r-- 1 root root a.txt</span><br><span class="line">$ ln a.txt b.txt</span><br><span class="line">$ ls -l</span><br><span class="line">-rw-r--r-- 2 root root a.txt</span><br><span class="line">-rw-r--r-- 2 root root b.txt</span><br></pre></td></tr></table></figure><p>此处1变成2，显示了该文件有多少硬链接。<br>使用 ls -i还会发现其索引号时相同的。a.txt和b.txt内容时一致的，实际在处理同一的数据。</p><p>硬链接的限制：无法指向目录，硬链接和源文件必须处于同一文件系统，因为每个分区都有各自的索引节点。</p><p>使用软连接<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s 源文件 连接名称</span><br></pre></td></tr></table></figure></p><p>硬链接索引节点相同，但软连接不同，因为他们是完全不同的文件。</p><h2 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h2><ol><li>搭配通配符</li><li>-i 提示功能，确认删除</li><li>-rf -r指的是递归每个子目录，删除所有文件，-f直接删除。</li></ol><h2 id="man-有问题找那个男人"><a href="#man-有问题找那个男人" class="headerlink" title="man 有问题找那个男人"></a>man 有问题找那个男人</h2><ol><li>man ls查看ls及其option</li><li>man -f ls 简单查看这个命令的说明</li><li>whatis ls 也是简单查看</li></ol><h2 id="info-查询手册，内容有点乱"><a href="#info-查询手册，内容有点乱" class="headerlink" title="info 查询手册，内容有点乱"></a>info 查询手册，内容有点乱</h2><h2 id="whereis-查找命令的可执行文件、源文件和手册页面的路径"><a href="#whereis-查找命令的可执行文件、源文件和手册页面的路径" class="headerlink" title="whereis 查找命令的可执行文件、源文件和手册页面的路径"></a>whereis 查找命令的可执行文件、源文件和手册页面的路径</h2><p>报告的顺序是:源文件位置–&gt;任何二进制可执行文件的位置–&gt;最后找到的是手册页面的位置。</p><ul><li>只想搜索二进制文件路径 -b whereis -b gcc</li><li>只想搜索手册页面路径 -m whereis -m ls</li><li>只想搜索源路径 -s whereis -s gcc</li></ul><p>非常好用的方法！！！一定得记住！！！</p><h2 id="which-找出将要运行的命令的版本"><a href="#which-找出将要运行的命令的版本" class="headerlink" title="which 找出将要运行的命令的版本"></a>which 找出将要运行的命令的版本</h2><p>比如gcc有多个版本，当前使用的哪个版本会先运行，即whereis -b gcc时发现有多个可执行文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which gcc</span><br></pre></td></tr></table></figure></p><p>同时也是快速判断系统是否有改特定命令的方法。</p><h2 id="type-揭示shell是如何解释命令"><a href="#type-揭示shell是如何解释命令" class="headerlink" title="type 揭示shell是如何解释命令"></a>type 揭示shell是如何解释命令</h2><p>不是常用命令，但如果想知道为什么命令没有按照预期的方式执行操作，type可以帮助你了解到问题所在。</p><h2 id="连续运行多个命令"><a href="#连续运行多个命令" class="headerlink" title="; 连续运行多个命令"></a>; 连续运行多个命令</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd a ;cd ..</span><br></pre></td></tr></table></figure><p>又回到了原目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3;</span><br><span class="line">``` </span><br><span class="line">会等待延迟3秒钟。</span><br><span class="line"></span><br><span class="line">## &amp;&amp; 仅在前面的命令成功运行时才运行下一条命令</span><br></pre></td></tr></table></figure><p>$ cd a &amp;&amp; cd ..<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最好还是用&amp;&amp;，这要处理更加安全。</span><br><span class="line"></span><br><span class="line">## || 仅在前面的命令运行失败时，才运行下一条命令</span><br><span class="line"></span><br><span class="line">## $() 将一条命令的输出插入另一条命令</span><br></pre></td></tr></table></figure></p><p>$ date “+%Y-%m-%d”</p><blockquote><blockquote><p>2019-9-10<br>$ mkdir $(date “+%Y-%m-%d”)<br>2019-9-10/ #创建了日期命名的目录<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个是极为强大的功能，无处不在。</span><br><span class="line"></span><br><span class="line">## | 将一条命令的输出用作另外一条命令的输入</span><br><span class="line">```linux</span><br><span class="line">$ ps ux | grep firefox</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><h2 id="gt-将命令的输出重定向到文件"><a href="#gt-将命令的输出重定向到文件" class="headerlink" title="&gt; 将命令的输出重定向到文件"></a>&gt; 将命令的输出重定向到文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l abc/ &gt; a.txt</span><br><span class="line">$ cat a.txt</span><br><span class="line"># abc目录下的文件</span><br></pre></td></tr></table></figure><p>若文件a.txt不存在则会被创建，已存在则会被完全覆盖。所以使用重定向要十分谨慎。</p><h2 id="gt-gt-将命令的输出追加到文件中"><a href="#gt-gt-将命令的输出追加到文件中" class="headerlink" title="&gt;&gt; 将命令的输出追加到文件中"></a>&gt;&gt; 将命令的输出追加到文件中</h2><p>如果文件不存在，会创建新的文件；<br>但是，如果使用 &gt;&gt; 代替 &gt;，就会把输出追加到指定文件按的结尾。</p><p><strong>如果无意间输入 &gt; ，就不是追加了，而是覆盖了。</strong></p><h2 id="lt-将文件用作命令的输入"><a href="#lt-将文件用作命令的输入" class="headerlink" title="&lt; 将文件用作命令的输入"></a>&lt; 将文件用作命令的输入</h2><p>不常用，举例<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tr &apos;A-Z&apos; &apos;a-z&apos; &lt; commands.txt</span><br></pre></td></tr></table></figure></p><p>将txt用于输入，tr用来进行处理。</p><h2 id="结合使用输入和输出重定向"><a href="#结合使用输入和输出重定向" class="headerlink" title="结合使用输入和输出重定向"></a>结合使用输入和输出重定向</h2><p>[command] &lt; [file] &gt;[output]<br>了解一下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tr &apos;A-Z&apos; &apos;a-z&apos; &lt; commands.txt &gt; a.txt</span><br></pre></td></tr></table></figure></p><p>tr处理后的commands.txt的内容输出到a.txt</p><h2 id="tee-将输出同时发送到文件和stdout"><a href="#tee-将输出同时发送到文件和stdout" class="headerlink" title="tee 将输出同时发送到文件和stdout"></a>tee 将输出同时发送到文件和stdout</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l a/ | tee b.txt</span><br></pre></td></tr></table></figure><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><ol><li>查看文件</li><li>拼接文件至标准输出设备 cat file1 file2</li><li>拼接文件到其他文件 cat file1 file2 &gt; file3</li><li>追加到其他文件上 cat file1 &gt;&gt; file2</li><li>拼接文件并显示行号 cat -n file1 file2</li></ol><h2 id="less-逐屏查看文本文件"><a href="#less-逐屏查看文本文件" class="headerlink" title="less 逐屏查看文本文件"></a>less 逐屏查看文本文件</h2><ol><li>PageDn、e或空格键 前进一页</li><li>PageUp或b 后退一页</li><li>上下箭头对应 前进和后退一行</li><li>Q 退出</li></ol><h2 id="head-查看文件前十行"><a href="#head-查看文件前十行" class="headerlink" title="head 查看文件前十行"></a>head 查看文件前十行</h2><ol><li>head file1 file2也可以查看多个文件的前十行内容。</li><li>head -n 5 file1 只看前五行</li></ol><h2 id="tail-查看最后十行"><a href="#tail-查看最后十行" class="headerlink" title="tail 查看最后十行"></a>tail 查看最后十行</h2><p>大部分与head相同</p><ol><li>tail -f 查看一个或多个文件中经常更新的最后几行内容。</li></ol><h2 id="wc-计算文件中的单词数，行数和字符数"><a href="#wc-计算文件中的单词数，行数和字符数" class="headerlink" title="wc 计算文件中的单词数，行数和字符数"></a>wc 计算文件中的单词数，行数和字符数</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wc a.txt</span><br><span class="line">&gt;&gt; 192 11134 70923 a.txt</span><br></pre></td></tr></table></figure><p>按顺序给出了行数、单词数和字符数。</p><ol><li>-l -w -m 分别对应行数、单词数和字符数。</li></ol><p>更重要的是理解这是一个<strong>过滤器</strong>。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep JerkyJerks sever_access.log | wc -l</span><br><span class="line">&gt;&gt; 11542</span><br></pre></td></tr></table></figure></p><p>使用wc -l来计算这些网络黑客对计算机攻击了多少次。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep [/]usr/bin.cronolog | wc -l</span><br><span class="line">&gt;&gt; 83</span><br></pre></td></tr></table></figure></p><p>多少个cronolog实例征在运行。</p><h2 id="nl对文件中的行进行编号"><a href="#nl对文件中的行进行编号" class="headerlink" title="nl对文件中的行进行编号"></a>nl对文件中的行进行编号</h2><ol><li>nl a.txt 不给空行编号</li><li>nl -b a a.txt 也会给空行进行编号</li></ol><h2 id="cut-选择分隔文件中的整列数据"><a href="#cut-选择分隔文件中的整列数据" class="headerlink" title="cut 选择分隔文件中的整列数据"></a>cut 选择分隔文件中的整列数据</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -f 1,3 a.txt</span><br></pre></td></tr></table></figure><p>提取数据的第一列和第三列<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo wu.images.ccc.com | cut -d &apos;.&apos; -f 2-4</span><br><span class="line">&gt;&gt; images.ccc.com</span><br></pre></td></tr></table></figure></p><h2 id="sort-排序文件中的内容"><a href="#sort-排序文件中的内容" class="headerlink" title="sort 排序文件中的内容"></a>sort 排序文件中的内容</h2><h2 id="uniq-删除文件中重复的行"><a href="#uniq-删除文件中重复的行" class="headerlink" title="uniq 删除文件中重复的行"></a>uniq 删除文件中重复的行</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history | awl &apos;&#123;print $2&#125;&apos;| uniq</span><br></pre></td></tr></table></figure><p>删除重复的命令</p><h2 id="tr-使用其他字符替换选择的字符"><a href="#tr-使用其他字符替换选择的字符" class="headerlink" title="tr 使用其他字符替换选择的字符"></a>tr 使用其他字符替换选择的字符</h2><ol><li>tr -s 使用单个实例替换重复的字符</li><li>tr -d 删除匹配的字符</li></ol><h2 id="sed-转变文件中的文本"><a href="#sed-转变文件中的文本" class="headerlink" title="sed 转变文件中的文本"></a>sed 转变文件中的文本</h2><p>搭配正则表达式，功能强大，stream editor的简写</p><h2 id="awk-打印文件中的特定字段"><a href="#awk-打印文件中的特定字段" class="headerlink" title="awk 打印文件中的特定字段"></a>awk 打印文件中的特定字段</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h | awk &apos;NR&gt;1 &#123;print $6 &quot;has&quot; $4 &quot; of &quot; $2 &quot;left&#125;&apos;</span><br></pre></td></tr></table></figure><p>df -h可以显示计算机上文件系统的磁盘使用情况，NR&gt;1告诉awk跳过第一行。</p><h2 id="su-username-切换用户"><a href="#su-username-切换用户" class="headerlink" title="su username 切换用户"></a>su username 切换用户</h2><h2 id="su-成为root用户"><a href="#su-成为root用户" class="headerlink" title="su 成为root用户"></a>su 成为root用户</h2><p>whoami可以查看当前用户名称</p><h2 id="su-成为root用户并使用其环境变量"><a href="#su-成为root用户并使用其环境变量" class="headerlink" title="su - 成为root用户并使用其环境变量"></a>su - 成为root用户并使用其环境变量</h2><p>只是用su，可以拥有root用户的权限，但是在后台，非root用户环境变量仍然在起作用。所以需要使用su -</p><h2 id="chgrp-更改用户或目录所属用户组"><a href="#chgrp-更改用户或目录所属用户组" class="headerlink" title="chgrp 更改用户或目录所属用户组"></a>chgrp 更改用户或目录所属用户组</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chgrp admins a.sh</span><br></pre></td></tr></table></figure><p>使用 cat/etc/group 查看用户组的情况。</p><ol><li>-R 递归更改目录所属的用户组</li></ol><h2 id="chown-更改文件和目录的拥有者"><a href="#chown-更改文件和目录的拥有者" class="headerlink" title="chown 更改文件和目录的拥有者"></a>chown 更改文件和目录的拥有者</h2><p>只有root用户，或使用sudo拥有root身份的用户，才可以更改文件的拥有者。</p><ol><li>-R 同样可以递归</li></ol><h2 id="chown-owner-group-同时更改文件和目录的拥有者和用户组"><a href="#chown-owner-group-同时更改文件和目录的拥有者和用户组" class="headerlink" title="chown owner:group  同时更改文件和目录的拥有者和用户组"></a>chown owner:group  同时更改文件和目录的拥有者和用户组</h2><p>root用户可以一直能够对任何文件或目录进行任意操作</p><h2 id="chmod-修改文件和目录的权限"><a href="#chmod-修改文件和目录的权限" class="headerlink" title="chmod 修改文件和目录的权限"></a>chmod 修改文件和目录的权限</h2><ol><li>chmod [ugo][+-=][rwx] </li><li>chmod a[+-=][rwx]影响所有用户组</li><li>-R 递归地修改全年</li></ol><h2 id="suid-设置和清除"><a href="#suid-设置和清除" class="headerlink" title="suid 设置和清除"></a>suid 设置和清除</h2><ol><li>chmod u[+-]s 设置和清除，用户就可以使用拥有者的权限执行这个文件。</li></ol><h2 id="zip-压缩文件"><a href="#zip-压缩文件" class="headerlink" title="zip 压缩文件"></a>zip 压缩文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip 压缩后的文件名.zip 需要压缩的文件</span><br></pre></td></tr></table></figure><ol><li><p>zip -[0-9]，-9获得的压缩率最大</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -9 mo.zip *.txt</span><br></pre></td></tr></table></figure></li><li><p>-P和-e 可以用密码来保护压缩的zip文档。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zip -P 123 mo.zip *.txt</span><br><span class="line">$ zip -e  mo.zip *.txt</span><br></pre></td></tr></table></figure></li></ol><p>-e 密码不可见，不会存在shell事件的历史记录之中。</p><h2 id="unzip解压缩文件"><a href="#unzip解压缩文件" class="headerlink" title="unzip解压缩文件"></a>unzip解压缩文件</h2><ol><li>unzip -t 测试将要解压缩的文件。因为有时候zip压缩文档会损毁，最好在解压缩之前，都进行一次测试。</li></ol><h2 id="gzip-归档和压缩文件"><a href="#gzip-归档和压缩文件" class="headerlink" title="gzip 归档和压缩文件"></a>gzip 归档和压缩文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gzip a.txt</span><br><span class="line">&gt;&gt; a.txt.gz #原来的a.txt不存在了</span><br></pre></td></tr></table></figure><p>如果想让gzip保留原始文件，需要使用-c，且要搭配重定向。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gzip -c a.txt &gt; a.txt.gz</span><br></pre></td></tr></table></figure></p><p>现在既有原始文件，也有压缩文件。</p><ol><li>-r 递归</li><li>也可以用-[0-9] 指定压缩率<h2 id="gunzip-解压缩gzip压缩的文件"><a href="#gunzip-解压缩gzip压缩的文件" class="headerlink" title="gunzip 解压缩gzip压缩的文件"></a>gunzip 解压缩gzip压缩的文件</h2>操作和gzip相同，如果要保留.gz文件，也需要用上述的重定向和-c。<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gunzip -c a.txt.gz &gt; a.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="bzip2-压缩"><a href="#bzip2-压缩" class="headerlink" title="bzip2 压缩"></a>bzip2 压缩</h2><p>和gzip几乎一样，但保留原始文件，使用-k，且不用重定向<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -k a.txt</span><br></pre></td></tr></table></figure></p><h2 id="bunzip2-解压缩bzip2压缩的文件"><a href="#bunzip2-解压缩bzip2压缩的文件" class="headerlink" title="bunzip2 解压缩bzip2压缩的文件"></a>bunzip2 解压缩bzip2压缩的文件</h2><ol><li>-t 最好解压缩前测试一下</li></ol><h2 id="tar-cf-归档文件"><a href="#tar-cf-归档文件" class="headerlink" title="tar -cf 归档文件"></a>tar -cf 归档文件</h2><p>tar不执行压缩 必须接着-cf，-c告诉tar命令正在创建原始码，-f则用于为原始码指定文件名<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf moby.tar *.txt</span><br><span class="line"># 压缩所有.txt文件</span><br></pre></td></tr></table></figure></p><p>也可以用于压缩整个目录结构，使用该命令可以批量归档大量的文件和子目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cf moby.tar abc/</span><br></pre></td></tr></table></figure><p>归档了abc目录</p><h2 id="tar-pzcvf结合tar和gzip归档和压缩文件"><a href="#tar-pzcvf结合tar和gzip归档和压缩文件" class="headerlink" title="tar -pzcvf结合tar和gzip归档和压缩文件"></a>tar -pzcvf结合tar和gzip归档和压缩文件</h2><ol><li>-p 确保保留权限 -z 能够在tar中调用gzip -v 运行时告知你执行的操作<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -pzcvf moby.tar.gz abc/</span><br></pre></td></tr></table></figure></li></ol><p>最后的扩展名是.tar.gz，也可以使用.tgz或是tar.gzip</p><ol start="2"><li>当然也可以使用tar结合bzip2<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -pjcvf moby.tar.bz2 abc/</span><br></pre></td></tr></table></figure></li></ol><p>注意 -j 选项。</p><h2 id="tar-zvtf-测试将要解开和解压缩的文件"><a href="#tar-zvtf-测试将要解开和解压缩的文件" class="headerlink" title="tar -zvtf 测试将要解开和解压缩的文件"></a>tar -zvtf 测试将要解开和解压缩的文件</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zvtf moby.tar.gz</span><br></pre></td></tr></table></figure><ol><li>-t 测试</li><li>-f 必须是放在最后一个选项</li><li>tar -jvtf moby.tar.gz 解压缩bzip2压缩的文件</li></ol><h2 id="grep-在文本文件中搜索匹配的模式"><a href="#grep-在文本文件中搜索匹配的模式" class="headerlink" title="grep 在文本文件中搜索匹配的模式"></a>grep 在文本文件中搜索匹配的模式</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep trian *</span><br><span class="line">$ grep &apos;hello wolrd!&apos; * #遇到有空格的字符串，用单引号，不要用双引号</span><br></pre></td></tr></table></figure><ol><li>-R 递归地搜索文件中的文本。</li><li>-i 忽略大小写</li><li>-w 只搜索完整单词</li><li>-n 显示搜索单词在文件中的对应行号</li><li>-v 显示文件中没有包含匹配单词的行</li><li>-l 列出包含搜索词的文件名</li><li>-c 列出文件中单词的出现次数</li></ol><h2 id="find-搜索文件"><a href="#find-搜索文件" class="headerlink" title="find 搜索文件"></a>find 搜索文件</h2><ol><li><p>-name</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name shaggs</span><br><span class="line">$ find . -name &quot;*shaggs*&quot; #最好搭配一些通配符</span><br></pre></td></tr></table></figure></li><li><p>-user 根据拥有者</p></li><li>-group 根据拥有组</li><li>-size 根据文件大小</li><li>-type 根据文件类型</li><li>-a 组合选项时 均为ture (And) </li><li>-o 任一表达式为 （OR）</li></ol><h2 id="history-查看历史命令"><a href="#history-查看历史命令" class="headerlink" title="history 查看历史命令"></a>history 查看历史命令</h2><h2 id="再次运行最近输入的命令"><a href="#再次运行最近输入的命令" class="headerlink" title="!! 再次运行最近输入的命令"></a>!! 再次运行最近输入的命令</h2><h2 id="！使用数字再次运行之前的命令"><a href="#！使用数字再次运行之前的命令" class="headerlink" title="！使用数字再次运行之前的命令"></a>！使用数字再次运行之前的命令</h2><p>history可以查到命令的编号，!499。</p><h2 id="使用字符串再次运行之前的命令"><a href="#使用字符串再次运行之前的命令" class="headerlink" title="使用字符串再次运行之前的命令"></a>使用字符串再次运行之前的命令</h2><p>!cat /ect，部分信息就行</p><h2 id="搜索之前输入的命令并运行"><a href="#搜索之前输入的命令并运行" class="headerlink" title="搜索之前输入的命令并运行"></a>搜索之前输入的命令并运行</h2><ol><li>按Crtl+r键,r代表反向搜索和匹配</li></ol><h2 id="uptime-显示计算机的持续运行时间"><a href="#uptime-显示计算机的持续运行时间" class="headerlink" title="uptime 显示计算机的持续运行时间"></a>uptime 显示计算机的持续运行时间</h2><p>有趣的命令</p><h2 id="ps-aux查看正在运行的所有进程"><a href="#ps-aux查看正在运行的所有进程" class="headerlink" title="ps aux查看正在运行的所有进程"></a>ps aux查看正在运行的所有进程</h2><ol><li>a 表示所有用户</li><li>u 以面向用户的格式显示，或显示拥有每个进程的用户</li><li>x 没有控制终端设备或终端屏幕的进程，“显示每个进程”的另外一个说法</li><li>-w 默认情况下输出会在终端窗口的边缘被切断，为了完整地查看输出行，可添加 -w 换行</li></ol><p>ps命令提供很多信息，包括拥有进程地用户、唯一地进程ID编号（PID，用于标识进程）、进程正在使用的CPU百分比（%CPU）和内存百分比（%MEM）、已经运行了多长时间、进程的当前状态STAT以及进程自身的名称。</p><ul><li>R 正在运行</li><li>S 正在休眠</li><li>T 已停止</li><li>Z 僵尸进程 意味着该进程一直处于挂起状态，不能停止。只有重启计算机才能完全关闭这个程序。</li></ul><h2 id="ps-axjf-查看进程树"><a href="#ps-axjf-查看进程树" class="headerlink" title="ps axjf 查看进程树"></a>ps axjf 查看进程树</h2><h2 id="ps-U-username-查看特定用户拥有的进程"><a href="#ps-U-username-查看特定用户拥有的进程" class="headerlink" title="ps U username 查看特定用户拥有的进程"></a>ps U username 查看特定用户拥有的进程</h2><h2 id="kill-终止正在运行的程序"><a href="#kill-终止正在运行的程序" class="headerlink" title="kill 终止正在运行的程序"></a>kill 终止正在运行的程序</h2><ol><li>-1 控制程序已停止运行，关闭进程</li><li>-15 正常终止进程，清除将要失控的进程和文件</li><li>-9 停止任何正在进行的处理工作，立即关闭进程<br>通常，先试试-15（实际上，这是默认值），没有响应，则使用-9</li></ol><h2 id="top-查看运行中进程的动态更新列表"><a href="#top-查看运行中进程的动态更新列表" class="headerlink" title="top 查看运行中进程的动态更新列表"></a>top 查看运行中进程的动态更新列表</h2><h2 id="df-显示文件系统的磁盘使用情况"><a href="#df-显示文件系统的磁盘使用情况" class="headerlink" title="df 显示文件系统的磁盘使用情况"></a>df 显示文件系统的磁盘使用情况</h2><h2 id="du-报告目录使用的文件空间"><a href="#du-报告目录使用的文件空间" class="headerlink" title="du 报告目录使用的文件空间"></a>du 报告目录使用的文件空间</h2><ol><li>-hs 只报告占用空间的总量</li></ol><h2 id="rpm-安装软件包"><a href="#rpm-安装软件包" class="headerlink" title="rpm 安装软件包"></a>rpm 安装软件包</h2><p>用于安装以.rpm为后缀的软件安装程序。</p><ol><li>-ihv [package]  i 安装软件包，h 显示hash标记，以便观察安装进度，v 显示命令执行的操作</li><li>-Uhv [package] 更好的选择 U 可以进行安装和升级。如果已经存在软件包，会自动更新。</li><li>-e [package] 删除软件包</li></ol><h2 id="yum-安装软件包及其依赖程序-RPM"><a href="#yum-安装软件包及其依赖程序-RPM" class="headerlink" title="yum 安装软件包及其依赖程序(RPM)"></a>yum 安装软件包及其依赖程序(RPM)</h2><p>yum命令通过充当RPM的包装器来安装、升级和卸载软件包。</p><ol><li>install </li><li>remove 删除软件包及其依赖程序</li><li>update 更新升级</li><li>list avaliable 查看可供下载的软件包<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list avaliable | grep wireshark</span><br></pre></td></tr></table></figure></li></ol><h2 id="dpkg-安装软件包-DEB"><a href="#dpkg-安装软件包-DEB" class="headerlink" title="dpkg 安装软件包(DEB)"></a>dpkg 安装软件包(DEB)</h2><ol><li>-i [package] 就是这么简单</li><li>-r [package] 删除</li></ol><h2 id="apt-get-install-安装软件包及其依赖程序-DEB"><a href="#apt-get-install-安装软件包及其依赖程序-DEB" class="headerlink" title="apt-get install 安装软件包及其依赖程序(DEB)"></a>apt-get install 安装软件包及其依赖程序(DEB)</h2><ol><li>apt-get update 该命令会从APT服务器（称为仓库）下载当前的软件包列表，在APT配置文件（/etc/apt/sources.list）中列出了这些仓库（可以使用cat查看）。</li><li>apt-get remove [package] 删除软件包及其依赖程序（DEB)</li><li>–purge 卸载软件包不会删除这个包的所有数据，被删除软件的配置文件还会残留在计算机中。如果想要删除所有数据，使用 –purge，表示与这个包相关的配置文件包也要被删除。</li><li>apt-cache search [package] 查找可供下载的软件包</li><li>apt-get clean 清楚不再需要的安装包</li></ol><h2 id="ping-验证计算机是否正在运行和能否接受请求"><a href="#ping-验证计算机是否正在运行和能否接受请求" class="headerlink" title="ping 验证计算机是否正在运行和能否接受请求"></a>ping 验证计算机是否正在运行和能否接受请求</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping ww.baidu.com</span><br></pre></td></tr></table></figure><p>直到按下Ctrl + C组合键，ping命令才会停止。</p><h2 id="ssh-安全登录到另外一台服务器"><a href="#ssh-安全登录到另外一台服务器" class="headerlink" title="ssh 安全登录到另外一台服务器"></a>ssh 安全登录到另外一台服务器</h2><h2 id="sftp-在计算机之间安全地传输文件"><a href="#sftp-在计算机之间安全地传输文件" class="headerlink" title="sftp 在计算机之间安全地传输文件"></a>sftp 在计算机之间安全地传输文件</h2><h2 id="scp-在主机之间安全地复制文件"><a href="#scp-在主机之间安全地复制文件" class="headerlink" title="scp 在主机之间安全地复制文件"></a>scp 在主机之间安全地复制文件</h2><h2 id="wget-非交互式下载文件或非交互式下载整个网站"><a href="#wget-非交互式下载文件或非交互式下载整个网站" class="headerlink" title="wget 非交互式下载文件或非交互式下载整个网站"></a>wget 非交互式下载文件或非交互式下载整个网站</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纯个人向认为比较重要的，需要熟记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工作日常" scheme="http://www.cygao.xyz/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="linux" scheme="http://www.cygao.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>手推xgboost及常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/09/xgboost/"/>
    <id>http://www.cygao.xyz/2019/09/09/xgboost/</id>
    <published>2019-09-09T07:24:53.000Z</published>
    <updated>2019-09-09T07:53:23.589Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容转载于<a href="https://blog.csdn.net/v_JULY_v/article/details/81410574" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/81410574</a><br><a id="more"></a></p><h3 id="手推xgboost"><a href="#手推xgboost" class="headerlink" title="手推xgboost"></a>手推xgboost</h3><div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/xgboost1.jpg"></div> <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/xgboost2.jpg"></div> <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/xgboost3.jpg"></div> <h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>XGBOOST怎么调参，用了多少棵树</li><li>XGBOOST的回归怎么做的<br>自行在下方找答案吧。</li></ol><p>下面的内容摘抄自链接：<a href="https://blog.csdn.net/v_JULY_v/article/details/81410574" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/81410574</a>    </p><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h3><p> xgboost一直在竞赛江湖里被传为神器，比如时不时某个kaggle/天池比赛中，某人用xgboost于千军万马中斩获冠军。</p><p> 而我们的机器学习课程里也必讲xgboost，如寒所说：“RF和GBDT是工业界大爱的模型，Xgboost 是大杀器包裹，Kaggle各种Top排行榜曾一度呈现Xgboost一统江湖的局面，另外某次滴滴比赛第一名的改进也少不了Xgboost的功劳”。</p><p> 此外，公司七月在线从2016年上半年起，就开始组织学员参加各种比赛，以在实际竞赛项目中成长（毕竟，搞AI不可能没实战，而参加比赛历经数据处理、特征选择、模型调优、代码调参，是一个极好的真刀真枪的实战机会，对能力的提升和找/换工作的帮助都非常大）。</p><p> AI大潮之下，今年特别多从传统IT转行转岗转型AI的朋友，很多朋友都咨询如何转行AI，我一般都会着重强调学习AI或找/换AI的四大金刚：<a href="https://www.julyedu.com/category/index" target="_blank" rel="noopener">课程</a> + <a href="https://www.julyedu.com/question/index" target="_blank" rel="noopener">题库</a> + <a href="https://oj.julyedu.com/problemset.php" target="_blank" rel="noopener">OJ</a> + kaggle/天池。包括集训营的毕业考核更会融合kaggle或天池比赛。</p><p> 考虑到kaggle/天池比赛对搞数学科学的重要性，特写此文介绍xgboost，助力大家快速入门xgboost以及在比赛中获得优异成绩。</p><p> 最后，xgboost不是我July发明的，但我会确保本文对它的介绍是最通俗易懂的（且本文得到七月在线AI lab负责人陈博士审校）。另，感谢文末所列的全部参考文献，有何问题，欢迎随时留言评论，thanks。</p><h3 id="1-决策树"><a href="#1-决策树" class="headerlink" title="1 决策树"></a>1 决策树</h3><p> 举个例子，集训营某一期有100多名学员，假定给你一个任务，要你统计男生女生各多少人，当一个一个学员依次上台站到你面前时，你会怎么区分谁是男谁是女呢？</p><p> 很快，你考虑到男生的头发一般很短，女生的头发一般比较长，所以你通过头发的长短将这个班的所有学员分为两拨，长发的为“女”，短发为“男”。</p><p> 相当于你依靠一个指标“头发长短”将整个班的人进行了划分，于是形成了一个简单的决策树，而划分的依据是头发长短。<br> 这时，有的人可能有不同意见了：为什么要用“头发长短”划分呀，我可不可以用“穿的鞋子是否是高跟鞋”，“有没有喉结”等等这些来划分呢，答案当然是可以的。</p><p> 但究竟根据哪个指标划分更好呢？很直接的判断是哪个分类效果更好则优先用哪个。所以，这时就需要一个评价标准来量化分类效果了。 </p><p> 怎么判断“头发长短”或者“是否有喉结”是最好的划分方式，效果怎么量化呢？直观上来说，如果根据某个标准分类人群后，纯度越高效果越好，比如说你分为两群，“女”那一群都是女的，“男”那一群全是男的，那这个效果是最好的。但有时实际的分类情况不是那么理想，所以只能说越接近这种情况，我们则认为效果越好。</p><p> 量化分类效果的方式有很多，比如信息增益（ID3）、信息增益率（C4.5）、基尼系数（CART）等等。</p><blockquote><p><strong>信息增益的度量标准：熵</strong></p><p> ID3算法的核心思想就是以信息增益度量属性选择，选择分裂后信息增益最大的属性进行分裂。</p><p> 什么是信息增益呢？为了精确地定义信息增益，我们先定义信息论中广泛使用的一个度量标准，称为<strong>熵</strong>（entropy），它刻画了任意样例集的纯度（purity）。给定包含关于某个目标概念的正反样例的样例集S，那么S相对这个布尔型分类的熵为：</p><blockquote><p><img src="http://hi.csdn.net/attachment/201201/8/0_1326017614WvVU.gif" alt></p><p> 上述公式中，p+代表正样例，比如在本文开头第二个例子中p+则意味着去打羽毛球，而p-则代表反样例，不去打球(在有关熵的所有计算中我们定义0log0为0)。</p><p> 举例来说，假设S是一个关于布尔概念的有14个样例的集合，它包括9个正例和5个反例（我们采用记号[9+，5-]来概括这样的数据样例），那么S相对于这个布尔样例的熵为：</p></blockquote><blockquote><p>Entropy（[9+，5-]）=-（9/14）log2（9/14）-（5/14）log2（5/14）=0.940。</p><p> So，根据上述这个公式，我们可以得到：</p></blockquote><ul><li>如果S的所有成员属于同一类，则Entropy(S)=0； </li><li>如果S的正反样例数量相等，则Entropy(S)=1； </li><li>如果S的正反样例数量不等，则熵介于0，1之间 如下图所示：</li></ul><blockquote><p><img src="http://hi.csdn.net/attachment/201201/8/0_1326018003ADwJ.gif" alt></p><p> 看到没，通过Entropy的值，你就能评估当前分类树的分类效果好坏了。</p></blockquote><p> 更多细节如剪枝、过拟合、优缺点、可以参考此文《<a href="https://blog.csdn.net/v_july_v/article/details/7577684" target="_blank" rel="noopener">决策树学习</a>》。</p></blockquote><p> 所以，现在决策树的灵魂已经有了，即依靠某种指标进行树的分裂达到分类/回归的目的，总是希望纯度越高越好。</p><p>### </p><h3 id="2-回归树与集成学习"><a href="#2-回归树与集成学习" class="headerlink" title="2.回归树与集成学习"></a>2.回归树与集成学习</h3><p> 如果用一句话定义xgboost，很简单：Xgboost就是由很多CART树集成。但，什么是CART树？</p><blockquote><p>数据挖掘或机器学习中使用的决策树有两种主要类型：</p><ol><li>分类树分析是指预测结果是数据所属的类（比如某个电影去看还是不看） </li><li>回归树分析是指预测结果可以被认为是实数（例如房屋的价格，或患者在医院中的逗留时间） 而术语分类回归树（CART，Classification And Regression Tree）分析是用于指代上述两种树的总称，由Breiman等人首先提出。</li></ol><p> <strong>2.1 回归树</strong><br> 事实上，分类与回归是两个很接近的问题，分类的目标是根据已知样本的某些特征，判断一个新的样本属于哪种已知的样本类，它的结果是离散值。而回归的结果是连续的值。当然，本质是一样的，都是特征（feature）到结果/标签（label）之间的映射。</p></blockquote><p> 理清了什么是分类和回归之后，理解分类树和回归树就不难了。</p><p> 分类树的样本输出（即响应值）是类的形式，比如判断这个救命药是真的还是假的，周末去看电影《风语咒》还是不去。而回归树的样本输出是数值的形式，比如给某人发放房屋贷款的数额就是具体的数值，可以是0到300万元之间的任意值。</p><p> 所以，对于回归树，你没法再用分类树那套信息增益、信息增益率、基尼系数来判定树的节点分裂了，你需要采取新的方式评估效果，包括预测误差（常用的有均方误差、对数误差等）。而且节点不再是类别，是数值（预测值），那么怎么确定呢？有的是节点内样本均值，有的是最优化算出来的比如Xgboost。</p><blockquote><p>CART回归树是假设树为二叉树，通过不断将特征进行分裂。比如当前树结点是基于第j个特征值进行分裂的，设该特征值小于s的样本划分为左子树，大于s的样本划分为右子树。</p><p> <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/1-3.png" alt></p><p> 而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为：</p><p> <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/2-3.png" alt></p><p> 因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数：</p><p> <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/3-3.png" alt></p><p> 所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。</p><p> <strong>2.2 boosting集成学习</strong></p></blockquote><p> 所谓集成学习，是指构建多个分类器（弱分类器）对数据集进行预测，然后用某种策略将多个分类器预测的结果集成起来，作为最终预测结果。通俗比喻就是“三个臭皮匠赛过诸葛亮”，或一个公司董事会上的各董事投票决策，它要求每个弱分类器具备一定的“准确性”，分类器之间具备“差异性”。</p><p> 集成学习根据各个弱分类器之间有无依赖关系，分为Boosting和Bagging两大流派：</p><ol><li>Boosting流派，各分类器之间有依赖关系，必须串行，比如Adaboost、GBDT(Gradient Boosting Decision Tree)、Xgboost </li><li>Bagging流派，各分类器之间没有依赖关系，可各自并行，比如随机森林（Random Forest） 而著名的Adaboost作为boosting流派中最具代表性的一种方法，本博客曾详细介绍它。</li></ol><blockquote><p>AdaBoost，是英文”Adaptive Boosting”（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</p><p> 具体说来，整个Adaboost 迭代算法就3步：</p><ol><li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。 </li><li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。 </li><li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。<br>而另一种boosting方法GBDT（Gradient Boost Decision Tree)，则与AdaBoost不同，GBDT每一次的计算是都为了减少上一次的残差，进而在残差减少（负梯度）的方向上建立一个新的模型。</li></ol></blockquote><p> boosting集成学习由多个相关联的决策树联合决策，什么叫相关联？举个例子</p><ol><li>有一个样本[数据-&gt;标签]是：[(2，4，5)-&gt; 4] </li><li>第一棵决策树用这个样本训练的预测为3.3 </li><li>那么第二棵决策树训练时的输入，这个样本就变成了：[(2，4，5)-&gt; 0.7] </li><li><p>也就是说，下一棵决策树输入样本会与前面决策树的训练和预测相关 很快你会意识到，Xgboost为何也是一个boosting的集成学习了。</p><p>而一个回归树形成的关键点在于：</p></li></ol><ul><li>分裂点依据什么来划分（如前面说的均方误差最小，loss）； </li><li>分类后的节点预测值是多少（如前面说，有一种是将叶子节点下各样本实际值得均值作为叶子节点预测误差，或者计算所得） 至于另一类集成学习方法，比如Random Forest（随机森林）算法，各个决策树是独立的、每个决策树在样本堆里随机选一批样本，随机选一批特征进行独立训练，各个决策树之间没有啥关系。本文暂不展开介绍。</li></ul><h3 id="3-GBDT"><a href="#3-GBDT" class="headerlink" title="3.GBDT"></a>3.GBDT</h3><p> 说到Xgboost，不得不先从GBDT(Gradient Boosting Decision Tree)说起。因为xgboost本质上还是一个GBDT，但是力争把速度和效率发挥到极致，所以叫X (Extreme) GBoosted。包括前面说过，两者都是boosting方法。</p><p> GBDT的原理很简单，就是所有弱分类器的结果相加等于预测值，然后下一个弱分类器去拟合误差函数对预测值的梯度/残差(这个梯度/残差就是预测值与真实值之间的误差)。当然了，它里面的弱分类器的表现形式就是各棵树。如图所示：Y = Y1 + Y2 + Y3。</p><p> <img src="https://img-blog.csdn.net/20180804144218395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 举一个非常简单的例子，比如我今年30岁了，但计算机或者模型GBDT并不知道我今年多少岁，那GBDT咋办呢？</p><ol><li>它会在第一个弱分类器（或第一棵树中）随便用一个年龄比如20岁来拟合，然后发现误差有10岁； </li><li>接下来在第二棵树中，用6岁去拟合剩下的损失，发现差距还有4岁； </li><li>接着在第三棵树中用3岁拟合剩下的差距，发现差距只有1岁了； </li><li><p>最后在第四课树中用1岁拟合剩下的残差，完美。 最终，四棵树的结论加起来，就是真实年龄30岁。实际工程中，gbdt是计算负梯度，用负梯度近似残差。</p><p>注意，为何gbdt可以用用负梯度近似残差呢？</p><p>回归任务下，GBDT 在每一轮的迭代时对每个样本都会有一个预测值，此时的损失函数为均方差损失函数，</p><p><img src="https://img-blog.csdnimg.cn/20190310003539352.gif" alt></p><p>那此时的负梯度是这样计算的</p><p><img src="https://img-blog.csdnimg.cn/20190310003450668.gif" alt></p><p>所以，当损失函数选用均方损失函数是时，每一次拟合的值就是（真实值 - 当前模型预测的值），即残差。此时的变量是<img src="https://img-blog.csdnimg.cn/20190310003909104.gif" alt>，即“当前预测模型的值”，也就是对它求负梯度。</p></li></ol><blockquote><p>另外，这里还得再啰嗦一下，上面预测年龄的第一个步骤中的“随便”二字看似随便，其实深入思考一下一点都不随便，你会发现大部分做预测的模型，基本都是这么个常规套路，先随便用一个值去预测，然后对比预测值与真实值的差距，最后不断调整 缩小差距。所以会出来一系列目标函数：确定目标，和损失函数：缩小误差。</p><p> 再进一步思考，你会发现这完全符合人类做预测的普遍常识、普遍做法，当对一个事物不太了解时，一开始也是根据经验尝试、初探，直到逼近某种意义上的接近或者完全吻合。</p><p> 还是年龄预测的例子。</p></blockquote><p> 简单起见，假定训练集只有4个人：A,B,C,D，他们的年龄分别是14,16,24,26。其中A、B分别是高一和高三学生；C,D分别是应届毕业生和工作两年的员工。</p><p> 所以，现在的问题就是我们要预测这4个人的年龄，咋下手？很简单，先随便用一个年龄比如20岁去拟合他们，然后根据实际情况不断调整。</p><p> 如果是用一棵传统的回归决策树来训练，会得到如下图所示结果：</p><p> <img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153148112917172596.png" alt><br> 现在我们使用GBDT来做这件事，由于数据太少，我们限定叶子节点做多有两个，即每棵树都只有一个分枝，并且限定只学两棵树。</p><p> 我们会得到如下图所示结果：</p><p> <img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153148115267426581.png" alt><br> 在第一棵树分枝和图1一样，由于A,B年龄较为相近，C,D年龄较为相近，他们被分为左右两拨，每拨用平均年龄作为预测值。</p><ul><li>此时计算残差（<strong>残差的意思就是：A的实际值 - A的预测值 = A的残差</strong>），所以A的残差就是实际值14 - 预测值15 = 残差值-1。 </li><li><p>注意，A的预测值是指前面所有树累加的和，这里前面只有一棵树所以直接是15，如果还有树则需要都累加起来作为A的预测值。 </p><blockquote><p>残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。“残差”蕴含了有关模型基本假设的重要信息。如果回归模型正确的话， 我们可以将残差看作误差的观测值。</p><p>进而得到A,B,C,D的残差分别为-1,1，-1,1。</p></blockquote><p>然后拿它们的残差-1、1、-1、1代替A B C D的原值，到第二棵树去学习，第二棵树只有两个值1和-1，直接分成两个节点，即A和C分在左边，B和D分在右边，经过计算（比如A，实际值-1 - 预测值-1 = 残差0，比如C，实际值-1 - 预测值-1 = 0），此时所有人的残差都是0。</p><p>残差值都为0，相当于第二棵树的预测值和它们的实际值相等，则只需把第二棵树的结论累加到第一棵树上就能得到真实年龄了，即每个人都得到了真实的预测值。</p><p>换句话说，现在A,B,C,D的预测值都和真实年龄一致了。Perfect！<br>A: 14岁高一学生，购物较少，经常问学长问题，预测年龄A = 15 – 1 = 14<br>B: 16岁高三学生，购物较少，经常被学弟问问题，预测年龄B = 15 + 1 = 16</p><p>C: 24岁应届毕业生，购物较多，经常问师兄问题，预测年龄C = 25 – 1 = 24<br>D: 26岁工作两年员工，购物较多，经常被师弟问问题，预测年龄D = 25 + 1 = 26</p><p>所以，GBDT需要将多棵树的得分累加得到最终的预测得分，且每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差。</p></li></ul><h3 id="4-Xgboost"><a href="#4-Xgboost" class="headerlink" title="4.Xgboost"></a>4.Xgboost</h3><p> <strong>4.1 xgboost树的定义</strong></p><p> 本节的示意图基本引用自xgboost原作者陈天奇的讲义PPT中。</p><p> 举个例子，我们要预测一家人对电子游戏的喜好程度，考虑到年轻和年老相比，年轻更可能喜欢电子游戏，以及男性和女性相比，男性更喜欢电子游戏，故先根据年龄大小区分小孩和大人，然后再通过性别区分开是男是女，逐一给各人在电子游戏喜好程度上打分，如下图所示。</p><blockquote><p><img src="https://img-blog.csdn.net/20180804174128743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 就这样，训练出了2棵树tree1和tree2，类似之前gbdt的原理，两棵树的结论累加起来便是最终的结论，所以小孩的预测分数就是两棵树中小孩所落到的结点的分数相加：2 + 0.9 = 2.9。爷爷的预测分数同理：-1 + （-0.9）= -1.9。具体如下图所示</p></blockquote><blockquote><p><img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/5-2.png" alt></p><p> 恩，你可能要拍案而起了，惊呼，这不是跟上文介绍的gbdt乃异曲同工么？</p></blockquote><p> 事实上，如果不考虑工程实现、解决问题上的一些差异，xgboost与gbdt比较大的不同就是目标函数的定义。xgboost的目标函数如下图所示：</p><p> <img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase6415314827826172363.png" alt></p><p> 其中</p><ul><li>红色箭头所指向的L 即为损失函数（比如平方损失函数：<img src="https://img-blog.csdnimg.cn/20190115001152242.gif" alt>，或logistic损失函数：<img src="https://img-blog.csdn.net/20180805010528463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>） </li><li>红色方框所框起来的是正则项（包括L1正则、L2正则） </li><li>红色圆圈所圈起来的为常数项 </li><li><p>对于<img src="https://private.codecogs.com/gif.latex?f%28x%29" alt="f(x)">，xgboost利用泰勒展开三项，做一个近似 我们可以很清晰地看到，最终的目标函数只依赖于每个数据点在误差函数上的一阶导数和二阶导数。</p><p>额，峰回路转，突然丢这么大一个公式，不少人可能瞬间就懵了。没事，下面咱们来拆解下这个目标函数，并一一剖析每个公式、每个符号、每个下标的含义。</p><p><strong>4.2 xgboost目标函数</strong></p><p>xgboost的核心算法思想不难，基本就是</p></li></ul><ol><li><p>不断地添加树，<strong>不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差</strong>。 <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/4-2.png" alt></p><p> 注：w_q(x)为叶子节点q的分数，<img src="https://img-blog.csdn.net/20180806215950729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>对应了所有K棵回归树（regression tree）的集合，而f(x)为其中一棵回归树。</p></li></ol><ol start="3"><li>当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数 </li><li><p>最后只需要将每棵树对应的分数加起来就是该样本的预测值。 显然，我们的目标是要使得树群的预测值<img src="https://img-blog.csdn.net/2018080921415487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>尽量接近真实值<img src="https://private.codecogs.com/gif.latex?y_%7Bi%7D" alt="y_{i}">，而且有尽量大的泛化能力。</p><p>所以，从数学角度看这是一个泛函最优化问题，故把目标函数简化如下：</p><p><img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155669134287033.png" alt></p><p>如你所见，这个目标函数分为两部分：损失函数和正则化项。且<strong>损失函数揭示训练误差</strong>（即预测分数和真实分数的差距）<strong>，正则化定义复杂度。</strong></p><p>对于上式而言，<img src="https://img-blog.csdn.net/2018080921415487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>是整个累加模型的输出，正则化项<img src="https://img-blog.csdnimg.cn/20190309164745107.png" alt>是则表示树的复杂度的函数，值越小复杂度越低，泛化能力越强，其表达式为</p><p><img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155674940294423.png" alt></p><p>T表示叶子节点的个数，w表示叶子节点的分数。直观上看，目标要求预测误差尽量小，且叶子节点T尽量少（γ控制叶子结点的个数），节点数值w尽量不极端（λ控制叶子节点的分数不会过大），防止过拟合。</p></li></ol><blockquote><p>插一句，一般的目标函数都包含下面两项</p><p> <img src="https://img-blog.csdn.net/20180805010136131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 其中，误差/损失函数鼓励我们的模型尽量去拟合训练数据，使得最后的模型会有比较少的 bias。而正则化项则鼓励更加简单的模型。因为当模型简单之后，有限数据拟合出来结果的随机性比较小，不容易过拟合，使得最后模型的预测更加稳定。</p><p> <strong>4.2.1 模型学习与训练误差</strong></p></blockquote><p> 具体来说，目标函数第一部分中的 <img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 表示第<img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>个样本，<img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> (<img src="https://img-blog.csdn.net/2018080921415487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> − <img src="https://private.codecogs.com/gif.latex?y_%7Bi%7D" alt="y_{i}">) 表示第 <img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 个样本的预测误差，我们的目标当然是误差越小越好。</p><p> 类似之前GBDT的套路，xgboost也是需要将多棵树的得分累加得到最终的预测得分（每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差）。</p><p> <img src="http://i.imgur.com/hPRke6w.png" alt></p><p> 但，我们如何选择每一轮加入什么<img src="https://private.codecogs.com/gif.latex?f" alt="f">呢？答案是非常直接的，选取一个<img src="https://img-blog.csdn.net/20180805124812416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 来使得我们的目标函数尽量最大地降低。</p><blockquote><p><img src="https://img-blog.csdn.net/20180805012146417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 再强调一下，考虑到<strong>第t轮的模型预测值**</strong> <img src="https://img-blog.csdnimg.cn/20190116224720643.png" alt> = 前t-1轮的模型预测<img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt> + <img src="https://img-blog.csdnimg.cn/20190116225031205.png" alt>，因此误差函数记为：<strong><img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> </strong>( <strong><img src="https://img-blog.csdn.net/20180805124717659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></strong>, <img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt>+ <img src="https://img-blog.csdnimg.cn/20190116225031205.png" alt> )**，后面一项为正则化项。</p></blockquote><p> 对于这个误差函数的式子而言，在第t步，<img src="https://img-blog.csdn.net/20180805124717659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>是真实值，即已知，<strong><img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt></strong>可由上一步第t-1步中的<img src="https://img-blog.csdnimg.cn/20190307212807817.gif" alt>加上<img src="https://img-blog.csdnimg.cn/20190115131437590.gif" alt>计算所得，某种意义上也算已知值，故模型学习的是<img src="https://img-blog.csdn.net/20180805124812416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>。</p><p> 上面那个Obj的公式表达的可能有些过于抽象，我们可以考虑当<img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 是平方误差的情况（相当于<img src="https://img-blog.csdnimg.cn/20190115001152242.gif" alt>），这个时候我们的目标可以被写成下面这样的二次函数（图中画圈的部分表示的就是预测值和真实值之间的残差）：</p><blockquote><p><img src="https://img-blog.csdn.net/20180805012522806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 更加一般的，损失函数不是二次函数咋办？利用泰勒展开，不是二次的想办法近似为二次（如你所见，定义了一阶导<img src="https://private.codecogs.com/gif.latex?g" alt="g">和二阶导<img src="https://private.codecogs.com/gif.latex?h" alt="h">）。</p></blockquote><blockquote><p><img src="http://i.imgur.com/4UggIum.png" alt></p><p> 恩恩，注意了！不少人可能就会在这里卡壳，网上也很少有文章解释清楚，在和七月在线AI lab陈博士讨论之后，发现这里面最关键的其实就是把泰勒二阶展开各项和xgboost 目标函数的对应关系搞清楚，相当于我们可以利用泰勒二阶展开去做目标函数的近似。</p></blockquote><p> 首先，这是泰勒二阶展开<img src="https://img-blog.csdnimg.cn/20190114211855366.png" alt></p><p> 对应到xgboost的目标函数里头</p><p> <img src="https://img-blog.csdnimg.cn/2019011421570463.png" alt></p><p> 忽略损失函数<img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 中的<img src="https://img-blog.csdnimg.cn/20190114224146584.gif" alt>（别忘了上面说的“ 在第t步，<img src="https://img-blog.csdn.net/20180805124717659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>是真实值，即已知 ”，不影响后续目标函数对<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799905263888750.png" alt>的偏导计算），做下一一对应：</p><ul><li>泰勒二阶展开f 里的x对应目标函数里的<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799905263888750.png" alt>， </li><li>f 里<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64155197699632731742.png" alt>的对应目标函数的<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799902222028087.png" alt>， </li><li><p>从而f 对x求导数时，对应为目标函数对<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799905263888750.png" alt>求偏导 得到：</p><p><img src="https://img-blog.csdnimg.cn/20190114224457972.png" alt></p><p>其中，<img src="https://img-blog.csdnimg.cn/20190114224646298.png" alt>，<img src="https://img-blog.csdnimg.cn/2019011422465540.png" alt></p><p>呜呼，透了！不过，这个转化过程中的关键泰勒二次展开到底是哪来的呢？</p></li></ul><blockquote><p>在数学中，泰勒公式（英语：Taylor’s Formula）是一个用函数在某点的信息描述其附近取值的公式。这个公式来自于微积分的泰勒定理（Taylor’s theorem），泰勒定理描述了一个可微函数，如果函数足够光滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值，这个多项式称为泰勒多项式（Taylor polynomial）。</p><p> 相当于告诉我们可由利用泰勒多项式的某些次项做原函数的近似。</p><p> 泰勒定理：<br> 设 n 是一个正整数。如果定义在一个包含 a 的区间上的函数 f 在 a 点处 n+1 次可导，那么对于这个区间上的任意 x，都有：</p><p> <img src="https://img-blog.csdnimg.cn/20190114235057740.png" alt></p><p> 其中的多项式称为函数在a 处的泰勒展开式，剩余的<img src="https://img-blog.csdnimg.cn/20190114234926647.png" alt>是泰勒公式的余项，是<img src="https://img-blog.csdnimg.cn/20190114234943527.png" alt>的高阶无穷小。</p><p> 接下来，考虑到我们的第t 颗回归树是根据前面的t-1颗回归树的残差得来的，相当于t-1颗树的值<strong><img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt></strong>是已知的。换句话说，<img src="https://img-blog.csdnimg.cn/20190116004713489.png" alt>对目标函数的优化不影响，可以直接去掉，且常数项也可以移除，从而得到如下一个比较统一的目标函数。</p></blockquote><blockquote><p><img src="http://i.imgur.com/quPhp1K.png" alt></p><p> 这时，目标函数只依赖于每个数据点在误差函数上的一阶导数<img src="https://private.codecogs.com/gif.latex?g" alt="g">和二阶导数<img src="https://private.codecogs.com/gif.latex?h" alt="h">（相信你已经看出xgboost和gbdt的不同了，目标函数保留了泰勒展开的二次项）。</p></blockquote><p> 总的指导原则如就职Google的读者crab6789所说：</p><blockquote><p>实质是把样本分配到叶子结点会对应一个obj，优化过程就是obj优化。也就是分裂节点到叶子不同的组合，不同的组合对应不同obj，所有的优化围绕这个思想展开。</p><p> 到目前为止我们讨论了目标函数中的第一个部分：训练误差。接下来我们讨论目标函数的第二个部分：正则项，即如何定义树的复杂度。</p></blockquote><p> <strong>4.2.2 正则项：树的复杂度</strong></p><p> 首先，梳理下几个规则</p><ul><li>用叶子节点集合以及叶子节点得分表示  </li><li>每个样本都落在一个叶子节点上  </li><li>q(x)表示样本x在某个叶子节点上，wq(x)是该节点的打分，即该样本的模型预测值 所以当我们把树成<strong>结构部分q</strong>和<strong>叶子权重部分w后，</strong>结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。</li></ul><blockquote><p><img src="http://i.imgur.com/P5QtOgo.png" alt></p><p> 另外，如下图所示，xgboost对树的复杂度包含了两个部分：</p></blockquote><ol><li>一个是树里面叶子节点的个数T </li><li><p>一个是树上叶子节点的得分w的L2模平方（对w进行L2正则化，相当于针对每个叶结点的得分增加L2平滑，目的是为了避免过拟合） </p><blockquote><p><img src="https://img-blog.csdn.net/20170228153006200" alt></p><p>在这种新的定义下，我们可以把之前的目标函数进行如下变形（另，别忘了：<img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155674940294423.png" alt>）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181208010713981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92,size_16,color_FFFFFF,t_70" alt></p><p>其中<img src="https://img-blog.csdn.net/20180804185718100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>被定义为每个叶节点 j 上面样本下标的集合 <img src="https://img-blog.csdn.net/20160421105402974" alt>，g是一阶导数，h是二阶导数。这一步是由于xgboost目标函数第二部分加了两个正则项，一个是叶子节点个数(T),一个是叶子节点的分数(w)。</p><p>从而，加了正则项的目标函数里就出现了两种累加</p></li></ol><ul><li>一种是<img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> - &gt; n（样本数） </li><li><p>一种是<img src="https://img-blog.csdn.net/20180805125138736?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> -&gt; T（叶子节点数） 这一个目标包含了T个相互独立的单变量二次函数。</p><p>理解这个推导的关键在哪呢？在和AI lab陈博士讨论之后，其实就在于理解这个定义：<img src="https://img-blog.csdn.net/20180804185718100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>被定义为每个叶节点 j 上面样本下标的集合 <img src="https://img-blog.csdn.net/20160421105402974" alt>，这个定义里的q(xi)要表达的是：每个样本值xi 都能通过函数q(xi)映射到树上的某个叶子节点，从而通过这个定义把两种累加统一到了一起。</p><p>接着，我们可以定义</p><p><img src="https://img-blog.csdn.net/20160421105610771" alt></p><p>最终公式可以化简为</p><p><img src="https://img-blog.csdn.net/20160421105711217" alt></p><p>通过对<img src="https://img-blog.csdn.net/20160421105932533" alt>求导等于0，可以得到</p><p><img src="https://img-blog.csdn.net/20160421110031784" alt></p><p>然后把<img src="https://img-blog.csdn.net/20160421105932533" alt>最优解代入得到：</p><p><img src="https://img-blog.csdn.net/20160421110139754" alt></p><p><strong>4.3 打分函数计算</strong></p><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)<img src="https://img-blog.csdn.net/20160421110535150" alt></p><p><strong>4.3.1 分裂节点</strong></p><p>很有意思的一个事是，我们从头到尾了解了xgboost如何优化、如何计算，但树到底长啥样，我们却一直没看到。很显然，一棵树的生成是由一个节点一分为二，然后不断分裂最终形成为整棵树。那么树怎么分裂的就成为了接下来我们要探讨的关键。</p><p>对于一个叶子节点如何进行分裂，xgboost作者在其原始论文中给出了两种分裂节点的方法</p><p>（1）枚举所有不同树结构的贪心法</p><p>现在的情况是只要知道树的结构，就能得到一个该结构下的最好分数，那如何确定树的结构呢？</p><p>一个想当然的方法是：不断地枚举不同树的结构，然后利用打分函数来寻找出一个最优结构的树，接着加入到模型中，不断重复这样的操作。而再一想，你会意识到要枚举的状态太多了，基本属于无穷种，那咋办呢？</p><p>我们试下贪心法，从树深度0开始，每一节点都遍历所有的特征，比如年龄、性别等等，然后对于某个特征，<strong>先按照该特征里的值进行排序，然后线性扫描该特征进而确定最好的分割点</strong>，最后对所有特征进行分割后，我们选择所谓的增益Gain最高的那个特征，而Gain如何计算呢？</p><p>还记得4.2节最后，我们得到的计算式子吧？</p><p><img src="https://img-blog.csdn.net/20160421110139754" alt></p><p>换句话说，目标函数中的G/(H+λ)部分，表示着每一个叶子节点对当前模型损失的贡献程度，融合一下，得到Gain的计算表达式，如下所示：</p></li></ul><blockquote><p><img src="https://img-blog.csdn.net/20160421110908655" alt></p><p> 第一个值得注意的事情是“对于某个特征，先按照该特征里的值进行排序”，这里举个例子。</p></blockquote><p> 比如设置一个值a，然后枚举所有x &lt; a、a &lt; x这样的条件（<strong>x代表某个特征比如年龄age，把age从小到大排序：假定从左至右依次增大，则比a小的放在左边，比a大的放在右边</strong>），对于某个特定的分割a，我们要计算a左边和右边的导数和。</p><p> 比如总共五个人，按年龄排好序后，一开始我们总共有如下4种划分方法：</p><ol><li>把第一个人和后面四个人划分开 </li><li>把前两个人和后面三个人划分开 </li><li>把前三个人和后面两个人划分开 </li><li>把前面四个人和后面一个人划分开 接下来，把上面4种划分方法全都各自计算一下Gain，看哪种划分方法得到的Gain值最大则选取哪种划分方法，经过计算，发现把第2种划分方法“前面两个人和后面三个人划分开”得到的Gain值最大，意味着在一分为二这个第一层层面上这种划分方法是最合适的。</li></ol><blockquote><p><img src="https://img-blog.csdn.net/20160421111024891" alt></p><p> 换句话说，对于所有的特征x，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用计算Gain的公式计算每个分割方案的分数就可以了。</p></blockquote><p> 然后后续则依然按照这种划分方法继续第二层、第三层、第四层、第N层的分裂。</p><p> 第二个值得注意的事情就是引入分割不一定会使得情况变好，所以我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值γ 的时候，则忽略这个分割。</p><p> 换句话说，当引入某项分割，结果分割之后得到的分数 - 不分割得到的分数得到的值太小（比如小于我们的最低期望阀值γ），但却因此得到的复杂度过高，则相当于得不偿失，不如不分割。即做某个动作带来的好处比因此带来的坏处大不了太多，则为避免复杂 多一事不如少一事的态度，不如不做。</p><p> 相当于在我们发现“分”还不如“不分”的情况下后（得到的增益太小，小到小于阈值γ），会有2个叶子节点存在同一棵子树上的情况。</p><p> 下面是论文中的算法</p><blockquote><p><img src="https://img-blog.csdn.net/20170228144201588" alt></p><p> （2）近似算法</p></blockquote><p> 主要针对数据太大，不能直接进行计算</p><blockquote><p><img src="https://img-blog.csdn.net/20170228144525979" alt></p><p> 就职于Google的读者crab6789点评：</p></blockquote><blockquote><p>把样本从根分配到叶子结点，就是个排列组合。不同的组合对应的cost不同。求最好的组合你就要try，一味穷举是不可能的，所以才出来贪婪法。不看从头到尾 就看当下节点怎么分配最好。这才有了那个exact greddy方法，后来还想加速才有了histogram的做法。</p><p> <strong>4.4 小结：Boosted Tree Algorithm </strong></p></blockquote><p> 总结一下，如图所示</p><p> <img src="http://i.imgur.com/L7PhJwO.png" alt></p><p> 咱们来再次回顾整个过程。</p><p> 如果某个样本label数值为4，那么第一个回归树预测3，第二个预测为1； 另外一组回归树，一个预测2，一个预测2，那么倾向后一种，为什么呢？前一种情况，第一棵树学的太多，太接近4，也就意味着有较大的过拟合的风险。</p><p> OK，听起来很美好，可是怎么实现呢，上面这个目标函数跟实际的参数怎么联系起来，记得我们说过，回归树的参数：</p><ol><li>选取哪个feature分裂节点呢 </li><li><p>节点的预测值（总不能靠取平均值这么粗暴不讲道理的方式吧，好歹高级一点） 最终的策略就是：贪心 + 最优化（对的，二次最优化） 。</p><p>通俗解释贪心策略：就是决策时刻按照当前目标最优化决定，说白了就是眼前利益最大化决定，“目光短浅”策略。</p><p>这里是怎么用贪心策略的呢，刚开始你有一群样本，放在第一个节点，这时候T=1，w多少呢，不知道，是求出来的，这时候所有样本的预测值都是w,带入样本的label数值，此时loss function变为</p><p><img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155689536706939.png" alt></p></li></ol><ul><li>如果这里的l(w−yi)误差表示用的是平方误差，那么上述函数就是一个关于w的二次函数求最小值，取最小值的点就是这个节点的预测值，最小的函数值为最小损失函数。 </li><li>本质上来讲，这就是一个二次函数最优化问题！但要是损失函数不是二次函数咋办？泰勒展开，不是二次的想办法近似为二次。 接着来，接下来要选个feature分裂成两个节点，变成一棵弱小的树苗，那么需要：</li></ul><ol><li>确定分裂用的feature，how？最简单的是粗暴的枚举/穷举（嗯，够粗暴），然后选择loss function效果最好的那个； </li><li><p>如何确立节点的w以及最小的loss function，大声告诉我怎么做？对，二次函数的求最值（计算二次的最值一般都有固定套路，即导数等于0的点） 。所以，选择一个feature分裂，计算loss function最小值，然后再选一个feature分裂，又得到一个loss function最小值，你枚举完，找一个效果最好的，把树给分裂，就得到了小树苗。 在分裂的时候，你可以注意到，每次节点分裂，loss function被影响的只有这个节点的样本，因而每次分裂，计算分裂的增益（loss function的降低量）只需要关注打算分裂的那个节点的样本。</p><p>总而言之，XGBoost使用了和CART回归树一样的想法，利用贪婪算法，遍历所有特征的所有特征划分点，不同的是使用的目标函数不一样。具体做法就是分裂后的目标函数值比单子叶子节点的目标函数的增益，同时为了限制树生长过深，还加了个阈值，只有当增益大于该阈值才进行分裂。</p><p>以下便为设定的阈值</p></li></ol><blockquote><p><img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/15.png" alt></p><p> 从而继续分裂，形成一棵树，再形成一棵树，每次在上一次的预测基础上取最优进一步分裂/建树，是不是贪心策略？</p></blockquote><p> 凡是这种循环迭代的方式必定有停止条件，什么时候停止呢？简言之，设置树的最大深度、当样本权重和小于设定阈值时停止生长以防止过拟合。具体而言，则</p><ol><li>当引入的分裂带来的增益小于设定阀值的时候，我们可以忽略掉这个分裂，所以并不是每一次分裂loss function整体都会增加的，有点预剪枝的意思，阈值参数为<img src="https://img-blog.csdn.net/20180805130912894?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>（即正则项里叶子节点数T的系数）；  </li><li>当树达到最大深度时则停止建立决策树，设置一个超参数max_depth，避免树太深导致学习局部样本，从而过拟合；  </li><li>当样本权重和小于设定阈值时则停止建树。什么意思呢，即涉及到一个超参数-最小的样本权重和min_child_weight，和GBM的 min_child_leaf 参数类似，但不完全一样。大意就是一个叶子节点样本太少了，也终止同样是防止过拟合；  </li><li>貌似看到过有树的最大数量的… </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分内容转载于&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/81410574&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/v_JULY_v/article/details/81410574&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手推GBDT和常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/08/gbdt/"/>
    <id>http://www.cygao.xyz/2019/09/08/gbdt/</id>
    <published>2019-09-08T09:48:01.000Z</published>
    <updated>2019-09-09T11:45:05.373Z</updated>
    
    <content type="html"><![CDATA[<p>主要是手推算法。<br><a id="more"></a></p><h2 id="手推GBDT"><a href="#手推GBDT" class="headerlink" title="手推GBDT"></a>手推GBDT</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/gbdt.jpg" alt></div> <h2 id="GBDT中的CART回归树每个叶子结点的输出值是什么"><a href="#GBDT中的CART回归树每个叶子结点的输出值是什么" class="headerlink" title="GBDT中的CART回归树每个叶子结点的输出值是什么"></a>GBDT中的CART回归树每个叶子结点的输出值是什么</h2><ol><li>对于分类树，其输出变量的众数就是分类结果。</li><li>对于回归树，其输出变量的平均值就是预测结果。​</li></ol><h2 id="GDBT的GB是什么意思，如何体现？"><a href="#GDBT的GB是什么意思，如何体现？" class="headerlink" title="GDBT的GB是什么意思，如何体现？"></a>GDBT的GB是什么意思，如何体现？</h2><p><strong>Gradient Boosting</strong><br>Boosting是一种可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴，</p><p>Gradient Boosting是一种实现Boosting的方法，它的主要思想是，每一次建立模型，是在之前建立模型损失函数的梯度下降方向。损失函数描述的是模型的不靠谱程度，损失函数越大，说明模型越容易出错。如果我们的模型能够让损失函数持续的下降，说明我们的模型在不停的改进，而最好的方式就是让损失函数在其梯度的方向下降。</p><h2 id="介绍一下GBDT的原理和推导"><a href="#介绍一下GBDT的原理和推导" class="headerlink" title="介绍一下GBDT的原理和推导"></a>介绍一下GBDT的原理和推导</h2><p>见手推GBDT</p><h2 id="GBDT是回归树还是分类树"><a href="#GBDT是回归树还是分类树" class="headerlink" title="GBDT是回归树还是分类树"></a>GBDT是回归树还是分类树</h2><p>CART决策树既可以用于分类也可以用于回归，决策树分为分类树和回归树，分类树的衡量标准是最大熵，回归树的衡量标准是最小化均方差，所以<strong>GBDT中的树都是回归树，不是分类树</strong>.<br><strong>回归树！！！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是手推算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手推LR（Logistic Regression）逻辑斯蒂回归及常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/08/lr/"/>
    <id>http://www.cygao.xyz/2019/09/08/lr/</id>
    <published>2019-09-08T03:11:48.000Z</published>
    <updated>2019-09-08T03:43:33.283Z</updated>
    
    <content type="html"><![CDATA[<p>概念，公式推导，常见问题。</p><a id="more"></a><h2 id="1、逻辑斯蒂回归的概念"><a href="#1、逻辑斯蒂回归的概念" class="headerlink" title="1、逻辑斯蒂回归的概念"></a>1、逻辑斯蒂回归的概念</h2><p>算法的名字叫做逻辑斯蒂回归（我也不知道为什么这么翻译）但其实它是一种分类模型，一定不能把它和线性回归混为一谈。简单说一下分类和回归之间的区别：</p><ul><li>分类：给定一个数据，根据给出的训练集训练模型并推断出它所对应的类别（+1，-1），是一种定性的输出，也叫作离散变量预测。</li><li>回归：给定一个数据，根据给出的训练集训练模型并推断出该数据下的输出值是多少，此时输出的是一个真实的数值，是一种定量的输出，也叫作连续变量预测。</li></ul><h3 id="具体概念"><a href="#具体概念" class="headerlink" title="具体概念"></a>具体概念</h3><p>LR模型其实仅在线性回归的基础上，套用了一个逻辑函数（sigmoid）。逻辑回归是一个非线性的二分类模型，主要是计算在某个样本特征下事件发生的概率，但是他本质上是一个线性回归模型，因为除去sigmoid映射函数外，其他步骤算法都是线性回归的。</p><h2 id="2、手推LR"><a href="#2、手推LR" class="headerlink" title="2、手推LR"></a>2、手推LR</h2><p>图片转载自 <a href="https://blog.csdn.net/SweetSeven_/article/details/94620627" target="_blank" rel="noopener">https://blog.csdn.net/SweetSeven_/article/details/94620627</a></p><div align="center"><br><img width="700" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/lr1.png"><br></div> <h2 id="3、LR怎么加入非线性"><a href="#3、LR怎么加入非线性" class="headerlink" title="3、LR怎么加入非线性"></a>3、LR怎么加入非线性</h2><p>套用了一个逻辑函数（sigmoid），逻辑回归是一个非线性的二分类模型。</p><h2 id="4、LR的LOSS"><a href="#4、LR的LOSS" class="headerlink" title="4、LR的LOSS"></a>4、LR的LOSS</h2><p>上述图片中的J(θ)。</p><h2 id="5、极大似然的概念"><a href="#5、极大似然的概念" class="headerlink" title="5、极大似然的概念"></a>5、极大似然的概念</h2><p>先验概率是<strong>知因求果</strong>，后验概率是<strong>知果求因</strong>，极大似然是<strong>知果求最可能的原因</strong>,就是在参数θ的可能取值范围内，选取使L(θ)达到最大的参数值θ，作为参数θ的估计值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概念，公式推导，常见问题。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="检测算法" scheme="http://www.cygao.xyz/tags/%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>手推SVM及常见面试问题</title>
    <link href="http://www.cygao.xyz/2019/09/07/svm/"/>
    <id>http://www.cygao.xyz/2019/09/07/svm/</id>
    <published>2019-09-07T11:45:39.000Z</published>
    <updated>2019-09-07T13:07:13.062Z</updated>
    
    <content type="html"><![CDATA[<p>面试必备<br><a id="more"></a></p><h2 id="1、手推SVM"><a href="#1、手推SVM" class="headerlink" title="1、手推SVM"></a>1、手推SVM</h2><p>差不多这个程度应该够了。</p><div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm1.jpg"></div>  <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm2.jpg"></div>  <h2 id="2、SVM为什么叫支持向量机"><a href="#2、SVM为什么叫支持向量机" class="headerlink" title="2、SVM为什么叫支持向量机"></a>2、SVM为什么叫支持向量机</h2><p>这个名字是强调了此类学习器的关键是如何从支持向量构建出解；同时也暗示了其复杂度主要与支持向量的数目有关。</p><h2 id="3、SVM的损失函数（求导省略了）"><a href="#3、SVM的损失函数（求导省略了）" class="headerlink" title="3、SVM的损失函数（求导省略了）"></a>3、SVM的损失函数（求导省略了）</h2><div align="center"><br><img width="400" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm4.png"><br></div> <h2 id="4、核函数了解哪些，为什么要用核函数"><a href="#4、核函数了解哪些，为什么要用核函数" class="headerlink" title="4、核函数了解哪些，为什么要用核函数"></a>4、核函数了解哪些，为什么要用核函数</h2><p>当样本在原始空间线性不可分时，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。</p><div align="center"><br><img width="400" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm3.jpg"><br></div> <ol><li><p>线性核，主要用于线性可分的情况，我们可以看到特征空间到输入空间的维度是一样的，其参数少速度快，对于线性可分数据，其分类效果很理想，因此我们通常首先尝试用线性核函数来做分类，看看效果如何，如果不行再换别的。</p></li><li><p>多项式核函数可以实现将低维的输入空间映射到高纬的特征空间，但是多项式核函数的参数多，当多项式的阶数比较高的时候，核矩阵的元素值将趋于无穷大或者无穷小，计算复杂度会大到无法计算。</p></li><li><p>高斯（RBF）核函数 是一种局部性强的核函数，其可以将一个样本映射到一个更高维的空间内，该核函数是应用最广的一个，无论大样本还是小样本都有比较好的性能，而且其相对于多项式核函数参数要少，因此大多数情况下在不知道用什么核函数的时候，优先使用高斯核函数。</p></li><li><p>采用sigmoid核函数，支持向量机实现的就是一种多层神经网络。<br>因此，在选用核函数的时候，如果我们对我们的数据有一定的先验知识，就利用先验来选择符合数据分布的核函数；如果不知道的话，通常使用交叉验证的方法，来试用不同的核函数，误差最下的即为效果最好的核函数，或者也可以将多个核函数结合起来，形成混合核函数。在吴恩达的课上，也曾经给出过一系列的选择核函数的方法.</p></li></ol><p><strong><em>如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；<br>如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；<br>如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况。</em></strong></p><h2 id="5、为什么要将求解SVM的原始问题转换为其对偶问题？"><a href="#5、为什么要将求解SVM的原始问题转换为其对偶问题？" class="headerlink" title="5、为什么要将求解SVM的原始问题转换为其对偶问题？"></a>5、为什么要将求解SVM的原始问题转换为其对偶问题？</h2><ol><li>是对偶问题往往更易求解（当我们寻找约束存在时的最优点的时候，约束的存在虽然减小了需要搜寻的范围，但是却使问题变得更加复杂。为了使问题变得易于处理，<strong>把目标函数和约束全部融入一个新的函数，即拉格朗日函数，再通过这个函数来寻找最优点。</strong>）</li><li>自然引入核函数，进而推广到非线性分类问题。</li></ol><h2 id="6、SVM为什么可以处理非线性问题"><a href="#6、SVM为什么可以处理非线性问题" class="headerlink" title="6、SVM为什么可以处理非线性问题"></a>6、SVM为什么可以处理非线性问题</h2><p>非线性的话通过核函数将其隐射到高维空间，在高维空间非线性问题转化为线性问题。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>周志华的<br>《机器学习》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试必备&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>K-means原理及常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/06/kmeans/"/>
    <id>http://www.cygao.xyz/2019/09/06/kmeans/</id>
    <published>2019-09-06T00:33:55.000Z</published>
    <updated>2019-09-06T00:49:46.113Z</updated>
    
    <content type="html"><![CDATA[<p>主要关注伪代码，k怎么选择，初始点怎么选择，原理及优缺点。</p><a id="more"></a><h2 id="原理和流程"><a href="#原理和流程" class="headerlink" title="原理和流程"></a>原理和流程</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p> 对给定的<strong>无标记</strong>的样本数据集，事先确定<strong>聚类簇数K</strong>，让簇内的样本尽可能紧密分布在一起，使簇间的距离尽可能大。K-Means作为无监督的聚类算法，其类似于全自动分类，簇内越相似，聚类效果越好，实现较简单，聚类效果好，因此被广泛使用。用以下的效果图更能直观地看出其过程：<br> <img src="https://img-blog.csdnimg.cn/20190815155230514.gif" alt></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>随即确定K个初始点作为质心（这里如何确定k将在下面给出解释）  </li><li>将数据集中的每个点分配到一个簇中，即为每个点找距离其最近的质心，并将其分配给之心所对应的簇  </li><li>簇分好后，计算每个簇所有点的平均值，将平均值作为对应簇新的质心  </li><li><p>循环2、3步骤，直到质心不变</p><p><strong>伪代码是：</strong></p></li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建k个点作为起始质心（经常是随机选择）</span><br><span class="line">当任意一个点的簇分配结果发生改变时</span><br><span class="line">对数据集中的每个数据点</span><br><span class="line">对每个质心</span><br><span class="line">计算质心和数据点之间的距离</span><br><span class="line">将数据点分配到距离其最近的簇</span><br><span class="line">对每一个簇，计算簇中所有点的均值并将均值作为质心</span><br></pre></td></tr></table></figure><p> 上面“最近”质心，意味着需要进行<strong>某种距离</strong>的计算，即下文要介绍的K-means中常用的到中心距离的度量有哪些？</p><h2 id="K-means中常用的到中心距离的度量"><a href="#K-means中常用的到中心距离的度量" class="headerlink" title="K-means中常用的到中心距离的度量"></a>K-means中常用的到中心距离的度量</h2><p> 这里最常用的有以下两种</p><p> <strong>1、曼哈顿距离</strong><br> <img src="https://img-blog.csdnimg.cn/20190815155442301.png" alt><br> <strong>2、欧几里得距离</strong>（别称“欧式距离”）<br> <img src="https://img-blog.csdnimg.cn/2019081515485016.png" alt></p><h2 id="K-means中的k值如何选取-了解一下"><a href="#K-means中的k值如何选取-了解一下" class="headerlink" title="K-means中的k值如何选取(了解一下)"></a>K-means中的k值如何选取(了解一下)</h2><ul><li>手肘法</li><li>轮廓系数法</li></ul><h2 id="面试常见问题回答"><a href="#面试常见问题回答" class="headerlink" title="面试常见问题回答"></a>面试常见问题回答</h2><h3 id="1、K-means算法中初始点的选择对最终结果有影响吗？"><a href="#1、K-means算法中初始点的选择对最终结果有影响吗？" class="headerlink" title="1、K-means算法中初始点的选择对最终结果有影响吗？"></a>1、K-means算法中初始点的选择对最终结果有影响吗？</h3><p> 会有影响的，不同的初始值结果可能不一样</p><h3 id="2、K-means聚类中每个类别中心的初始点如何选择？"><a href="#2、K-means聚类中每个类别中心的初始点如何选择？" class="headerlink" title="2、K-means聚类中每个类别中心的初始点如何选择？"></a>2、K-means聚类中每个类别中心的初始点如何选择？</h3><p> （1）这k个点的距离尽可能远  </p><p> （2）可以对数据先进行<strong>层次聚类</strong>，得到K个簇之后，从每个类簇中选择一个点，该点可以是该类簇的中心点，或者是距离类簇中心点最近的那个点。</p><h3 id="3、K-means中空聚类的处理"><a href="#3、K-means中空聚类的处理" class="headerlink" title="3、K-means中空聚类的处理"></a>3、K-means中空聚类的处理</h3><p>（1）选择一个距离当前任何质心最远的点。这将消除当前对总平方误差影响最大的点。<br> （2）从具有最大SSE的簇中选择一个替补的质心，这将分裂簇并降低聚类的总SSE。如果有多个空簇，则该过程重复多次。<br> （3）如果噪点或者孤立点过多，考虑更换算法，如<strong>密度聚类</strong>。</p><h3 id="4、K-means是否会一直陷入选择质心的循环停不下来？-（1）迭代次数设置"><a href="#4、K-means是否会一直陷入选择质心的循环停不下来？-（1）迭代次数设置" class="headerlink" title="4、K-means是否会一直陷入选择质心的循环停不下来？ （1）迭代次数设置"></a>4、K-means是否会一直陷入选择质心的循环停不下来？ （1）迭代次数设置</h3><p> （2）设定收敛判断距离</p><h3 id="5、如何快速收敛数据量超大的K-means？-相关解释可以去这个博客稍做了解"><a href="#5、如何快速收敛数据量超大的K-means？-相关解释可以去这个博客稍做了解" class="headerlink" title="5、如何快速收敛数据量超大的K-means？ 相关解释可以去这个博客稍做了解"></a>5、如何快速收敛数据量超大的K-means？ 相关解释可以去这个博客稍做了解</h3><p> <a href="https://blog.csdn.net/sunnyxidian/article/details/89630815" target="_blank" rel="noopener">https://blog.csdn.net/sunnyxidian/article/details/89630815</a></p><h3 id="6、K-means算法的优点和缺点是什么？-K-Means的主要优点："><a href="#6、K-means算法的优点和缺点是什么？-K-Means的主要优点：" class="headerlink" title="6、K-means算法的优点和缺点是什么？ K-Means的主要优点："></a>6、K-means算法的优点和缺点是什么？ K-Means的<strong>主要优点</strong>：</h3><p> （1）原理简单，容易实现<br> （2）可解释度较强</p><h3 id="7、-K-Means的主要缺点："><a href="#7、-K-Means的主要缺点：" class="headerlink" title="7、 K-Means的主要缺点："></a>7、 K-Means的<strong>主要缺点</strong>：</h3><p> （1）K值很难确定<br> （2）局部最优<br> （3）对噪音和异常点敏感<br> （4）需样本存在均值（限定数据种类）<br> （5）聚类效果依赖于聚类中心的初始化<br> （6）对于非凸数据集或类别规模差异太大的数据效果不好</p><hr><p>参考 <a href="https://blog.csdn.net/WangZixuan1111/article/details/98970139" target="_blank" rel="noopener">https://blog.csdn.net/WangZixuan1111/article/details/98970139</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要关注伪代码，k怎么选择，初始点怎么选择，原理及优缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="聚类算法" scheme="http://www.cygao.xyz/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>L1正则&amp;L2正则常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/05/l1l2/"/>
    <id>http://www.cygao.xyz/2019/09/05/l1l2/</id>
    <published>2019-09-05T13:01:50.000Z</published>
    <updated>2019-09-05T13:23:22.929Z</updated>
    
    <content type="html"><![CDATA[<p>L1正则&amp;L2正则常考题目及解答。<br><a id="more"></a></p><ol><li>过拟合的解决方式有哪些，l1和l2正则化都有哪些不同，各自有什么优缺点(爱奇艺)</li><li>L1和L2正则化来避免过拟合是大家都知道的事情，而且我们都知道L1正则化可以得到稀疏解，L2正则化可以得到平滑解，这是为什么呢？</li><li>L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。（美团）</li><li>L1和L2的区别，以及各自的使用场景（头条）</li></ol><h2 id="什么是L1正则-amp-L2正则？"><a href="#什么是L1正则-amp-L2正则？" class="headerlink" title="什么是L1正则&amp;L2正则？"></a>什么是L1正则&amp;L2正则？</h2><p>L1正则即将参数的绝对值之和加入到损失函数中，以二元线性回归为例，损失函数变为：</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l11.png" alt></div><br>L2正则即将参数的平方之和加入到损失函数中，以二元线性回归为例，损失函数变为：<br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l12.png" alt></div> <h2 id="L1正则-amp-L2正则的区别是什么？"><a href="#L1正则-amp-L2正则的区别是什么？" class="headerlink" title="L1正则&amp;L2正则的区别是什么？"></a>L1正则&amp;L2正则的区别是什么？</h2><ol><li>L1正则化是指在损失函数中加入权值向量w的绝对值之和，即各个元素的绝对值之和，L2正则化指在损失函数中加入权值向量w的平方和。</li><li>L1的功能是使权重稀疏，而L2的功能是使权重平滑。</li></ol><h2 id="L1正则为什么可以得到稀疏解？"><a href="#L1正则为什么可以得到稀疏解？" class="headerlink" title="L1正则为什么可以得到稀疏解？"></a>L1正则为什么可以得到稀疏解？</h2><h3 id="解空间形状"><a href="#解空间形状" class="headerlink" title="解空间形状"></a>解空间形状</h3><p>L2正则化相当于为参数定义了一个圆形的解空间，而L1正则化相当于为参数定义了一个菱形的解空间。L1“棱角分明”的解空间显然更容易与目标函数等高线在脚点碰撞。从而产生稀疏解。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l13.jpg" alt></div> <p>其中变量 w 是动态参数，如果我们调节 w 就会得到一系列的圆，这也是你在上图中看到这么多圆线的原因，上图中其实假设了 w 参数只有二维，这样方便在图中表示，与此同时 L 的图像是一个旋转 90 度的矩形，图像中二者交点的位置就是可能出现最优解的地方，你会发现二者相交出现极大可能的位置就是顶点处，矩形顶点的地方肯定是由其中一个 w 为 0 的，w 为 0 则表示其中一个特征并不是我们需要的特征可以忽略不计，这就说明了 L1 会产生稀疏解的原因。</p><h2 id="L2为什么可以解决过拟合"><a href="#L2为什么可以解决过拟合" class="headerlink" title="L2为什么可以解决过拟合"></a>L2为什么可以解决过拟合</h2><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数 w 都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。若某个 w 参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果 w 参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。L2正则化就是可以使权重平滑。</p><h2 id="L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验"><a href="#L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验" class="headerlink" title="L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验"></a>L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;L1正则&amp;amp;L2正则常考题目及解答。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简单粗暴的BP图示及公式,CNN的BP及权值共享</title>
    <link href="http://www.cygao.xyz/2019/09/05/bp/"/>
    <id>http://www.cygao.xyz/2019/09/05/bp/</id>
    <published>2019-09-05T12:20:06.000Z</published>
    <updated>2019-09-19T09:05:10.380Z</updated>
    
    <content type="html"><![CDATA[<p>权值共享:同一层的每个感受野被卷积时，卷积参数都是相同的。<br>来源是Introduction to Deep Learning MIT 6.S191；<a href="https://blog.csdn.net/login_sonata/article/details/77488383" target="_blank" rel="noopener">https://blog.csdn.net/login_sonata/article/details/77488383</a>   </p><a id="more"></a><h2 id="BP"><a href="#BP" class="headerlink" title="BP"></a>BP</h2><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp1.png" alt></div> <div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp2.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp3.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp4.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp5.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp6.png" alt></div> <h1 id="卷积神经网络的反向传播："><a href="#卷积神经网络的反向传播：" class="headerlink" title="卷积神经网络的反向传播："></a>卷积神经网络的反向传播：</h1><p> 首先回顾一下一般的前馈神经网络的反向传播：<br> <img src="https://img-blog.csdn.net/20170824170432450" alt="这里写图片描述"><br> 详细内容可参看：<a href="http://blog.csdn.net/login_sonata/article/details/76737482" target="_blank" rel="noopener">神经网络基础和反向传播推导</a></p><h2 id="1，CNN的前向传播"><a href="#1，CNN的前向传播" class="headerlink" title="1，CNN的前向传播"></a>1，CNN的前向传播</h2><p> a）对于卷积层，卷积核与输入矩阵对应位置求积再求和，作为输出矩阵对应位置的值。如果输入矩阵inputX为M<em>N大小，卷积核为a</em>b大小，那么输出Y为（M-a+1）*（N-b+1）大小。<br> <img src="https://img-blog.csdn.net/20170824180524581" alt="这里写图片描述"><br> b）对于池化层，按照池化标准把输入张量缩小。<br> c）对于全连接层，按照普通网络的前向传播计算。</p><h2 id="2，CNN反向传播的不同之处："><a href="#2，CNN反向传播的不同之处：" class="headerlink" title="2，CNN反向传播的不同之处："></a>2，CNN反向传播的不同之处：</h2><p> 首先要注意的是，一般神经网络中每一层输入输出a,z都只是一个向量，<strong>而CNN中的a,z是一个三维张量</strong>，即由若干个输入的子矩阵组成。其次：</p><ol start="2"><li><strong>池化层没有激活函数</strong>。这个问题倒比较好解决，我们可以令池化层的激活函数为σ(z)=z，即激活后就是自己本身。这样池化层激活函数的导数为1。 </li><li>池化层在前向传播的时候，对输入进行了压缩，那么我们向前反向推导上一层的误差时，<strong>需要做upsample处理</strong>。 </li><li>卷积层是通过张量卷积，或者说<strong>若干个矩阵卷积求和而得到当前层的输出</strong>，这和一般的网络直接进行矩阵乘法得到当前层的输出不同。这样在卷积层反向传播的时候，上一层误差的递推计算方法肯定有所不同。 </li><li>对于卷积层，由于W使用的运算是卷积，那么由该层误差推导出该层的所有卷积核的W,b的方式也不同。  由于卷积层可以有多个卷积核，各个卷积核的处理方法是完全相同且独立的，为了简化算法公式的复杂度，我们下面提到卷积核都是卷积层中若干卷积核中的一个。接下来看具体的CNN反向传播步骤。</li></ol><h2 id="3，已知池化层的误差，反向推导上一隐藏层的误差"><a href="#3，已知池化层的误差，反向推导上一隐藏层的误差" class="headerlink" title="3，已知池化层的误差，反向推导上一隐藏层的误差"></a>3，已知池化层的误差，反向推导上一隐藏层的误差</h2><p> 在前向传播时，池化层我们会用MAX或者Average对输入进行池化，池化的区域大小已知。现在我们反过来，要从缩小后区域的误差，还原前一层较大区域的误差。这个过程叫做upsample。假设我们的池化区域大小是2x2。第l层误差的第k个子矩阵δlk为:<br> <img src="https://img-blog.csdn.net/20170824182603912" alt="这里写图片描述"><br> 如果池化区域表示为a*a大小，那么我们把上述矩阵上下左右各扩展a-1行和列进行<strong>还原</strong>：<br> <img src="https://img-blog.csdn.net/20170824181456863" alt="这里写图片描述"><br> 如果是MAX，假设我们之前在前向传播时记录的最大值位置分别是左上，右下，右上，左下，则转换后的矩阵为：<br> <img src="https://img-blog.csdn.net/20170824183635544" alt="这里写图片描述"><br> 如果是Average，则进行平均，转换后的矩阵为：<br> <img src="https://img-blog.csdn.net/20170824183714077" alt="这里写图片描述"><br> 上边这个矩阵就是误差矩阵经过upsample之后的矩阵，那么，由后一层误差推导出前一层误差的公式为：<br> <img src="https://img-blog.csdn.net/20170826144238437" alt="这里写图片描述"><br> 上式和普通网络的反向推导误差很类似：<br> <img src="https://img-blog.csdn.net/20170826145756406" alt="这里写图片描述"><br> 可以看到，只有第一项不同。</p><h2 id="4，已知卷积层的误差，反向推导上一隐藏层的误差"><a href="#4，已知卷积层的误差，反向推导上一隐藏层的误差" class="headerlink" title="4，已知卷积层的误差，反向推导上一隐藏层的误差"></a>4，已知卷积层的误差，反向推导上一隐藏层的误差</h2><p> 公式如下：<br> <img src="https://img-blog.csdn.net/20170826150333441" alt="这里写图片描述"><br> 我们再看一次普通网络的反向推导误差的公式：<br> <img src="https://img-blog.csdn.net/20170826145756406" alt="这里写图片描述"><br> 可以看到区别在于，下一层的权重w的转置操作，变成了旋转180度的操作，也就是上下翻转一次，左右再翻转一次，这其实就是“卷积”一词的意义（我们可简单理解为数学上的trick），可参考下图，Q是下一层的误差，周围补0方便计算，W是180度翻转后的卷积核，P是W和Q做卷积的结果：<br> <img src="https://img-blog.csdn.net/20170826151721741" alt="这里写图片描述"></p><h2 id="5，已知卷积层的误差，推导该层的W-b的梯度"><a href="#5，已知卷积层的误差，推导该层的W-b的梯度" class="headerlink" title="5，已知卷积层的误差，推导该层的W,b的梯度"></a>5，已知卷积层的误差，推导该层的W,b的梯度</h2><p> 经过以上各步骤，我们已经算出每一层的误差了，那么：<br> a）对于全连接层，可以按照普通网络的反向传播算法求该层W,b的梯度。<br> b）对于池化层，它并没有W,b,也不用求W,b的梯度。<br> c）只有卷积层的W,b需要求出，先看w：<br> <img src="https://img-blog.csdn.net/20170826154408701" alt="这里写图片描述"><br> 再对比一下普通网络的求w梯度的公式，发现区别在于，对前一层的输出做翻转180度的操作：<br> <img src="https://img-blog.csdn.net/20170826154512559" alt="这里写图片描述"><br> 而对于b,则稍微有些特殊，因为在CNN中，误差δ是三维张量，而b只是一个向量，不能像普通网络中那样直接和误差δ相等。通常的做法是将误差δ的各个子矩阵的项分别求和，得到一个误差向量，即为b的梯度：<br> <img src="https://img-blog.csdn.net/20170826155032222" alt="这里写图片描述"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权值共享:同一层的每个感受野被卷积时，卷积参数都是相同的。&lt;br&gt;来源是Introduction to Deep Learning MIT 6.S191；&lt;a href=&quot;https://blog.csdn.net/login_sonata/article/details/77488383&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/login_sonata/article/details/77488383&lt;/a&gt;   &lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>主成分分析PCA原理和执行步骤</title>
    <link href="http://www.cygao.xyz/2019/09/05/pca/"/>
    <id>http://www.cygao.xyz/2019/09/05/pca/</id>
    <published>2019-09-05T02:27:21.000Z</published>
    <updated>2019-09-05T11:41:04.569Z</updated>
    
    <content type="html"><![CDATA[<p>主成分分析（PCA）特征选择算法简介，包含适用场景。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PCA全称Principal Component Analysis，即主成分分析，是一种常用的数据降维方法。它可以通过<strong>线性变换</strong>将原始数据变换为一组各维度<strong>线性无关</strong>的表示，以此来提取数据的<strong>主要线性分量</strong>。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>我们在处理实际问题的时候，进行特征提取过程中，提取的特征维数太多经常会导致特征匹配时过于复杂，消耗计算资源。</p><hr><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><hr><ol><li>线性变换=&gt;新特征轴可由原始特征轴线性变换表征</li><li>线性无关=&gt;构建的特征轴是正交的</li><li>主要线性分量（或者说是主成分）=&gt;方差加大的方向</li><li>PCA算法的求解就是找到主要线性分量及其表征方式的过程</li></ol><hr><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>假设有m个样例，n维特征</p><ol><li>对每一维特征进行零均值化，即减去均值</li><li>再求特征协方差矩阵</li><li>求改协方差矩阵的特征值和特征向量</li><li>将特征值按照从大到小的顺序排序，并选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</li><li>将样本点投影到选取的特征向量上，假设有m个样例，n维特征，零均值化后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为:</li></ol><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/pca.png" alt></div> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主成分分析（PCA）特征选择算法简介，包含适用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>NMS算法（NonMaximumSuppression）</title>
    <link href="http://www.cygao.xyz/2019/09/05/nms/"/>
    <id>http://www.cygao.xyz/2019/09/05/nms/</id>
    <published>2019-09-05T01:58:02.000Z</published>
    <updated>2019-09-05T12:34:12.670Z</updated>
    
    <content type="html"><![CDATA[<p>NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。</p><a id="more"></a><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><hr><p>非极大值抑制（NMS）顾名思义就是抑制不是极大值的元素，搜索局部的极大值。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。这里不讨论通用的NMS算法，而是用于在目标检测中用于提取分数最高的窗口的。<br>例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si ,  1&lt;=i&lt;=N。</p><ol><li><p>建造一个存放待处理候选框的集合H，初始化为包含全部N个框；建造一个存放最优框的集合M，初始化为空集。</p></li><li><p>将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p></li><li><p>遍历集合 H 中的框，分别与框m计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m重叠，将此框从集合 H 中去除。</p></li><li><p>回到第2步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p></li></ol><h3 id="需要优化的参数"><a href="#需要优化的参数" class="headerlink" title="需要优化的参数"></a>需要优化的参数</h3><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。</p><hr><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">py_cpu_nms</span><span class="hljs-params">(dets, thresh)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""Pure Python NMS baseline."""</span></span><br><span class="line">    <span class="hljs-comment">#x1、y1、x2、y2、以及score赋值</span></span><br><span class="line">    x1 = dets[:, <span class="hljs-number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="hljs-number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="hljs-number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="hljs-number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="hljs-number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">#每一个检测框的面积</span></span><br><span class="line">    areas = (x2 - x1 + <span class="hljs-number">1</span>) * (y2 - y1 + <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-comment">#按照score置信度降序排序</span></span><br><span class="line">    order = scores.argsort()[::<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">    keep = [] <span class="hljs-comment">#保留的结果框集合</span></span><br><span class="line">    <span class="hljs-keyword">while</span> order.size &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        i = order[<span class="hljs-number">0</span>]</span><br><span class="line">        keep.append(i) <span class="hljs-comment">#保留该类剩余box中得分最高的一个</span></span><br><span class="line">        <span class="hljs-comment">#得到相交区域,左上及右下</span></span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="hljs-number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#计算相交的面积,不重叠时面积为0</span></span><br><span class="line">        w = np.maximum(<span class="hljs-number">0.0</span>, xx2 - xx1 + <span class="hljs-number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="hljs-number">0.0</span>, yy2 - yy1 + <span class="hljs-number">1</span>)</span><br><span class="line">        inter = w * h</span><br><span class="line">        <span class="hljs-comment">#计算IoU：重叠面积 /（面积1+面积2-重叠面积）</span></span><br><span class="line">        ovr = inter / (areas[i] + areas[order[<span class="hljs-number">1</span>:]] - inter)</span><br><span class="line">        <span class="hljs-comment">#保留IoU小于阈值的box</span></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="hljs-number">0</span>]</span><br><span class="line">        order = order[inds + <span class="hljs-number">1</span>] <span class="hljs-comment">#因为ovr数组的长度比order数组少一个,所以这里要将所有下标后移一位</span></span><br><span class="line">       </span><br><span class="line">    <span class="hljs-keyword">return</span> keep</span><br><span class="line">`</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="检测算法" scheme="http://www.cygao.xyz/tags/%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法面试通关40讲总结</title>
    <link href="http://www.cygao.xyz/2019/08/22/algorithm40/"/>
    <id>http://www.cygao.xyz/2019/08/22/algorithm40/</id>
    <published>2019-08-22T02:43:23.000Z</published>
    <updated>2019-09-02T01:53:04.951Z</updated>
    
    <content type="html"><![CDATA[<p>知识图谱的形式总结极客时间的算法面试通关40讲课程<br><a id="more"></a></p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/algorithm.jpg" alt></div> <div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/algorithm2.jpg" alt></div> <p>转载自链接：<a href="https://blog.csdn.net/xushuanglu_csdn/article/details/87165984" target="_blank" rel="noopener">https://blog.csdn.net/xushuanglu_csdn/article/details/87165984</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知识图谱的形式总结极客时间的算法面试通关40讲课程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="基本算法" scheme="http://www.cygao.xyz/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【python】冒泡，选择，插入，希尔，快速，归并排序的实现及图解</title>
    <link href="http://www.cygao.xyz/2019/08/13/sort/"/>
    <id>http://www.cygao.xyz/2019/08/13/sort/</id>
    <published>2019-08-13T04:54:16.000Z</published>
    <updated>2019-09-02T01:52:52.105Z</updated>
    
    <content type="html"><![CDATA[<p>总结基本的排序算法。<br><a id="more"></a></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>冒泡排序</strong>（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了<strong>最后一个</strong>。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  </li></ul><p>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示： </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort1.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>):</span><br><span class="line">        count = <span class="hljs-number">0</span>  <span class="hljs-comment">#利用count进行优化，如果中间有一次不交换了，则证明已经排序完毕</span></span><br><span class="line">        <span class="hljs-comment"># j表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>-j):</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[i] &gt; alist[i+<span class="hljs-number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="hljs-number">1</span>] = alist[i+<span class="hljs-number">1</span>], alist[i]</span><br><span class="line">                count+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）需要加上count进行判断。</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定<h2 id="冒泡排序的演示"><a href="#冒泡排序的演示" class="headerlink" title="冒泡排序的演示"></a>冒泡排序的演示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort2.gif" alt></div> </li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="hljs-comment"># 需要进行n-1次选择操作</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>):</span><br><span class="line">        <span class="hljs-comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="hljs-comment"># 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, n):</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="hljs-comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n2)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定（考虑升序每次选择最大的情况）</li></ul><h2 id="选择排序的演示"><a href="#选择排序的演示" class="headerlink" title="选择排序的演示"></a>选择排序的演示</h2><p>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort3.gif" alt></div> <h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(alist)):</span><br><span class="line">        <span class="hljs-comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[j] &lt; alist[j<span class="hljs-number">-1</span>]:</span><br><span class="line">                alist[j], alist[j<span class="hljs-number">-1</span>] = alist[j<span class="hljs-number">-1</span>], alist[j]</span><br><span class="line">                j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）每次都直接break，跳出循环</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定</li></ul><h2 id="插入排序的演示"><a href="#插入排序的演示" class="headerlink" title="插入排序的演示"></a>插入排序的演示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort4.gif" alt></div><br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort5.gif" alt></div> <h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>希尔排序</strong>(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><blockquote><p>python2和python3里的整除分别对应 <strong>/</strong> 和 <strong>//</strong>。</p></blockquote><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="hljs-comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-keyword">while</span> gap &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="hljs-comment"># 插入排序</span></span><br><span class="line">            <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> alist[j-gap] &gt; alist[j]:</span><br><span class="line">                    alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n2)</li><li>稳定想：不稳定</li></ul><h2 id="希尔排序的图示"><a href="#希尔排序的图示" class="headerlink" title="希尔排序的图示"></a>希尔排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/shellsort.png" alt></div> <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序</strong>（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(alist, start, end)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""快速排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 递归的退出条件</span></span><br><span class="line">    <span class="hljs-keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="hljs-comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="hljs-comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low<span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="hljs-number">1</span>, end)</span><br><span class="line"></span><br><span class="line">alist = [<span class="hljs-number">54</span>,<span class="hljs-number">26</span>,<span class="hljs-number">93</span>,<span class="hljs-number">17</span>,<span class="hljs-number">77</span>,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">20</span>]</span><br><span class="line">quick_sort(alist,<span class="hljs-number">0</span>,len(alist)<span class="hljs-number">-1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p><h2 id="快速排序的图示"><a href="#快速排序的图示" class="headerlink" title="快速排序的图示"></a>快速排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/quicksort.jpg" alt></div> <h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>归并排序</strong>是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p><p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) &lt;= <span class="hljs-number">1</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> alist</span><br><span class="line">    <span class="hljs-comment"># 二分分解</span></span><br><span class="line">    num = len(alist)/<span class="hljs-number">2</span></span><br><span class="line">    left = merge_sort(alist[:num])</span><br><span class="line">    right = merge_sort(alist[num:])</span><br><span class="line">    <span class="hljs-comment"># 合并</span></span><br><span class="line">    <span class="hljs-keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right)</span>:</span></span><br><span class="line">    <span class="hljs-string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    <span class="hljs-comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="hljs-keyword">while</span> l&lt;len(left) <span class="hljs-keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="hljs-keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="hljs-number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line"></span><br><span class="line">alist = [<span class="hljs-number">54</span>,<span class="hljs-number">26</span>,<span class="hljs-number">93</span>,<span class="hljs-number">17</span>,<span class="hljs-number">77</span>,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">20</span>]</span><br><span class="line">sorted_alist = mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(nlogn)</li><li>稳定性：稳定</li></ul><h2 id="归并排序的图示"><a href="#归并排序的图示" class="headerlink" title="归并排序的图示"></a>归并排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/mergesort.gif" alt></div> <h1 id="常见排序算法效率比较"><a href="#常见排序算法效率比较" class="headerlink" title="常见排序算法效率比较"></a>常见排序算法效率比较</h1><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/compare.png" alt></div> <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找</p><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(alist, item)</span>:</span></span><br><span class="line">      first = <span class="hljs-number">0</span></span><br><span class="line">      last = len(alist)<span class="hljs-number">-1</span></span><br><span class="line">      <span class="hljs-keyword">while</span> first&lt;=last:</span><br><span class="line">          midpoint = (first + last)/<span class="hljs-number">2</span></span><br><span class="line">          <span class="hljs-keyword">if</span> alist[midpoint] == item:</span><br><span class="line">              <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">          <span class="hljs-keyword">elif</span> item &lt; alist[midpoint]:</span><br><span class="line">              last = midpoint<span class="hljs-number">-1</span></span><br><span class="line">          <span class="hljs-keyword">else</span>:</span><br><span class="line">              first = midpoint+<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">testlist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">13</span>))</span><br></pre></td></tr></table></figure><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(alist, item)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) == <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        midpoint = len(alist)//<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">if</span> alist[midpoint]==item:</span><br><span class="line">          <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">          <span class="hljs-keyword">if</span> item&lt;alist[midpoint]:</span><br><span class="line">            <span class="hljs-keyword">return</span> binary_search(alist[:midpoint],item)</span><br><span class="line">          <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> binary_search(alist[midpoint+<span class="hljs-number">1</span>:],item)</span><br><span class="line"></span><br><span class="line">testlist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">13</span>))</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(1)</li><li>最坏时间复杂度：O(logn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结基本的排序算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="基本算法" scheme="http://www.cygao.xyz/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【python】 多种链表的实现及python中“=”的解读</title>
    <link href="http://www.cygao.xyz/2019/08/12/linked%20list/"/>
    <id>http://www.cygao.xyz/2019/08/12/linked list/</id>
    <published>2019-08-12T08:54:16.000Z</published>
    <updated>2019-09-02T01:52:29.519Z</updated>
    
    <content type="html"><![CDATA[<p>python中“=”的正确、简单好记的理解以及python链表的实现。<br><a id="more"></a></p><h1 id="python中“-”的理解"><a href="#python中“-”的理解" class="headerlink" title="python中“=”的理解"></a>python中“=”的理解</h1><p>python并不像是c/c++，c++中新建一个变量，比如<code>int a = 3</code>，此时必须申明变量的类型，找一块内存空间存储3，这个内存空间的别名是a，占4个字节且a只能存整数。</p><p>python中并不需要申明类型，<code>a  = 10</code>这种隐式申明的的原因是，a是另外一个内存，保存的是一个地址，地址指向什么就代表a是什么。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def C():</span><br><span class="line">    pass</span><br><span class="line">a = C</span><br></pre></td></tr></table></figure></p><p>a可以重新指向一个方法，类或是对象中的元素都行。所以 <strong>=</strong> 只能代表把指向更改，指向了什么。</p><h1 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleNode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单链表的结点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># _item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="hljs-comment"># _next是下一个节点的标识</span></span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><h1 id="单链表的实现及部分操作"><a href="#单链表的实现及部分操作" class="headerlink" title="单链表的实现及部分操作"></a>单链表的实现及部分操作</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkList</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.__head = <span class="hljs-literal">None</span> </span><br><span class="line">        <span class="hljs-comment">#__双下划线代表私有变量/方法</span></span><br><span class="line">        <span class="hljs-comment">#_但下划线代表保护变量/方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.__head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""链表长度"""</span></span><br><span class="line">        <span class="hljs-comment"># cur初始时指向头节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 尾节点指向None，当未到达尾部时</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment"># 将cur后移一个节点</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            print(cur.item,end=<span class="hljs-string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line"> ```       </span><br><span class="line"><span class="hljs-comment">## 头部添加元素 </span></span><br><span class="line">```python</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部添加元素"""</span></span><br><span class="line">        <span class="hljs-comment"># 先创建一个保存item值的节点</span></span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        <span class="hljs-comment"># 将新节点的链接域next指向头节点，即_head指向的位置</span></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        <span class="hljs-comment"># 将链表的头_head指向新节点</span></span><br><span class="line">        self.__head = node</span><br></pre></td></tr></table></figure><h2 id="尾部添加元素"><a href="#尾部添加元素" class="headerlink" title="尾部添加元素"></a>尾部添加元素</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""尾部添加元素"""</span></span><br><span class="line">    node = SingleNode(item)</span><br><span class="line">    <span class="hljs-comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="hljs-comment"># 若不为空，则找到尾部，将尾节点的next指向新节点</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != <span class="hljs-literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br></pre></td></tr></table></figure><h2 id="指定位置添加元素"><a href="#指定位置添加元素" class="headerlink" title="指定位置添加元素"></a>指定位置添加元素</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link1.png" alt></div><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""指定位置添加元素"""</span></span><br><span class="line">    <span class="hljs-comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">    <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">        self.add(item)</span><br><span class="line">    <span class="hljs-comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">        self.append(item)</span><br><span class="line">    <span class="hljs-comment"># 找到指定位置</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="hljs-comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">        node.next = pre.next</span><br><span class="line">        <span class="hljs-comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">        pre.next = node</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link2.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""删除节点"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    pre = <span class="hljs-literal">None</span></span><br><span class="line">    <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-comment"># 找到了指定元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-comment"># 如果第一个就是删除的节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre:</span><br><span class="line">                <span class="hljs-comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                self.__head = cur.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 继续按链表后移节点</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br></pre></td></tr></table></figure><h2 id="查找节点是否存在"><a href="#查找节点是否存在" class="headerlink" title="查找节点是否存在"></a>查找节点是否存在</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""链表查找节点是否存在，并返回True或者False"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><h1 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h1><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。<br>链表与顺序表的各种操作复杂度如下所示：</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link3.png" alt></div> <p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p><h1 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h1><p>单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link4.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""节点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinCycLinkedlist</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单向循环链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""返回链表的长度"""</span></span><br><span class="line">        <span class="hljs-comment"># 如果链表为空，返回长度0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment">#添加的节点指向_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="hljs-comment"># 移到链表尾部，将尾部节点的next指向node</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment">#_head指向添加node的</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""尾部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 移到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将尾节点指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment"># 将node指向头节点_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""删除一个节点"""</span></span><br><span class="line">        <span class="hljs-comment"># 若链表为空，则直接返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        <span class="hljs-comment"># 将cur指向头节点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 若头节点的元素就是要查找的元素item</span></span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-comment"># 如果链表不止一个节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> cur.next != self._head:</span><br><span class="line">                <span class="hljs-comment"># 先找到尾节点，将尾节点的next指向第二个节点</span></span><br><span class="line">                <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="hljs-comment"># cur指向了尾节点</span></span><br><span class="line">                cur.next = self._head.next</span><br><span class="line">                self._head = self._head.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 链表只有一个节点</span></span><br><span class="line">                self._head = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="hljs-comment"># 第一个节点不是要删除的</span></span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                <span class="hljs-comment"># 找到了要删除的元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="hljs-comment"># 删除</span></span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="hljs-keyword">return</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># cur 指向尾节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-comment"># 尾部删除</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""查找节点是否存在"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    ll = SinCycLinkedlist()</span><br><span class="line">    ll.add(<span class="hljs-number">1</span>)</span><br><span class="line">    ll.add(<span class="hljs-number">2</span>)</span><br><span class="line">    ll.append(<span class="hljs-number">3</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">3</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">7</span>)</span><br><span class="line">    ll.remove(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。  </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link5.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""双向链表节点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br><span class="line">        self.prev = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkList</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""双向链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""返回链表的长度"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="hljs-comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head.prev = node</span><br><span class="line">            <span class="hljs-comment"># 将_head 指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""尾部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 移动到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != <span class="hljs-literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""查找元素是否存在"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line">            <span class="hljs-comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            node.next = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            <span class="hljs-comment"># 将cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""删除元素"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> cur.next == <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-comment"># 如果链表只有这一个节点</span></span><br><span class="line">                    self._head = <span class="hljs-literal">None</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    cur.next.prev = <span class="hljs-literal">None</span></span><br><span class="line">                    <span class="hljs-comment"># 将_head指向第二个节点</span></span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                <span class="hljs-keyword">return</span></span><br><span class="line">            <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="hljs-comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="hljs-comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                cur = cur.next</span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="hljs-number">1</span>)</span><br><span class="line">    ll.add(<span class="hljs-number">2</span>)</span><br><span class="line">    ll.append(<span class="hljs-number">3</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">3</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">4</span>)</span><br><span class="line">    ll.remove(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中“=”的正确、简单好记的理解以及python链表的实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 list的基本实现</title>
    <link href="http://www.cygao.xyz/2019/08/12/list/"/>
    <id>http://www.cygao.xyz/2019/08/12/list/</id>
    <published>2019-08-12T08:26:12.000Z</published>
    <updated>2019-09-02T01:52:33.732Z</updated>
    
    <content type="html"><![CDATA[<p>总结python在list中的原理和实现。<br><a id="more"></a></p><h1 id="python中list的基本实现技术"><a href="#python中list的基本实现技术" class="headerlink" title="python中list的基本实现技术"></a>python中list的基本实现技术</h1><h2 id="元素外置的顺序表"><a href="#元素外置的顺序表" class="headerlink" title="元素外置的顺序表"></a>元素外置的顺序表</h2><p>python中的list可以存放不同类型的数据，比如int，char，float等等，这些数据元素大小不同，所以得用到外置顺序表。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="hljs-number">1</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-number">2.2</span>]</span><br></pre></td></tr></table></figure></p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list1.png" alt></div>  <blockquote><p>Loc(li) = Loc(l0) + c*i </p></blockquote><p>元素的大小不统一，则须采用如图的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。<br>如图这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h2><p>一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list2.png" alt></div><br>python中的list主要采用分离式结构，如图<br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list3.png" alt></div>  <p>表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。这样在进行扩充的时候，数据的迁移，不用迁徙表头，指针指向的地址改变就行。</p><h2 id="list的数据扩充"><a href="#list的数据扩充" class="headerlink" title="list的数据扩充"></a>list的数据扩充</h2><p>在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结python在list中的原理和实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈的应用，括号匹配问题，中缀、后缀表达式</title>
    <link href="http://www.cygao.xyz/2019/08/12/stack/"/>
    <id>http://www.cygao.xyz/2019/08/12/stack/</id>
    <published>2019-08-12T04:54:16.000Z</published>
    <updated>2019-08-29T13:46:32.268Z</updated>
    
    <content type="html"><![CDATA[<p>主要是中缀、后缀表达式的转换。<br><a id="more"></a></p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.符号匹配<br>2.计算机表达式的转换<br>3.CPU内部栈主要是用来进行子程序调用和返回<br>4.进制转换  </p><h3 id="1-括号匹配问题"><a href="#1-括号匹配问题" class="headerlink" title="1.括号匹配问题"></a>1.括号匹配问题</h3><p>大多数计算机语言中都需要检测括号是否匹配，那么如何实现符号成对检测？  </p><p><strong>算法思路</strong>：</p><ul><li>从第一个字符开始扫描</li><li>当遇见普通字符时忽略，</li><li>当遇见左符号时压入栈中</li><li>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</li><li>匹配成功：继续读入下一个字符</li><li>匹配失败：立即停止，并报错</li><li>结束：<br>成功: 所有字符扫描完毕，且栈为空<br>失败：匹配失败或所有字符扫描完毕但栈非空</li></ul><h3 id="2-计算机表达式转换"><a href="#2-计算机表达式转换" class="headerlink" title="2.计算机表达式转换"></a>2.计算机表达式转换</h3><p>计算机的本质工作就是做数学运算，那计算机可以读入字符串<br>“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？</p><p><strong>中缀表达式和后缀表达式</strong><br>后缀表达式（由波兰科学家在20世纪50年代提出）<br>将运算符放在数字后面 ===》 符合计算机运算<br>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯<br>实例<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 =&gt; 5 4 +    </span><br><span class="line">1 + 2 * 3 =&gt; 1 2 3 * +    </span><br><span class="line">8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * +</span><br></pre></td></tr></table></figure></p><p><strong>算法思路</strong><br>中缀转后缀：<br>遍历中缀表达式中的数字和符号</p><ul><li>对于数字：直接输出</li><li>对于符号：  </li></ul><p>（1）左括号：进栈<br>（2）运算符号：与栈顶符号进行优先级比较<br>若栈顶符号优先级低：此符号进栈<br>（默认栈顶若是左括号，左括号优先级最低）<br>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈<br>（3）右括号：将栈顶符号弹出并输出，直到匹配左括号   </p><ul><li>遍历结束：将栈中的所有符号弹出并输出</li></ul><blockquote><p><strong>计算机如何基于后缀表达式结算结果</strong><br>例如：8 3 1 – 5 * +</p></blockquote><ul><li>计算规则：  </li><li>遍历后缀表达式中的数字和符号  </li><li>对于数字：进栈  </li><li>对于符号：<br>（1）从栈中弹出右操作数<br>（2）从栈中弹出左操作数<br>根据符号进行运算<br>将运算结果压入栈中<br>遍历结束：栈中的唯一数字为计算结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是中缀、后缀表达式的转换。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 timeit模块,list及dict操作复杂度</title>
    <link href="http://www.cygao.xyz/2019/08/12/python%20timeit/"/>
    <id>http://www.cygao.xyz/2019/08/12/python timeit/</id>
    <published>2019-08-12T01:01:55.000Z</published>
    <updated>2019-09-02T01:52:40.212Z</updated>
    
    <content type="html"><![CDATA[<p>简单减少一个性能分析的模块timeit，以及利用该模块测试list及dict的一些基本操作。<br><a id="more"></a></p><h1 id="Python内置类型性能分析"><a href="#Python内置类型性能分析" class="headerlink" title="Python内置类型性能分析"></a>Python内置类型性能分析</h1><h2 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h2><p>timeit模块可以用来测试一小段Python代码的执行速度。</p><h3 id="class-timeit-Timer-stmt-’pass’-setup-’pass’-timer"><a href="#class-timeit-Timer-stmt-’pass’-setup-’pass’-timer" class="headerlink" title="class timeit.Timer(stmt=’pass’, setup=’pass’ timer=)"></a>class timeit.Timer(stmt=’pass’, setup=’pass’ timer=<timer function>)</timer></h3><p>Timer是测量小段代码执行速度的类。</p><p>stmt参数是要测试的代码语句（statment）；</p><p>setup参数是运行代码时需要的设置；</p><p>timer参数是一个定时器函数，与平台有关。</p><h3 id="timeit-Timer-timeit-number-1000000"><a href="#timeit-Timer-timeit-number-1000000" class="headerlink" title="timeit.Timer.timeit(number=1000000)"></a>timeit.Timer.timeit(number=1000000)</h3><p>Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p><h2 id="比较list的操作复杂度"><a href="#比较list的操作复杂度" class="headerlink" title="比较list的操作复杂度"></a>比较list的操作复杂度</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):</span><br><span class="line">      l = l + [i] <span class="hljs-comment">#会先创建一个新的列表l + [i]再赋值到新的l上，效率很差。尽量使用l+=[i]，已在python内部优化了。 </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):</span><br><span class="line">      l.append(i)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>)]</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = list(range(<span class="hljs-number">1000</span>))</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l =[]</span><br><span class="line">   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):</span><br><span class="line">      l.extend([i]) <span class="hljs-comment"># 类似于 l+=[i]，是直接在列表l上操作</span></span><br><span class="line"><span class="hljs-keyword">from</span> timeit <span class="hljs-keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line">t1 = Timer(<span class="hljs-string">"test1()"</span>, <span class="hljs-string">"from __main__ import test1"</span>)</span><br><span class="line">print(<span class="hljs-string">"concat "</span>,t1.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t2 = Timer(<span class="hljs-string">"test2()"</span>, <span class="hljs-string">"from __main__ import test2"</span>)</span><br><span class="line">print(<span class="hljs-string">"append "</span>,t2.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t3 = Timer(<span class="hljs-string">"test3()"</span>, <span class="hljs-string">"from __main__ import test3"</span>)</span><br><span class="line">print(<span class="hljs-string">"comprehension "</span>,t3.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="hljs-string">"test4()"</span>, <span class="hljs-string">"from __main__ import test4"</span>)</span><br><span class="line">print(<span class="hljs-string">"list range "</span>,t4.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="hljs-string">"test5()"</span>, <span class="hljs-string">"from __main__ import test5"</span>)</span><br><span class="line">print(<span class="hljs-string">"extend "</span>,t5.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line"><span class="hljs-comment"># ('concat ', 1.7890608310699463, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('append ', 0.13796091079711914, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('comprehension ', 0.05671119689941406, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('list range ', 0.014147043228149414, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('extend ', 0.12147043228149414, 'seconds')</span></span><br></pre></td></tr></table></figure><blockquote><p>list range(迭代转化) &lt; comprehension(包含) &lt; extend &lt; append &lt; concat </p></blockquote><h3 id="pop操作比较"><a href="#pop操作比较" class="headerlink" title="pop操作比较"></a>pop操作比较</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="hljs-number">2000000</span>)</span><br><span class="line">pop_zero = Timer(<span class="hljs-string">"x.pop(0)"</span>,<span class="hljs-string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="hljs-string">"pop_zero "</span>,pop_zero.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">x = range(<span class="hljs-number">2000000</span>)</span><br><span class="line">pop_end = Timer(<span class="hljs-string">"x.pop()"</span>,<span class="hljs-string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="hljs-string">"pop_end "</span>,pop_end.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># ('pop_zero ', 1.9101738929748535, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('pop_end ', 0.00023603439331054688, 'seconds')</span></span><br></pre></td></tr></table></figure><blockquote><p>测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素</p></blockquote><h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</span><br><span class="line">l1[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>] <span class="hljs-comment">#可以是任意长度</span></span><br><span class="line">&gt;&gt; l1 = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br></pre></td></tr></table></figure><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/python1.png" alt></div>  <div align="center">!<img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/python2.png" alt></div>  ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单减少一个性能分析的模块timeit，以及利用该模块测试list及dict的一些基本操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
