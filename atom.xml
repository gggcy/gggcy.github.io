<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哲人存远</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cygao.xyz/"/>
  <updated>2019-08-19T08:11:41.298Z</updated>
  <id>http://www.cygao.xyz/</id>
  
  <author>
    <name>Cunyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【python】冒泡，选择，插入，希尔，快速，归并排序的实现及图解</title>
    <link href="http://www.cygao.xyz/2019/08/13/sort/"/>
    <id>http://www.cygao.xyz/2019/08/13/sort/</id>
    <published>2019-08-13T04:54:16.000Z</published>
    <updated>2019-08-19T08:11:41.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>冒泡排序</strong>（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br><a id="more"></a></p><p>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了<strong>最后一个</strong>。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  </li></ul><p>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示： </p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/sort1.png" alt></div> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        count = <span class="number">0</span>  <span class="comment">#利用count进行优化，如果中间有一次不交换了，则证明已经排序完毕</span></span><br><span class="line">        <span class="comment"># j表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>-j):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）需要加上count进行判断。</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定<h2 id="冒泡排序的演示"><a href="#冒泡排序的演示" class="headerlink" title="冒泡排序的演示"></a>冒泡排序的演示</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/sort2.gif" alt></div> </li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 需要进行n-1次选择操作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="comment"># 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n2)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定（考虑升序每次选择最大的情况）</li></ul><h2 id="选择排序的演示"><a href="#选择排序的演示" class="headerlink" title="选择排序的演示"></a>选择排序的演示</h2><p>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 </p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/sort3.gif" alt></div> <h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(alist)):</span><br><span class="line">        <span class="comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[j<span class="number">-1</span>]:</span><br><span class="line">                alist[j], alist[j<span class="number">-1</span>] = alist[j<span class="number">-1</span>], alist[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）每次都直接break，跳出循环</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定</li></ul><h2 id="插入排序的演示"><a href="#插入排序的演示" class="headerlink" title="插入排序的演示"></a>插入排序的演示</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/sort4.gif" alt></div><br><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/sort5.gif" alt></div> <h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>希尔排序</strong>(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><blockquote><p>python2和python3里的整除分别对应 <strong>/</strong> 和 <strong>//</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[j-gap] &gt; alist[j]:</span><br><span class="line">                    alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n2)</li><li>稳定想：不稳定</li></ul><h2 id="希尔排序的图示"><a href="#希尔排序的图示" class="headerlink" title="希尔排序的图示"></a>希尔排序的图示</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/shellsort.png" alt></div> <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序</strong>（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(alist, start, end)</span>:</span></span><br><span class="line">    <span class="string">"""快速排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归的退出条件</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">quick_sort(alist,<span class="number">0</span>,len(alist)<span class="number">-1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p><h2 id="快速排序的图示"><a href="#快速排序的图示" class="headerlink" title="快速排序的图示"></a>快速排序的图示</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/quicksort.jpg" alt></div> <h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>归并排序</strong>是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p><p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(alist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    num = len(alist)/<span class="number">2</span></span><br><span class="line">    left = merge_sort(alist[:num])</span><br><span class="line">    right = merge_sort(alist[num:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    <span class="comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">sorted_alist = mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(nlogn)</li><li>稳定性：稳定</li></ul><h2 id="归并排序的图示"><a href="#归并排序的图示" class="headerlink" title="归并排序的图示"></a>归并排序的图示</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/mergesort.gif" alt></div> <h1 id="常见排序算法效率比较"><a href="#常见排序算法效率比较" class="headerlink" title="常见排序算法效率比较"></a>常见排序算法效率比较</h1><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/compare.png" alt></div> <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找</p><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(alist, item)</span>:</span></span><br><span class="line">      first = <span class="number">0</span></span><br><span class="line">      last = len(alist)<span class="number">-1</span></span><br><span class="line">      <span class="keyword">while</span> first&lt;=last:</span><br><span class="line">          midpoint = (first + last)/<span class="number">2</span></span><br><span class="line">          <span class="keyword">if</span> alist[midpoint] == item:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">          <span class="keyword">elif</span> item &lt; alist[midpoint]:</span><br><span class="line">              last = midpoint<span class="number">-1</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              first = midpoint+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(alist, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(alist) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpoint = len(alist)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[midpoint]==item:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">if</span> item&lt;alist[midpoint]:</span><br><span class="line">            <span class="keyword">return</span> binary_search(alist[:midpoint],item)</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(alist[midpoint+<span class="number">1</span>:],item)</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(1)</li><li>最坏时间复杂度：O(logn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;冒泡排序&lt;/strong&gt;（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="基本算法，编程语言" scheme="http://www.cygao.xyz/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【python】 多种链表的实现及python中“=”的解读</title>
    <link href="http://www.cygao.xyz/2019/08/12/linked%20list/"/>
    <id>http://www.cygao.xyz/2019/08/12/linked list/</id>
    <published>2019-08-12T08:54:16.000Z</published>
    <updated>2019-08-13T02:06:51.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python中“-”的理解"><a href="#python中“-”的理解" class="headerlink" title="python中“=”的理解"></a>python中“=”的理解</h1><a id="more"></a><p>python并不像是c/c++，c++中新建一个变量，比如<code>int a = 3</code>，此时必须申明变量的类型，找一块内存空间存储3，这个内存空间的别名是a，占4个字节且a只能存整数。</p><p>python中并不需要申明类型，<code>a  = 10</code>这种隐式申明的的原因是，a是另外一个内存，保存的是一个地址，地址指向什么就代表a是什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def C():</span><br><span class="line">    pass</span><br><span class="line">a = C</span><br></pre></td></tr></table></figure></p><p>a可以重新指向一个方法，类或是对象中的元素都行。所以 <strong>=</strong> 只能代表把指向更改，指向了什么。</p><h1 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表的结点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="comment"># _item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># _next是下一个节点的标识</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="单链表的实现及部分操作"><a href="#单链表的实现及部分操作" class="headerlink" title="单链表的实现及部分操作"></a>单链表的实现及部分操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__head = <span class="literal">None</span> </span><br><span class="line">        <span class="comment">#__双下划线代表私有变量/方法</span></span><br><span class="line">        <span class="comment">#_但下划线代表保护变量/方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表长度"""</span></span><br><span class="line">        <span class="comment"># cur初始时指向头节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 尾节点指向None，当未到达尾部时</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将cur后移一个节点</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.item,end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line"> ```       </span><br><span class="line"><span class="comment">## 头部添加元素 </span></span><br><span class="line">```python</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""头部添加元素"""</span></span><br><span class="line">        <span class="comment"># 先创建一个保存item值的节点</span></span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        <span class="comment"># 将新节点的链接域next指向头节点，即_head指向的位置</span></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        <span class="comment"># 将链表的头_head指向新节点</span></span><br><span class="line">        self.__head = node</span><br></pre></td></tr></table></figure><h2 id="尾部添加元素"><a href="#尾部添加元素" class="headerlink" title="尾部添加元素"></a>尾部添加元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="string">"""尾部添加元素"""</span></span><br><span class="line">    node = SingleNode(item)</span><br><span class="line">    <span class="comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="comment"># 若不为空，则找到尾部，将尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br></pre></td></tr></table></figure><h2 id="指定位置添加元素"><a href="#指定位置添加元素" class="headerlink" title="指定位置添加元素"></a>指定位置添加元素</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/link1.png" alt></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">    <span class="string">"""指定位置添加元素"""</span></span><br><span class="line">    <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">    <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">        self.add(item)</span><br><span class="line">    <span class="comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">    <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">        self.append(item)</span><br><span class="line">    <span class="comment"># 找到指定位置</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">        node.next = pre.next</span><br><span class="line">        <span class="comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">        pre.next = node</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/link2.png" alt></div> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">    <span class="string">"""删除节点"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 找到了指定元素</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="comment"># 如果第一个就是删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                self.__head = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 继续按链表后移节点</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br></pre></td></tr></table></figure><h2 id="查找节点是否存在"><a href="#查找节点是否存在" class="headerlink" title="查找节点是否存在"></a>查找节点是否存在</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></span><br><span class="line">    <span class="string">"""链表查找节点是否存在，并返回True或者False"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h1><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。<br>链表与顺序表的各种操作复杂度如下所示：</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/link3.png" alt></div> <p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p><h1 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h1><p>单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/link4.png" alt></div> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""节点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinCycLinkedlist</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单向循环链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回链表的长度"""</span></span><br><span class="line">        <span class="comment"># 如果链表为空，返回长度0</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">print</span> cur.item,</span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">print</span> cur.item,</span><br><span class="line">        <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""头部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#添加的节点指向_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="comment"># 移到链表尾部，将尾部节点的next指向node</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment">#_head指向添加node的</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""尾部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 移到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将尾节点指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment"># 将node指向头节点_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除一个节点"""</span></span><br><span class="line">        <span class="comment"># 若链表为空，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将cur指向头节点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 若头节点的元素就是要查找的元素item</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="comment"># 如果链表不止一个节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.next != self._head:</span><br><span class="line">                <span class="comment"># 先找到尾节点，将尾节点的next指向第二个节点</span></span><br><span class="line">                <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="comment"># cur指向了尾节点</span></span><br><span class="line">                cur.next = self._head.next</span><br><span class="line">                self._head = self._head.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 链表只有一个节点</span></span><br><span class="line">                self._head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="comment"># 第一个节点不是要删除的</span></span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                <span class="comment"># 找到了要删除的元素</span></span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="comment"># 删除</span></span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.next</span><br><span class="line">            <span class="comment"># cur 指向尾节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 尾部删除</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""查找节点是否存在"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ll = SinCycLinkedlist()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">7</span>)</span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。  </p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/link5.png" alt></div> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双向链表节点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双向链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回链表的长度"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">print</span> cur.item,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""头部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head.prev = node</span><br><span class="line">            <span class="comment"># 将_head 指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""尾部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 移动到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""查找元素是否存在"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line">            <span class="comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            node.next = cur.next</span><br><span class="line">            <span class="comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            <span class="comment"># 将cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                <span class="keyword">if</span> cur.next == <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># 如果链表只有这一个节点</span></span><br><span class="line">                    self._head = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    cur.next.prev = <span class="literal">None</span></span><br><span class="line">                    <span class="comment"># 将_head指向第二个节点</span></span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur.next</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">4</span>)</span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python中“-”的理解&quot;&gt;&lt;a href=&quot;#python中“-”的理解&quot; class=&quot;headerlink&quot; title=&quot;python中“=”的理解&quot;&gt;&lt;/a&gt;python中“=”的理解&lt;/h1&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 list的基本实现</title>
    <link href="http://www.cygao.xyz/2019/08/12/list/"/>
    <id>http://www.cygao.xyz/2019/08/12/list/</id>
    <published>2019-08-12T08:26:12.000Z</published>
    <updated>2019-08-12T08:39:25.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python中list的基本实现技术"><a href="#python中list的基本实现技术" class="headerlink" title="python中list的基本实现技术"></a>python中list的基本实现技术</h1><h2 id="元素外置的顺序表"><a href="#元素外置的顺序表" class="headerlink" title="元素外置的顺序表"></a>元素外置的顺序表</h2><p>python中的list可以存放不同类型的数据，比如int，char，float等等，这些数据元素大小不同，所以得用到外置顺序表。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="string">"abc"</span>,<span class="number">2.2</span>]</span><br></pre></td></tr></table></figure></p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/list1.png" alt></div>  <blockquote><p>Loc(li) = Loc(l0) + c*i </p></blockquote><p>元素的大小不统一，则须采用如图的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。<br>如图这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h2><p>一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/list2.png" alt></div><br>python中的list主要采用分离式结构，如图<br><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/list3.png" alt></div>  <p>表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。这样在进行扩充的时候，数据的迁移，不用迁徙表头，指针指向的地址改变就行。</p><h2 id="list的数据扩充"><a href="#list的数据扩充" class="headerlink" title="list的数据扩充"></a>list的数据扩充</h2><p>在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python中list的基本实现技术&quot;&gt;&lt;a href=&quot;#python中list的基本实现技术&quot; class=&quot;headerlink&quot; title=&quot;python中list的基本实现技术&quot;&gt;&lt;/a&gt;python中list的基本实现技术&lt;/h1&gt;&lt;h2 id=&quot;元素外置的顺序表&quot;&gt;&lt;a href=&quot;#元素外置的顺序表&quot; class=&quot;headerlink&quot; title=&quot;元素外置的顺序表&quot;&gt;&lt;/a&gt;元素外置的顺序表&lt;/h2&gt;&lt;p&gt;python中的list可以存放不同类型的数据，比如int，char，float等等，这些数据元素大小不同，所以得用到外置顺序表。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈的应用，括号匹配问题，中缀、后缀表达式</title>
    <link href="http://www.cygao.xyz/2019/08/12/stack/"/>
    <id>http://www.cygao.xyz/2019/08/12/stack/</id>
    <published>2019-08-12T04:54:16.000Z</published>
    <updated>2019-08-13T02:55:57.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.符号匹配<br>2.计算机表达式的转换<br>3.CPU内部栈主要是用来进行子程序调用和返回<br>4.进制转换<br><a id="more"></a></p><h3 id="1-括号匹配问题"><a href="#1-括号匹配问题" class="headerlink" title="1.括号匹配问题"></a>1.括号匹配问题</h3><p>大多数计算机语言中都需要检测括号是否匹配，那么如何实现符号成对检测？  </p><p><strong>算法思路</strong>：</p><ul><li>从第一个字符开始扫描</li><li>当遇见普通字符时忽略，</li><li>当遇见左符号时压入栈中</li><li>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</li><li>匹配成功：继续读入下一个字符</li><li>匹配失败：立即停止，并报错</li><li>结束：<br>成功: 所有字符扫描完毕，且栈为空<br>失败：匹配失败或所有字符扫描完毕但栈非空</li></ul><h3 id="2-计算机表达式转换"><a href="#2-计算机表达式转换" class="headerlink" title="2.计算机表达式转换"></a>2.计算机表达式转换</h3><p>计算机的本质工作就是做数学运算，那计算机可以读入字符串<br>“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？</p><p><strong>中缀表达式和后缀表达式</strong><br>后缀表达式（由波兰科学家在20世纪50年代提出）<br>将运算符放在数字后面 ===》 符合计算机运算<br>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 =&gt; 5 4 +    </span><br><span class="line">1 + 2 * 3 =&gt; 1 2 3 * +    </span><br><span class="line">8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * +</span><br></pre></td></tr></table></figure></p><p><strong>算法思路</strong><br>中缀转后缀：<br>遍历中缀表达式中的数字和符号</p><ul><li>对于数字：直接输出</li><li>对于符号：  </li></ul><p>（1）左括号：进栈<br>（2）运算符号：与栈顶符号进行优先级比较<br>若栈顶符号优先级低：此符号进栈<br>（默认栈顶若是左括号，左括号优先级最低）<br>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈<br>（3）右括号：将栈顶符号弹出并输出，直到匹配左括号   </p><ul><li>遍历结束：将栈中的所有符号弹出并输出</li></ul><blockquote><p><strong>计算机如何基于后缀表达式结算结果</strong><br>例如：8 3 1 – 5 * +</p></blockquote><ul><li>计算规则：  </li><li>遍历后缀表达式中的数字和符号  </li><li>对于数字：进栈  </li><li>对于符号：<br>（1）从栈中弹出右操作数<br>（2）从栈中弹出左操作数<br>根据符号进行运算<br>将运算结果压入栈中<br>遍历结束：栈中的唯一数字为计算结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈的应用&quot;&gt;&lt;a href=&quot;#栈的应用&quot; class=&quot;headerlink&quot; title=&quot;栈的应用&quot;&gt;&lt;/a&gt;栈的应用&lt;/h1&gt;&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;1.符号匹配&lt;br&gt;2.计算机表达式的转换&lt;br&gt;3.CPU内部栈主要是用来进行子程序调用和返回&lt;br&gt;4.进制转换&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 timeit模块,list及dict操作复杂度</title>
    <link href="http://www.cygao.xyz/2019/08/12/python%20timeit/"/>
    <id>http://www.cygao.xyz/2019/08/12/python timeit/</id>
    <published>2019-08-12T01:01:55.000Z</published>
    <updated>2019-08-12T07:58:34.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内置类型性能分析"><a href="#Python内置类型性能分析" class="headerlink" title="Python内置类型性能分析"></a>Python内置类型性能分析</h1><h2 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h2><p>timeit模块可以用来测试一小段Python代码的执行速度。<br><a id="more"></a></p><h3 id="class-timeit-Timer-stmt-’pass’-setup-’pass’-timer"><a href="#class-timeit-Timer-stmt-’pass’-setup-’pass’-timer" class="headerlink" title="class timeit.Timer(stmt=’pass’, setup=’pass’ timer=)"></a>class timeit.Timer(stmt=’pass’, setup=’pass’ timer=<timer function>)</timer></h3><p>Timer是测量小段代码执行速度的类。</p><p>stmt参数是要测试的代码语句（statment）；</p><p>setup参数是运行代码时需要的设置；</p><p>timer参数是一个定时器函数，与平台有关。</p><h3 id="timeit-Timer-timeit-number-1000000"><a href="#timeit-Timer-timeit-number-1000000" class="headerlink" title="timeit.Timer.timeit(number=1000000)"></a>timeit.Timer.timeit(number=1000000)</h3><p>Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p><h2 id="比较list的操作复杂度"><a href="#比较list的操作复杂度" class="headerlink" title="比较list的操作复杂度"></a>比较list的操作复杂度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">      l = l + [i] <span class="comment">#会先创建一个新的列表l + [i]再赋值到新的l上，效率很差。尽量使用l+=[i]，已在python内部优化了。 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">      l.append(i)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">   l = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span><span class="params">()</span>:</span></span><br><span class="line">   l = list(range(<span class="number">1000</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test5</span><span class="params">()</span>:</span></span><br><span class="line">   l =[]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">      l.extend([i]) <span class="comment"># 类似于 l+=[i]，是直接在列表l上操作</span></span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line">t1 = Timer(<span class="string">"test1()"</span>, <span class="string">"from __main__ import test1"</span>)</span><br><span class="line">print(<span class="string">"concat "</span>,t1.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t2 = Timer(<span class="string">"test2()"</span>, <span class="string">"from __main__ import test2"</span>)</span><br><span class="line">print(<span class="string">"append "</span>,t2.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t3 = Timer(<span class="string">"test3()"</span>, <span class="string">"from __main__ import test3"</span>)</span><br><span class="line">print(<span class="string">"comprehension "</span>,t3.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="string">"test4()"</span>, <span class="string">"from __main__ import test4"</span>)</span><br><span class="line">print(<span class="string">"list range "</span>,t4.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="string">"test5()"</span>, <span class="string">"from __main__ import test5"</span>)</span><br><span class="line">print(<span class="string">"extend "</span>,t5.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line"><span class="comment"># ('concat ', 1.7890608310699463, 'seconds')</span></span><br><span class="line"><span class="comment"># ('append ', 0.13796091079711914, 'seconds')</span></span><br><span class="line"><span class="comment"># ('comprehension ', 0.05671119689941406, 'seconds')</span></span><br><span class="line"><span class="comment"># ('list range ', 0.014147043228149414, 'seconds')</span></span><br><span class="line"><span class="comment"># ('extend ', 0.12147043228149414, 'seconds')</span></span><br></pre></td></tr></table></figure><blockquote><p>list range(迭代转化) &lt; comprehension(包含) &lt; extend &lt; append &lt; concat </p></blockquote><h3 id="pop操作比较"><a href="#pop操作比较" class="headerlink" title="pop操作比较"></a>pop操作比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="number">2000000</span>)</span><br><span class="line">pop_zero = Timer(<span class="string">"x.pop(0)"</span>,<span class="string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="string">"pop_zero "</span>,pop_zero.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">x = range(<span class="number">2000000</span>)</span><br><span class="line">pop_end = Timer(<span class="string">"x.pop()"</span>,<span class="string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="string">"pop_end "</span>,pop_end.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('pop_zero ', 1.9101738929748535, 'seconds')</span></span><br><span class="line"><span class="comment"># ('pop_end ', 0.00023603439331054688, 'seconds')</span></span><br></pre></td></tr></table></figure><blockquote><p>测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素</p></blockquote><h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">l1[<span class="number">0</span>:<span class="number">2</span>] = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>] <span class="comment">#可以是任意长度</span></span><br><span class="line">&gt;&gt; l1 = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/python1.png" alt></div>  <div align="center">!<img src="http://pw0x0t99o.bkt.clouddn.com/python2.png" alt></div>  ]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python内置类型性能分析&quot;&gt;&lt;a href=&quot;#Python内置类型性能分析&quot; class=&quot;headerlink&quot; title=&quot;Python内置类型性能分析&quot;&gt;&lt;/a&gt;Python内置类型性能分析&lt;/h1&gt;&lt;h2 id=&quot;timeit模块&quot;&gt;&lt;a href=&quot;#timeit模块&quot; class=&quot;headerlink&quot; title=&quot;timeit模块&quot;&gt;&lt;/a&gt;timeit模块&lt;/h2&gt;&lt;p&gt;timeit模块可以用来测试一小段Python代码的执行速度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>markdown格式编写</title>
    <link href="http://www.cygao.xyz/2019/06/08/Joint/"/>
    <id>http://www.cygao.xyz/2019/06/08/Joint/</id>
    <published>2019-06-08T07:30:28.000Z</published>
    <updated>2019-08-08T08:49:19.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown格式编写"><a href="#markdown格式编写" class="headerlink" title="markdown格式编写"></a>markdown格式编写</h1><a id="more"></a><h2 id="第一个标题"><a href="#第一个标题" class="headerlink" title="第一个标题"></a>第一个标题</h2><p>段落1 中间空一行</p><p>段落2</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote><p>使用“&gt;”和空格高亮</p><p>这是一段段落高亮</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="www.baidu.com">百度</a>  利用中括号小括号的格式</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="http://image.baidu.com/search/detail?ct=503316480&amp;z=undefined&amp;tn=baiduimagedetail&amp;ipn=d&amp;word=robomaster%E7%9B%B4%E6%92%AD&amp;step_word=&amp;ie=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;cs=3125832727,3597497147&amp;os=1898171743,3878211660&amp;simid=3369673952,459146154&amp;pn=1&amp;rn=1&amp;di=20790&amp;ln=361&amp;fr=&amp;fmq=1565251372619_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;is=0,0&amp;istype=0&amp;ist=&amp;jit=&amp;bdtype=0&amp;spn=0&amp;pi=0&amp;gsm=0&amp;objurl=http%3A%2F%2Fi.dyt8.cc%2F66%2Fab%2F0a%2Ff1%2F38%2F38%2F4d%2Fe5%2Fa2%2Fd2%2F4d%2F0d%2Fb8%2Fc7%2F62%2Ffb.jpg&amp;rpstart=0&amp;rpnum=0&amp;adpicid=0&amp;force=undefined" alt="风景"> 超链接前面+!</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>1</li><li>1</li><li>1 “*”</li></ul><ul><li>2</li><li>2</li><li>2 “-“</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>“1.”<br>2.<br>3.</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><hr><p>“ *或是-” 大于3个</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown格式编写&quot;&gt;&lt;a href=&quot;#markdown格式编写&quot; class=&quot;headerlink&quot; title=&quot;markdown格式编写&quot;&gt;&lt;/a&gt;markdown格式编写&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【Person Search】 RCAA Relational Context-Aware Agents for Person Search</title>
    <link href="http://www.cygao.xyz/2018/12/09/RCAA%20Relational%20Context%20Aware%20Agents%20for%20Person%20Search/"/>
    <id>http://www.cygao.xyz/2018/12/09/RCAA Relational Context Aware Agents for Person Search/</id>
    <published>2018-12-09T10:27:11.000Z</published>
    <updated>2019-08-11T06:05:42.353Z</updated>
    
    <content type="html"><![CDATA[<p>论文：RCAA Relational Context-Aware Agents for Person Search<br>链接：<a href="http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html</a><br>代码地址：没有公开<br><a id="more"></a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在本文中，我们通过训练relational context-aware agents来解决这个问题，这些agens从整个场景图像库中学习定位目标人物的操作。我们将相关的空间和时间上下文合并到框架中。具体地说，我们建议在依赖查询的关系网络中使用目标人员作为查询。agent通过同时考虑局部的视觉信息、关系上下文和时间上下文，以及目标人员，确定在每个时间步上要采取的最佳操作。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>时空背景可能会提供额外的重要信息，但对人的搜索仍然不够深入。空间语境已被证明在回答视觉问题等任务中是有用的。在整个场景图像中，目标人物依赖的物体之间的空间关系可能有助于更有辨别力的表示。此外，序列决策在目标检测中的成功应用也为人的识别提供了借鉴。多步推理的agent可以更好地定位目标人，同时考虑到目标人的时间行为和状态记忆。在这项工作中，我们提出了一个自顶向下的搜索策略，由一个时空上下文感知的代理提供支持，以解决上面讨论的限制和机会。具体地说，考虑到整个场景、它的本地图像特性和查询图像，我们利用一个依赖于目标-人的关系网络来提取对象之间的空间上下文。然后，我们的深度强化学习代理根据空间上下文及其时间动作和状态记忆，在每一个时间步选择最佳动作，以缩小目标人物的精确位置。整个框架不包含人员建议计算，并且是端到端可培训的。</p><p>贡献：    </p><ol><li>我们最早尝试将人的搜索问题作为一个决策过程来解决，并构建了第一个基于深度强化学习的人的搜索框架。</li><li>该模型采用端到端方式进行训练，不需要进行冗余和噪声的proposal Scomputing。有趣的是，我们的模型甚至比负载完美的proposal detector方法性能更好。</li><li>我们在训练过程中加入了相关的时空背景，从而引导模型产生更多的信息“经验”。 </li></ol><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><ul><li>Person re-id<br>pass  </li><li>pedestrian detection<br>pass    </li><li>Deep Reinforcement Learning<br>文献中讨论了两种广泛使用的DRL方法——Deep QNetworks(DQN)和策略policy gradient，具体的看论文吧。</li></ul><h1 id="3-Relational-Context-Aware-Agents"><a href="#3-Relational-Context-Aware-Agents" class="headerlink" title="3. Relational Context-Aware Agents"></a>3. Relational Context-Aware Agents</h1><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h2><p>行人搜索解决了从整个场景图像库中寻找目标人物的精确位置的问题。系统通过时空上下文感知agent确定的顺序操作动态定位目标行人。我们的代理接受空间和时间上下文、本地图像特征和查询图像作为输入，并预测要采取的最佳操作。通过预测动作将包围框从当前状态转换为下一个状态，并从下一个状态预测下一个动作。这个过程不断重复，直到达到最优结果。<div align="center"><br><img src="http://pw0x0t99o.bkt.clouddn.com/RCAA1.png" alt></div></p><h2 id="3-2-Relational-Decision-Making"><a href="#3-2-Relational-Decision-Making" class="headerlink" title="3.2 Relational Decision Making"></a>3.2 Relational Decision Making</h2><p>该模型遵循马尔可夫决策过程(MDP)，适用于序列决策过程的建模。</p><ul><li>Action 存在移动，扩张和裁剪共14个操作。<div align="center"><br><img src="http://pw0x0t99o.bkt.clouddn.com/RCAA2.png" alt></div></li><li>State</li><li>Reward<br>这个具体看懂得有一些强化学习得知识和MDP的相关知识。 <h2 id="3-3-Network-Structure"><a href="#3-3-Network-Structure" class="headerlink" title="3.3 Network Structure"></a>3.3 Network Structure</h2>我们使用ResNet-50进行特征提取，因为它在人的识别方面显示了极大的优越性。为了编码关系上下文信息，我们结合了一个关系网络(RN)，上文所述，来考虑图像中所有对对象之间的所有关系。  <h2 id="3-4-Training"><a href="#3-4-Training" class="headerlink" title="3.4 Training"></a>3.4 Training</h2>为了避免次优解决方案，我们使用了actor-critic (A3C) method，它在环境的多个实例上异步并行地执行多个agents。我们使用ADAM optimizer训练模型，中间还介绍了强化学习的损失函数和训练策略，不太懂不展开了。<h1 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h1></li></ul><p>相当高的表现，在两个数据集上，表现见下图，即使放在19年也是很有竞争力的表现了。</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/RCAA3.png" alt></div><br><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/RCAA4.png" alt></div><br><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/RCAA5.png" alt></div>   <h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文首先尝试解决人的搜索问题，建立了第一个基于深度强化学习的人的搜索框架。与以往依赖proposal learning的工作不同，我们的方法利用了关系上下文信息，并在联合框架中预先利用视觉信息和query。<br>在未来，我们计划在我们的框架中使用宽松的学习lenient learning，因为存储的转换可能会因为agents并行更新它们各自的策略而过时。</p><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>有点复杂的论文，需要有强化学习和一些机器学习的基础，与众多的利用以Faster R-CNN为行人检测器的论文不同，还有以前用proposal learning的传统检测器。总感觉和我之前认知的Person Search有些不同。</p><ul><li><p>我的理解包括跑的一些Person Search的代码：Testing的时候，query和gallery的图像是分批次进入的，query的特征和再和所有gallery检测出的行人特征（也是通过检测后的行人包围框的特征），进行特征对比（比如用余弦相似度或是欧式距离等等），如果detction时候没有检测出iou&gt;0.5的包围框，再怎么query对比都没意义。</p></li><li><p>这篇RCAA，看文章模型的structure，<strong>Our agent accepts the spatial and temporal context, the local image feature and the query image as input</strong>,<strong>When the training is finished, we fix the policy and value network for testing. A single agent is used to process each query for testing. For each query, we rank all the value V and retrieve the top ranked results.</strong> 看的像是test的时候同时可以输入query引导detectoring的过程，和之前的方法推理过程有点不太一样。如果有研究person search的同学可以评论一下，和我交流。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：RCAA Relational Context-Aware Agents for Person Search&lt;br&gt;链接：&lt;a href=&quot;http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html&lt;/a&gt;&lt;br&gt;代码地址：没有公开&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Person Search】 Person Search by Multi-Scale Matching</title>
    <link href="http://www.cygao.xyz/2018/11/28/Person%20Search%20by%20Multi-Scale%20Matching/"/>
    <id>http://www.cygao.xyz/2018/11/28/Person Search by Multi-Scale Matching/</id>
    <published>2018-11-28T03:23:45.000Z</published>
    <updated>2019-08-11T07:08:30.474Z</updated>
    
    <content type="html"><![CDATA[<p>论文：Person Search by Multi-Scale Matching<br>链接：<a href="http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html</a><br>代码地址：没有公开<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=863970833&auto=0&height=66"></iframe><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>研究了无约束场景图像中的人搜索问题。现有的检测方法多侧重于提高人的检测精度，以减轻自动检测噪声引起的配准误差、误检等带来的负面影响。与以往的研究相比，我们发现，通过改进现有的深度学习对象检测器(如Fast R-CNN)，可以实现足够的可重复责任人实例裁剪，而在人员搜索中尚未得到充分研究的多尺度匹配问题是一个更为严重的障碍。在这项工作中，我们提出了一种跨层次语义对齐(CLSA)的深度学习方法，能够在统一的端到端模型中学习更具鉴别性的身份特征表示，从而解决了这个多尺度的人搜索挑战。这是通过利用深度神经网络的网络内特征金字塔结构来实现的。这很好地消除了构建计算开销昂贵的图像金字塔和复杂的多分支网络体系结构的需要。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>行人搜索处理原始的未细化的检测与许多错误裁剪和未知程度的错位。这就产生了一个更具挑战性的匹配问题，尤其是在人的重新识别过程中。此外，自动检测的人员框通常在规模(分辨率)上比常规的差异更大。由于人与摄像机之间固有的无法控制的距离(图1(a))。因此，它本质上是一个多尺度匹配问题。然而，这一问题目前在人员搜索中研究不足。</p><p>贡献：    </p><ol><li>我们确定了人搜索中的多尺度匹配问题，这是文献中缺少的一个元素，但发现它对提高模型性能具有重要意义。</li><li>我们提出了一个跨层次语义对齐(CLSA)的深度学习方法来解决多尺度匹配的挑战。这是基于学习一个端到端的网络内特征金字塔表示，具有较强的鲁棒性，以应对可变尺度的自动检测人的边界框。</li><li>我们改进了Faster R-CNN模型，在不受控制的场景中实现更可靠的行人定位，从而提高了整体搜索性能。以及用实验证明了<div align="center"><br><img src="http://pw0x0t99o.bkt.clouddn.com/CLSA1.png" alt></div>  </li></ol><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><ul><li>Person search<br>pass  </li><li>pedestrian detection<br>pass    </li></ul><h1 id="3-Cross-Level-Semantic-Alignment-for-Person-Search"><a href="#3-Cross-Level-Semantic-Alignment-for-Person-Search" class="headerlink" title="3. Cross-Level Semantic Alignment for Person Search"></a>3. Cross-Level Semantic Alignment for Person Search</h1><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/CLSA2.png" alt><br></div>  <h2 id="3-1-Person-Detection"><a href="#3-1-Person-Detection" class="headerlink" title="3.1 Person Detection"></a>3.1 Person Detection</h2><p>进一步提高检测性能和效率,我们介绍一些设计改进原模型。</p><ol><li>不是使用传统的RoI的利益(地区)池层,我们该地区农作物和调整功能映射到14×14像素,并进一步最大池他们7×7获得更好的效率</li><li>在ImageNet-1K上对backbone ResNet-50网络进行预训练后，我们将第一个构建块(前4层)固定在目标人物搜索数据的微调中。这允许保留从较大的源数据中学到的共享底层特性，同时使模型适应目标数据。</li><li>在非最大抑制(NMS)操作之前，我们保留并利用所有大小的proposals来降低在不受控制的场景中极端尺度下的误检率。在部署中，我们考虑所有的检测框得分都在0.5以上，而不是从每个场景图像中提取固定数量的框。这个很好理解。<h2 id="3-2-Multi-Scale-Matching-by-Cross-Level-Semantic-Alignment"><a href="#3-2-Multi-Scale-Matching-by-Cross-Level-Semantic-Alignment" class="headerlink" title="3.2 Multi-Scale Matching by Cross-Level Semantic Alignment"></a>3.2 Multi-Scale Matching by Cross-Level Semantic Alignment</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/CLSA3.png" alt></div></li></ol><p>有点复杂，具体可以见论文。</p><h1 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h1><h2 id="On-CUHK-SYSU"><a href="#On-CUHK-SYSU" class="headerlink" title="On CUHK-SYSU"></a>On CUHK-SYSU</h2><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/CLSA4.png" alt></div><h2 id="On-PRW"><a href="#On-PRW" class="headerlink" title="On PRW"></a>On PRW</h2><p>pass</p><h2 id="Further-Analysis-and-Discussions"><a href="#Further-Analysis-and-Discussions" class="headerlink" title="Further Analysis and Discussions"></a>Further Analysis and Discussions</h2><p>在re-id和detection的数据集上也做了一些实验。</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/CLSA5.png" alt></div>   <h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在本文中，我们提出了一种新的跨层次语义对齐(CLSA)深度学习框架，用于无约束场景图像中的人物搜索。与现有的以提高人的检测性能为核心的人的搜索方法相比，我们的实验表明，解决多尺度匹配问题对提高人的搜索结果更为重要。<br>为了解决这一研究不足的跨尺度人员搜索问题，我们提出了一种端到端的CLSA深度学习方法，通过构造网络内特征金字塔结构表示，利用语义对齐学习损失函数增强其表示能力。以使所有特征金字塔等级识别具有辨别力，从而导致更有效的分层表示，用于匹配具有大且无约束的尺度变化的人物图像。</p><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>主要通过提升检测时候增加了多尺度匹配，通过特征金字塔，在re-id部分增加语义对齐，这个在re-id里也是常用手段，但是是跨层次的，相当于multi-scale的。最后结尾在一些image-based re-id数据集上也做了实验，比如market1501和cuhk03上，但是提升效果寥寥，88.9的top1在market1501上真的很一般。为啥能在person search上表现这么好，总之person search的坑很多，一些在detection上和re-id上能提升的，改进一些都可以在person search上有提高。但是这也提高了太多了把~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：Person Search by Multi-Scale Matching&lt;br&gt;链接：&lt;a href=&quot;http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html&lt;/a&gt;&lt;br&gt;代码地址：没有公开&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Person Search】 Joint Detection and Identification Feature Learning for Person Search</title>
    <link href="http://www.cygao.xyz/2018/10/21/Neural%20Person%20Search%20Machines/"/>
    <id>http://www.cygao.xyz/2018/10/21/Neural Person Search Machines/</id>
    <published>2018-10-21T02:27:11.000Z</published>
    <updated>2019-08-11T01:50:05.037Z</updated>
    
    <content type="html"><![CDATA[<p>论文：Joint Detection and Identification Feature Learning for Person Search<br>链接：<a href="https://arxiv.org/abs/1604.01850" target="_blank" rel="noopener">https://arxiv.org/abs/1604.01850</a><br>代码地址： <a href="https://github.com/ShuangLI59/person_search" target="_blank" rel="noopener">https://github.com/ShuangLI59/person_search</a> caffe版本<br>疑似复现地址：<a href="https://github.com/liliangqi/person_search" target="_blank" rel="noopener">https://github.com/liliangqi/person_search</a> pytorch版本<br><a id="more"></a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p> 现有的行人再识别方法中所使用的标准和方法主要关注的是经过裁剪的行人照片，这与现实生活场景中的图片有所不同。本文为了缩小两者的差距，提出了一种行人搜索的新框架，将行人检测和行人再识别结合起来，利用单个CNN来进行训练。文中使用了OIM损失（Online Instance Matching）来训练网络，它比一般的Softmax损失函数的效果更快更好。</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM1.jpg" alt></div>    <p> 同时提出了一个大型的数据集，总共18184 images，所有图像中总共有8432 persons，99809个标注的bounding boxes。  </p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p> 行人重识别和行人搜索的不同点在于，行人重识别，是在已经假设行人检测已经做的完美的基础上做的再识别研究。而行人搜索更贴近于现实世界的应用，更具有挑战性，正如检测行人时可能不可避免的出现false alarms，漏检，misalignments，这些都会对行人搜索的效果产生影响。<br> 与传统方法中将行人检测和再识别分成两个问题不同，本文利用单个CNN将两者结合来解决上述问题，该CNN分为两个部分，一个是pedestrian proposal net，来产生候选行人的 bounding boxes，另一个是identification net，来提取特征来进行与检索目标的比较。两者在 joint optimization过程中具有相互适应的特点，从而消除自身外另一网络带来的问题。<br> 传统的re-id特征学习主要依赖于pair-wise或triplet distance loss functions,它们一次都只能用少量的数据做比较;以及Softmax loss function,虽然把行人重识别问题当成是多分类问题去做，解决了之前两个loss function的问题，但是随着行人类型（不同身份的人）数量的增多，训练一个如此庞大的Softmax 分类器会变得及其的慢，甚至更糟糕的时候网络会无法收敛。</p><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><h2 id="2-1-Person-re-id"><a href="#2-1-Person-re-id" class="headerlink" title="2.1 Person re-id"></a>2.1 Person re-id</h2><p>pass</p><h2 id="2-2-pedestrian-detection"><a href="#2-2-pedestrian-detection" class="headerlink" title="2.2 pedestrian detection"></a>2.2 pedestrian detection</h2><p>pass</p><h1 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h1><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM2.jpg" alt></div>   <h2 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h2><ol><li>首先，经过Stem CNN将raw pixel转换成Convolutional Feature Maps。然后，放到Pedestrain Proposal net生成候选行人的bounding boxes。</li><li>然后放到一个带有Rol(regionof interest) Pooling的识别网络，提取出每个候选区（boundingbox）对应的L2正则化256维特征向量。</li><li>在推测阶段，利用gallery person和目标行人之间的features distances来进行排序。  </li><li>在训练阶段，根据feature vectors，使用OIM loss function以及其他的loss functions来监控identification net，以多任务方式来训练网络。<h2 id="Model-Structure"><a href="#Model-Structure" class="headerlink" title="Model Structure"></a>Model Structure</h2></li><li>文中选用的是ResNet-50作为CNN模型的网络结构，利用其中的conv1和 conv4_3作为stem CNN部分。给定一张输入图片，stem会产生1024个通道的 features maps，它们的分辨率只有原图像的<strong>十六分之一</strong>。  </li><li>根据生成的这些features maps，利用512 × 3 × 3的卷积层来对行人特征进行转换，接着在feature map的每个位置利用<strong>9个anchors</strong>（源于Faster RCNN）和<strong>1个Softmax分类器</strong>来<strong>预测每个anchor是否包含行人在内</strong>，同时还包括了<strong>1个线性回归器</strong>来<strong>调整anchors的位置</strong>。在<strong>NMS</strong>过后仅保留<strong>128个调整后的bounding boxes作为最终的proposals</strong>； </li><li>建立IdentificationNet，用于提取每个候选区的特征，并和目标特征做对比。首先用ROI-Pooling从每个候选区的特征图中池化出一个<strong>1024<em>14</em>14</strong>的区域。然后，他们通过ResNet-50的con4_4到conv5_3，最后通过全局的平均池化层汇总成2048维特征向量。</li><li>另一方面，pedestrian proposal net 生成的 pedestrian proposals 中会不可避免地会包含一些 <strong>false alarms</strong>（也就是proposal里包含的不是行人）和 <strong>misalignments（</strong>也就是框没有对齐行人<strong>）</strong>，因此再次利用Softmax分类器和线性回归器来<strong>拒绝非行人的区域并精修proposal的位置</strong>。另一方面，我们将特征投影到经过L2正则化后的256维向量子空间中，并在推测阶段计算它们和目标行人的<strong>余弦相似度</strong>。<h2 id="Online-Instance-Matching-Loss"><a href="#Online-Instance-Matching-Loss" class="headerlink" title="Online Instance Matching Loss"></a>Online Instance Matching Loss</h2></li></ol><ul><li>labeled identity：与目标行人相吻合的proposal。  </li><li>unlabeled identities：包含行人但不是目标行人的proposal。  </li><li>background clutter：包含非行人物体或者背景的proposal。<br>在OIM损失函数中只考虑前两者。<br>具体见下图：  <div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM3.jpg" alt></div><br>因为目标是为了区分开不同id的人，一个很自然很常用的方法就是<strong>缩小相同id人的特征距离，同时增大不同id的人的特征距离</strong>，为了实现这个目的，我们需要<strong>存储所有人的特征</strong>。对所有训练集图像同时进行网络的前向传递就可以实现，但这对于SGD优化器来说是不实际的，因为随机梯度下降每次只取一个mini-batch，不可能把所有训练集图像一次包含进去训练，所以本文并未选择SGD进行优化，而是采用了 <strong>online approximation</strong>。<br>mini-batch中<strong>一个labeled identity的特征被记为记为x</strong>（x是D维特征向量），之后生成一个 lookup table V（LUT，查询表，前面有介绍过，Figure 3中右上角的蓝色格子），<strong>V用来记录所有labeled identity的特征</strong>（D×L 维矩阵，D是上面的x的维度，也就是一个labeled identity的特征维度；L是不同id的人，就是L个类；所以D×L 维矩阵就是整个LUT的维度）。<br><strong>前向计算</strong>时，会计算minibatch sample 与所有LUT中labeled identity的实例的cosine 相似度，通过矩阵乘法，<strong>后向传播</strong>时，如果query的ID为t，则更新LUT的第t列与之ID对应的labeled identity实例特征，如下：<br><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM6.jpg" alt></div>  </li></ul><h1 id="4-Dataset"><a href="#4-Dataset" class="headerlink" title="4. Dataset"></a>4. Dataset</h1><h2 id="4-1-CUHK-SYSU"><a href="#4-1-CUHK-SYSU" class="headerlink" title="4.1 CUHK-SYSU"></a>4.1 CUHK-SYSU</h2><p>总共有8432 persons，99809个标注的bounding boxes。<br>For street snaps, 12490 images and 6057 query persons ；<br> For movie/TV，5694 images and 2375 query persons ；<br> training set：11206 images and 5532 query persons ；<br> test set：6978 images and 2900 query persons ；<br> every query至少有与query同一ID的图片，不同的query有不同的gallery set且training and test sets have no overlap on images or query persons，以保证用测试集评价的合理性.  </p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM4.jpg" alt></div>       <h2 id="4-2-Metrics"><a href="#4-2-Metrics" class="headerlink" title="4.2 Metrics"></a>4.2 Metrics</h2><ul><li>mAP</li><li>CMC-K</li></ul><h1 id="5-Experiment-Settings"><a href="#5-Experiment-Settings" class="headerlink" title="5. Experiment Settings"></a>5. Experiment Settings</h1><p>文章是基于caffe框架和faster rcnn算法为基础的，用了基于ImageNet 的ResNet50的预训练模型</p><p> 所有用到的loss都有一样的损失权重，每一个mini-batch有2张全景图，学习率初始化为0.001，在4万次迭代后下降到0.0001，然后保持不变直到模型在大约5万次迭代的时候达到收敛。直接看文章开头的代码上手更快些。    </p><p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM5.jpg" alt></div><br>可以看出不管是CMC或者mAP两项评价指标，<strong>本文提出的方法均遥遥领先于其他方法</strong>。与IDNet方法相同，提升的原因，主要是：检测和重识别两项任务的有效结合，互相提升，以及在OIM loss中有效地使用了unlabeled identity 来监督学习。行人检测中 <strong>detectors 检测器的选择对行人重识别任务的效果提升尤为关键</strong>，我们可以看到CCF、ACF、CNN和GT之间的差别都是巨大的，直接使用现有的 detector 对现实生活中的行人检测任务来说并不是最优的，否则 detector 很可能就会成为限制行人重识别任务效果的一个瓶颈。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>pass </p><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>上手Person Search相关的科研论文，这篇文章是必读的，是第一篇整合两个子任务到同一个框架的工作，源码由于是caffe的，对于新手不太友好，尤其是18年开始入坑CV的小白来说，一些更轻便的框架,把层，代价函数，模块封装好的，如tensorflow或是pytorch则更容易手上，建议可以从那个疑似复现代码的地址上手，可能复现不到这篇论文的结果，相差大约1~2%,但从熟悉整个Person Search的框架再好不过了，主要还是大部分的Person Search论文都没有开源，或者只是提供了test的部分代码和训练好的网络参数和结构，打包成了.pth等让读者在云盘上下载，有点小坑，很难复现到原始论文的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：Joint Detection and Identification Feature Learning for Person Search&lt;br&gt;链接：&lt;a href=&quot;https://arxiv.org/abs/1604.01850&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/1604.01850&lt;/a&gt;&lt;br&gt;代码地址： &lt;a href=&quot;https://github.com/ShuangLI59/person_search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ShuangLI59/person_search&lt;/a&gt; caffe版本&lt;br&gt;疑似复现地址：&lt;a href=&quot;https://github.com/liliangqi/person_search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liliangqi/person_search&lt;/a&gt; pytorch版本&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码踩坑" scheme="http://www.cygao.xyz/tags/%E4%BB%A3%E7%A0%81%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【Person Search】 Joint Detection and Identification Feature Learning for Person Search</title>
    <link href="http://www.cygao.xyz/2018/10/21/Joint%20Detection%20and%20Identification%20Feature%20Learning%20for%20Person%20Search/"/>
    <id>http://www.cygao.xyz/2018/10/21/Joint Detection and Identification Feature Learning for Person Search/</id>
    <published>2018-10-21T02:27:11.000Z</published>
    <updated>2019-08-11T01:50:05.037Z</updated>
    
    <content type="html"><![CDATA[<p>论文：Joint Detection and Identification Feature Learning for Person Search<br>链接：<a href="https://arxiv.org/abs/1604.01850" target="_blank" rel="noopener">https://arxiv.org/abs/1604.01850</a><br>代码地址： <a href="https://github.com/ShuangLI59/person_search" target="_blank" rel="noopener">https://github.com/ShuangLI59/person_search</a> caffe版本<br>疑似复现地址：<a href="https://github.com/liliangqi/person_search" target="_blank" rel="noopener">https://github.com/liliangqi/person_search</a> pytorch版本<br><a id="more"></a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p> 现有的行人再识别方法中所使用的标准和方法主要关注的是经过裁剪的行人照片，这与现实生活场景中的图片有所不同。本文为了缩小两者的差距，提出了一种行人搜索的新框架，将行人检测和行人再识别结合起来，利用单个CNN来进行训练。文中使用了OIM损失（Online Instance Matching）来训练网络，它比一般的Softmax损失函数的效果更快更好。</p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM1.jpg" alt></div>    <p> 同时提出了一个大型的数据集，总共18184 images，所有图像中总共有8432 persons，99809个标注的bounding boxes。  </p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p> 行人重识别和行人搜索的不同点在于，行人重识别，是在已经假设行人检测已经做的完美的基础上做的再识别研究。而行人搜索更贴近于现实世界的应用，更具有挑战性，正如检测行人时可能不可避免的出现false alarms，漏检，misalignments，这些都会对行人搜索的效果产生影响。<br> 与传统方法中将行人检测和再识别分成两个问题不同，本文利用单个CNN将两者结合来解决上述问题，该CNN分为两个部分，一个是pedestrian proposal net，来产生候选行人的 bounding boxes，另一个是identification net，来提取特征来进行与检索目标的比较。两者在 joint optimization过程中具有相互适应的特点，从而消除自身外另一网络带来的问题。<br> 传统的re-id特征学习主要依赖于pair-wise或triplet distance loss functions,它们一次都只能用少量的数据做比较;以及Softmax loss function,虽然把行人重识别问题当成是多分类问题去做，解决了之前两个loss function的问题，但是随着行人类型（不同身份的人）数量的增多，训练一个如此庞大的Softmax 分类器会变得及其的慢，甚至更糟糕的时候网络会无法收敛。</p><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><h2 id="2-1-Person-re-id"><a href="#2-1-Person-re-id" class="headerlink" title="2.1 Person re-id"></a>2.1 Person re-id</h2><p>pass</p><h2 id="2-2-pedestrian-detection"><a href="#2-2-pedestrian-detection" class="headerlink" title="2.2 pedestrian detection"></a>2.2 pedestrian detection</h2><p>pass</p><h1 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h1><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM2.jpg" alt></div>   <h2 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h2><ol><li>首先，经过Stem CNN将raw pixel转换成Convolutional Feature Maps。然后，放到Pedestrain Proposal net生成候选行人的bounding boxes。</li><li>然后放到一个带有Rol(regionof interest) Pooling的识别网络，提取出每个候选区（boundingbox）对应的L2正则化256维特征向量。</li><li>在推测阶段，利用gallery person和目标行人之间的features distances来进行排序。  </li><li>在训练阶段，根据feature vectors，使用OIM loss function以及其他的loss functions来监控identification net，以多任务方式来训练网络。<h2 id="Model-Structure"><a href="#Model-Structure" class="headerlink" title="Model Structure"></a>Model Structure</h2></li><li>文中选用的是ResNet-50作为CNN模型的网络结构，利用其中的conv1和 conv4_3作为stem CNN部分。给定一张输入图片，stem会产生1024个通道的 features maps，它们的分辨率只有原图像的<strong>十六分之一</strong>。  </li><li>根据生成的这些features maps，利用512 × 3 × 3的卷积层来对行人特征进行转换，接着在feature map的每个位置利用<strong>9个anchors</strong>（源于Faster RCNN）和<strong>1个Softmax分类器</strong>来<strong>预测每个anchor是否包含行人在内</strong>，同时还包括了<strong>1个线性回归器</strong>来<strong>调整anchors的位置</strong>。在<strong>NMS</strong>过后仅保留<strong>128个调整后的bounding boxes作为最终的proposals</strong>； </li><li>建立IdentificationNet，用于提取每个候选区的特征，并和目标特征做对比。首先用ROI-Pooling从每个候选区的特征图中池化出一个<strong>1024<em>14</em>14</strong>的区域。然后，他们通过ResNet-50的con4_4到conv5_3，最后通过全局的平均池化层汇总成2048维特征向量。</li><li>另一方面，pedestrian proposal net 生成的 pedestrian proposals 中会不可避免地会包含一些 <strong>false alarms</strong>（也就是proposal里包含的不是行人）和 <strong>misalignments（</strong>也就是框没有对齐行人<strong>）</strong>，因此再次利用Softmax分类器和线性回归器来<strong>拒绝非行人的区域并精修proposal的位置</strong>。另一方面，我们将特征投影到经过L2正则化后的256维向量子空间中，并在推测阶段计算它们和目标行人的<strong>余弦相似度</strong>。<h2 id="Online-Instance-Matching-Loss"><a href="#Online-Instance-Matching-Loss" class="headerlink" title="Online Instance Matching Loss"></a>Online Instance Matching Loss</h2></li></ol><ul><li>labeled identity：与目标行人相吻合的proposal。  </li><li>unlabeled identities：包含行人但不是目标行人的proposal。  </li><li>background clutter：包含非行人物体或者背景的proposal。<br>在OIM损失函数中只考虑前两者。<br>具体见下图：  <div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM3.jpg" alt></div><br>因为目标是为了区分开不同id的人，一个很自然很常用的方法就是<strong>缩小相同id人的特征距离，同时增大不同id的人的特征距离</strong>，为了实现这个目的，我们需要<strong>存储所有人的特征</strong>。对所有训练集图像同时进行网络的前向传递就可以实现，但这对于SGD优化器来说是不实际的，因为随机梯度下降每次只取一个mini-batch，不可能把所有训练集图像一次包含进去训练，所以本文并未选择SGD进行优化，而是采用了 <strong>online approximation</strong>。<br>mini-batch中<strong>一个labeled identity的特征被记为记为x</strong>（x是D维特征向量），之后生成一个 lookup table V（LUT，查询表，前面有介绍过，Figure 3中右上角的蓝色格子），<strong>V用来记录所有labeled identity的特征</strong>（D×L 维矩阵，D是上面的x的维度，也就是一个labeled identity的特征维度；L是不同id的人，就是L个类；所以D×L 维矩阵就是整个LUT的维度）。<br><strong>前向计算</strong>时，会计算minibatch sample 与所有LUT中labeled identity的实例的cosine 相似度，通过矩阵乘法，<strong>后向传播</strong>时，如果query的ID为t，则更新LUT的第t列与之ID对应的labeled identity实例特征，如下：<br><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM6.jpg" alt></div>  </li></ul><h1 id="4-Dataset"><a href="#4-Dataset" class="headerlink" title="4. Dataset"></a>4. Dataset</h1><h2 id="4-1-CUHK-SYSU"><a href="#4-1-CUHK-SYSU" class="headerlink" title="4.1 CUHK-SYSU"></a>4.1 CUHK-SYSU</h2><p>总共有8432 persons，99809个标注的bounding boxes。<br>For street snaps, 12490 images and 6057 query persons ；<br> For movie/TV，5694 images and 2375 query persons ；<br> training set：11206 images and 5532 query persons ；<br> test set：6978 images and 2900 query persons ；<br> every query至少有与query同一ID的图片，不同的query有不同的gallery set且training and test sets have no overlap on images or query persons，以保证用测试集评价的合理性.  </p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM4.jpg" alt></div>       <h2 id="4-2-Metrics"><a href="#4-2-Metrics" class="headerlink" title="4.2 Metrics"></a>4.2 Metrics</h2><ul><li>mAP</li><li>CMC-K</li></ul><h1 id="5-Experiment-Settings"><a href="#5-Experiment-Settings" class="headerlink" title="5. Experiment Settings"></a>5. Experiment Settings</h1><p>文章是基于caffe框架和faster rcnn算法为基础的，用了基于ImageNet 的ResNet50的预训练模型</p><p> 所有用到的loss都有一样的损失权重，每一个mini-batch有2张全景图，学习率初始化为0.001，在4万次迭代后下降到0.0001，然后保持不变直到模型在大约5万次迭代的时候达到收敛。直接看文章开头的代码上手更快些。    </p><p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/OIM5.jpg" alt></div><br>可以看出不管是CMC或者mAP两项评价指标，<strong>本文提出的方法均遥遥领先于其他方法</strong>。与IDNet方法相同，提升的原因，主要是：检测和重识别两项任务的有效结合，互相提升，以及在OIM loss中有效地使用了unlabeled identity 来监督学习。行人检测中 <strong>detectors 检测器的选择对行人重识别任务的效果提升尤为关键</strong>，我们可以看到CCF、ACF、CNN和GT之间的差别都是巨大的，直接使用现有的 detector 对现实生活中的行人检测任务来说并不是最优的，否则 detector 很可能就会成为限制行人重识别任务效果的一个瓶颈。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>pass </p><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>上手Person Search相关的科研论文，这篇文章是必读的，是第一篇整合两个子任务到同一个框架的工作，源码由于是caffe的，对于新手不太友好，尤其是18年开始入坑CV的小白来说，一些更轻便的框架,把层，代价函数，模块封装好的，如tensorflow或是pytorch则更容易手上，建议可以从那个疑似复现代码的地址上手，可能复现不到这篇论文的结果，相差大约1~2%,但从熟悉整个Person Search的框架再好不过了，主要还是大部分的Person Search论文都没有开源，或者只是提供了test的部分代码和训练好的网络参数和结构，打包成了.pth等让读者在云盘上下载，有点小坑，很难复现到原始论文的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：Joint Detection and Identification Feature Learning for Person Search&lt;br&gt;链接：&lt;a href=&quot;https://arxiv.org/abs/1604.01850&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/1604.01850&lt;/a&gt;&lt;br&gt;代码地址： &lt;a href=&quot;https://github.com/ShuangLI59/person_search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ShuangLI59/person_search&lt;/a&gt; caffe版本&lt;br&gt;疑似复现地址：&lt;a href=&quot;https://github.com/liliangqi/person_search&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liliangqi/person_search&lt;/a&gt; pytorch版本&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码踩坑" scheme="http://www.cygao.xyz/tags/%E4%BB%A3%E7%A0%81%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【Person Search】 Person Re-identification in the Wild</title>
    <link href="http://www.cygao.xyz/2018/10/02/Person%20Re-identification%20in%20the%20Wild/"/>
    <id>http://www.cygao.xyz/2018/10/02/Person Re-identification in the Wild/</id>
    <published>2018-10-02T02:27:11.000Z</published>
    <updated>2019-08-11T03:13:00.285Z</updated>
    
    <content type="html"><![CDATA[<p>论文：Person Re-identification in the Wild<br>链接：<a href="https://arxiv.org/abs/1604.02531" target="_blank" rel="noopener">https://arxiv.org/abs/1604.02531</a><br>代码地址：<a href="https://github.com/liangzheng06/PRW-baseline" target="_blank" rel="noopener">https://github.com/liangzheng06/PRW-baseline</a><br><a id="more"></a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p> 这篇论文发布了一个可以研究端到端的行人检测-重识别的大规模数据集和一些baselines，baselines主要包括不同检测器和reid识别算法组合的性能，行人检测怎么有助于reid准确率的提升及评估不同检测器对reid的有效性。<br>  贡献：  </p><ol><li>提出了一个新的数据集：PRW，及基于数据集的广泛的benchmark。  <div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/PRW1.png" alt></div>       </li></ol><ol start="2"><li>行人检测通过以下两种方式对re-id有帮助，IDE 级联微调训练策略（充分利用detector得到的数据）+ CWS（Confidence Weighted Similarity，加入到相似度度量中（给错检附更低的权重，即通过优化相似度计算的方法改进detector对reid的影响）。</li><li>在特定场合下的accurate re-id过程中，检测器性能评价和一些关于发布数据集的实验结论。</li></ol><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>行人识别和重识别通常被分为两个不同的问题来考虑。作者开创性的在自己的数据集上研究了不同检测器和reid识别方法组合的性能，研究是否检测可以帮助提升reid准确率，研究选择怎样的检测器可以最大程度的提升reid准确率。<br>文中提出了与以往不同的新的dataset（PRW）和baselines（which moves beyond sequential application of detection and recognition），因为目前的许多数据集缺少annotations，从而无法将识别与再识别进行结合来评估。  </p><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><ul><li>前人的研究工作无法体现不同质量的detector对re-id精确度的影响。本文的pipline则是考虑了从detection到re-id的整个过程。  </li><li>Pedestrian detection的发展过程.</li><li>Person re-identification的发展过程。</li></ul><h1 id="3-The-PRW-Dataset"><a href="#3-The-PRW-Dataset" class="headerlink" title="3. The PRW Dataset"></a>3. The PRW Dataset</h1><p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/PRW2.png" alt></div><br>具体最直观的了解数据集方法就是下载它，一张张看加了解命名规则，README.md里介绍的很清楚。</p><h1 id="4-Evaluation-Protocols"><a href="#4-Evaluation-Protocols" class="headerlink" title="4. Evaluation Protocols"></a>4. Evaluation Protocols</h1><p>沿用了Person re-id的标准</p><h1 id="5-Experiments"><a href="#5-Experiments" class="headerlink" title="5. Experiments"></a>5. Experiments</h1><p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/PRW3.png" alt></div>    </p><p><div align="center"><img src="http://pw0x0t99o.bkt.clouddn.com/PRW4.png" alt></div><br>还有很多张实验的对比图没放，一些最基本的Detector+Metic-learning的方法，基本是作为以后Person Search论文里吊打的对比方法，毕竟拿深度学习的方法和传统方法对比，起码表格里看得出拉开了差距。</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul><li>设计有效的框回归方案来提升行人框定位精度，总而提升行人匹配正确率 </li><li>设计更复杂有效的权重方案，用检测的置信度或其他来指导更有效的相似度计算 </li><li>re-ranking方法对于可扩展的reid应用很有帮助 </li><li>怎样能够利用无ID标注的现存数据或若标签数据来提升reid性能也具有重要的研究价值 </li><li>检测和识别的联合学习问题，而不是组合形式，更符合reid实用需求 </li><li>有效的基于部件的reid，如对齐网络的引进和设计，将极大提升端到端网络的reid性能   </li></ul><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>  论文用的是matlab的代码，由于是16年的论文，从19年返回再来看价值不是很高，虽然现在也有很多还是把re-id和detection分开做的工作，但是只是在detection部分加入了简单的CNN层，re-id部分还是传统的图像处理。但是毕竟是提出的PRW的论文，引用也是必须的，PRW数据集是market1501的整帧图片，提出的作者也是同一个郑良大大，太厉害了。了解一下数据集图片命名的规则，对于做无监督的同学也是大有帮助的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：Person Re-identification in the Wild&lt;br&gt;链接：&lt;a href=&quot;https://arxiv.org/abs/1604.02531&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/abs/1604.02531&lt;/a&gt;&lt;br&gt;代码地址：&lt;a href=&quot;https://github.com/liangzheng06/PRW-baseline&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liangzheng06/PRW-baseline&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码踩坑" scheme="http://www.cygao.xyz/tags/%E4%BB%A3%E7%A0%81%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
</feed>
