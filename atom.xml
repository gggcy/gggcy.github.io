<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy的学习日常</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cygao.xyz/"/>
  <updated>2019-09-10T13:35:25.994Z</updated>
  <id>http://www.cygao.xyz/</id>
  
  <author>
    <name>Cunyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux的个人向常用操作</title>
    <link href="http://www.cygao.xyz/2019/09/10/linux/"/>
    <id>http://www.cygao.xyz/2019/09/10/linux/</id>
    <published>2019-09-10T06:46:44.000Z</published>
    <updated>2019-09-10T13:35:25.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四种通配符："><a href="#四种通配符：" class="headerlink" title="四种通配符："></a>四种通配符：</h2><ol><li>*可以匹配0个或多个任意字符</li><li>？只可以匹配单个字符，但是例如 rm a.*，可以匹配a.jpg，a.txt</li><li>[] 匹配一组单个字符，例如[12]匹配1或2，不匹配12；或者使用连字符分隔一定范围内的字符，例如[1-3]，它匹配1、2或3</li><li>{} 进行两种匹配：字符串和范围。如果用字符串必须用逗号分隔。比如 ls a.{jpg,txt}匹配 a.jpg和a.txt；ls {a,b}.jpg 匹配a.jpg和b.jpg。可以用 mkdir{a,b,c}快速创建多个目录。</li></ol><h2 id="clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。"><a href="#clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。" class="headerlink" title="clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。"></a>clear可以清楚屏幕，但是不会清楚history查看过去指令的记录。</h2><h2 id="ls及其衍生"><a href="#ls及其衍生" class="headerlink" title="ls及其衍生"></a>ls及其衍生</h2><ol><li>ls -R Documents/ 查看该文件夹中的所有文件列表</li><li>比较常用 -l，显示内容列表</li><li>-a查看隐藏文件和文件夹</li><li>-l是默认字母排序 -r倒叙排列，可以搭配-lr，不实用</li><li>-S按照文件大小，可以搭配-laS</li><li>-h人性化显示文件大小，做常用的是-lh</li></ol><h2 id="cd及其衍生"><a href="#cd及其衍生" class="headerlink" title="cd及其衍生"></a>cd及其衍生</h2><ol><li>cd - 改为之前目录</li></ol><h2 id="touch创建空文件，mkdir创建空目录"><a href="#touch创建空文件，mkdir创建空目录" class="headerlink" title="touch创建空文件，mkdir创建空目录"></a>touch创建空文件，mkdir创建空目录</h2><h2 id="cp-源文件-目标文件"><a href="#cp-源文件-目标文件" class="headerlink" title="cp 源文件 目标文件"></a>cp 源文件 目标文件</h2><ol><li>搭配 . 当前目录</li><li>搭配四种通配符</li><li>-v 显示复制文件的过程</li><li>-i 防止在复制时覆盖重要文件</li><li>-r 复制文件夹</li><li>-a等价于-dpr，可以确保备份时不会复制软连接的内容（这可能极大地增加复制量），只保留关键地文件属性（如所有者，时间戳），并递归处理子目录</li></ol><h2 id="mv-源文件-目标文件"><a href="#mv-源文件-目标文件" class="headerlink" title="mv 源文件 目标文件"></a>mv 源文件 目标文件</h2><ol><li>-v,-i,-r等同于cp</li><li>可以用来重命名文件或文件夹</li><li><strong>移动软连接时，例如dogs为~底下的软连接，指向/home/my/pictures/dogs，而现在要将这个链接移动到/home/my/libby下。一下命令只移动软连接：</strong><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv dogs ~/libby</span><br></pre></td></tr></table></figure></li></ol><p><strong>然而，下面的命令移动的时软连接指向的目录：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv dogs/ ~/libby</span><br></pre></td></tr></table></figure></p><p><strong>多了一个”/“！！！</strong></p><h2 id="ln-要链接的文件-硬链接名"><a href="#ln-要链接的文件-硬链接名" class="headerlink" title="ln 要链接的文件 硬链接名"></a>ln 要链接的文件 硬链接名</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">drwxr--r-- 2 root root 4096 abc/</span><br></pre></td></tr></table></figure><p>此处abc为目录，则2代表其下有多少子目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">-rw-r--r-- 1 root root a.txt</span><br><span class="line">$ ln a.txt b.txt</span><br><span class="line">$ ls -l</span><br><span class="line">-rw-r--r-- 2 root root a.txt</span><br><span class="line">-rw-r--r-- 2 root root b.txt</span><br></pre></td></tr></table></figure><p>此处1变成2，显示了该文件有多少硬链接。<br>使用 ls -i还会发现其索引号时相同的。a.txt和b.txt内容时一致的，实际在处理同一的数据。</p><p>硬链接的限制：无法指向目录，硬链接和源文件必须处于同一文件系统，因为每个分区都有各自的索引节点。</p><p>使用软连接<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s 源文件 连接名称</span><br></pre></td></tr></table></figure></p><p>硬链接索引节点相同，但软连接不同，因为他们是完全不同的文件。</p><h2 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm 删除文件"></a>rm 删除文件</h2><ol><li>搭配通配符</li><li>-i 提示功能，确认删除</li><li>-rf -r指的是递归每个子目录，删除所有文件，-f直接删除。</li></ol><h2 id="man-有问题找那个男人"><a href="#man-有问题找那个男人" class="headerlink" title="man 有问题找那个男人"></a>man 有问题找那个男人</h2><ol><li>man ls查看ls及其option</li><li>man -f ls 简单查看这个命令的说明</li><li>whatis ls 也是简单查看</li></ol><h2 id="info-查询手册，内容有点乱"><a href="#info-查询手册，内容有点乱" class="headerlink" title="info 查询手册，内容有点乱"></a>info 查询手册，内容有点乱</h2><h2 id="whereis-查找命令的可执行文件、源文件和手册页面的路径"><a href="#whereis-查找命令的可执行文件、源文件和手册页面的路径" class="headerlink" title="whereis 查找命令的可执行文件、源文件和手册页面的路径"></a>whereis 查找命令的可执行文件、源文件和手册页面的路径</h2><p>报告的顺序是:源文件位置–&gt;任何二进制可执行文件的位置–&gt;最后找到的是手册页面的位置。</p><ul><li>只想搜索二进制文件路径 -b whereis -b gcc</li><li>只想搜索手册页面路径 -m whereis -m ls</li><li>只想搜索源路径 -s whereis -s gcc</li></ul><p>非常好用的方法！！！一定得记住！！！</p><h2 id="which-找出将要运行的命令的版本"><a href="#which-找出将要运行的命令的版本" class="headerlink" title="which 找出将要运行的命令的版本"></a>which 找出将要运行的命令的版本</h2><p>比如gcc有多个版本，当前使用的哪个版本会先运行，即whereis -b gcc时发现有多个可执行文件。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which gcc</span><br></pre></td></tr></table></figure></p><p>同时也是快速判断系统是否有改特定命令的方法。</p><h2 id="type-揭示shell是如何解释命令"><a href="#type-揭示shell是如何解释命令" class="headerlink" title="type 揭示shell是如何解释命令"></a>type 揭示shell是如何解释命令</h2><p>不是常用命令，但如果想知道为什么命令没有按照预期的方式执行操作，type可以帮助你了解到问题所在。</p><h2 id="连续运行多个命令"><a href="#连续运行多个命令" class="headerlink" title="; 连续运行多个命令"></a>; 连续运行多个命令</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd a ;cd ..</span><br></pre></td></tr></table></figure><p>又回到了原目录。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 3;</span><br><span class="line">``` </span><br><span class="line">会等待延迟3秒钟。</span><br><span class="line"></span><br><span class="line">## &amp;&amp; 仅在前面的命令成功运行时才运行下一条命令</span><br></pre></td></tr></table></figure><p>$ cd a &amp;&amp; cd ..<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最好还是用&amp;&amp;，这要处理更加安全。</span><br><span class="line"></span><br><span class="line">## || 仅在前面的命令运行失败时，才运行下一条命令</span><br><span class="line"></span><br><span class="line">## $() 将一条命令的输出插入另一条命令</span><br></pre></td></tr></table></figure></p><p>$ date “+%Y-%m-%d”</p><blockquote><blockquote><p>2019-9-10<br>$ mkdir $(date “+%Y-%m-%d”)<br>2019-9-10/ #创建了日期命名的目录<br><code>`</code><br>这个是极为强大的功能，无处不在。</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四种通配符：&quot;&gt;&lt;a href=&quot;#四种通配符：&quot; class=&quot;headerlink&quot; title=&quot;四种通配符：&quot;&gt;&lt;/a&gt;四种通配符：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;*可以匹配0个或多个任意字符&lt;/li&gt;
&lt;li&gt;？只可以匹配单个字符，但是例如 rm a.*，可
      
    
    </summary>
    
      <category term="工作日常" scheme="http://www.cygao.xyz/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="linux" scheme="http://www.cygao.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>手推xgboost及常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/09/xgboost/"/>
    <id>http://www.cygao.xyz/2019/09/09/xgboost/</id>
    <published>2019-09-09T07:24:53.000Z</published>
    <updated>2019-09-09T07:53:23.589Z</updated>
    
    <content type="html"><![CDATA[<p>大部分内容转载于<a href="https://blog.csdn.net/v_JULY_v/article/details/81410574" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/81410574</a><br><a id="more"></a></p><h3 id="手推xgboost"><a href="#手推xgboost" class="headerlink" title="手推xgboost"></a>手推xgboost</h3><div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/xgboost1.jpg"></div> <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/xgboost2.jpg"></div> <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/xgboost3.jpg"></div> <h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>XGBOOST怎么调参，用了多少棵树</li><li>XGBOOST的回归怎么做的<br>自行在下方找答案吧。</li></ol><p>下面的内容摘抄自链接：<a href="https://blog.csdn.net/v_JULY_v/article/details/81410574" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/81410574</a>    </p><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h3><p> xgboost一直在竞赛江湖里被传为神器，比如时不时某个kaggle/天池比赛中，某人用xgboost于千军万马中斩获冠军。</p><p> 而我们的机器学习课程里也必讲xgboost，如寒所说：“RF和GBDT是工业界大爱的模型，Xgboost 是大杀器包裹，Kaggle各种Top排行榜曾一度呈现Xgboost一统江湖的局面，另外某次滴滴比赛第一名的改进也少不了Xgboost的功劳”。</p><p> 此外，公司七月在线从2016年上半年起，就开始组织学员参加各种比赛，以在实际竞赛项目中成长（毕竟，搞AI不可能没实战，而参加比赛历经数据处理、特征选择、模型调优、代码调参，是一个极好的真刀真枪的实战机会，对能力的提升和找/换工作的帮助都非常大）。</p><p> AI大潮之下，今年特别多从传统IT转行转岗转型AI的朋友，很多朋友都咨询如何转行AI，我一般都会着重强调学习AI或找/换AI的四大金刚：<a href="https://www.julyedu.com/category/index" target="_blank" rel="noopener">课程</a> + <a href="https://www.julyedu.com/question/index" target="_blank" rel="noopener">题库</a> + <a href="https://oj.julyedu.com/problemset.php" target="_blank" rel="noopener">OJ</a> + kaggle/天池。包括集训营的毕业考核更会融合kaggle或天池比赛。</p><p> 考虑到kaggle/天池比赛对搞数学科学的重要性，特写此文介绍xgboost，助力大家快速入门xgboost以及在比赛中获得优异成绩。</p><p> 最后，xgboost不是我July发明的，但我会确保本文对它的介绍是最通俗易懂的（且本文得到七月在线AI lab负责人陈博士审校）。另，感谢文末所列的全部参考文献，有何问题，欢迎随时留言评论，thanks。</p><h3 id="1-决策树"><a href="#1-决策树" class="headerlink" title="1 决策树"></a>1 决策树</h3><p> 举个例子，集训营某一期有100多名学员，假定给你一个任务，要你统计男生女生各多少人，当一个一个学员依次上台站到你面前时，你会怎么区分谁是男谁是女呢？</p><p> 很快，你考虑到男生的头发一般很短，女生的头发一般比较长，所以你通过头发的长短将这个班的所有学员分为两拨，长发的为“女”，短发为“男”。</p><p> 相当于你依靠一个指标“头发长短”将整个班的人进行了划分，于是形成了一个简单的决策树，而划分的依据是头发长短。<br> 这时，有的人可能有不同意见了：为什么要用“头发长短”划分呀，我可不可以用“穿的鞋子是否是高跟鞋”，“有没有喉结”等等这些来划分呢，答案当然是可以的。</p><p> 但究竟根据哪个指标划分更好呢？很直接的判断是哪个分类效果更好则优先用哪个。所以，这时就需要一个评价标准来量化分类效果了。 </p><p> 怎么判断“头发长短”或者“是否有喉结”是最好的划分方式，效果怎么量化呢？直观上来说，如果根据某个标准分类人群后，纯度越高效果越好，比如说你分为两群，“女”那一群都是女的，“男”那一群全是男的，那这个效果是最好的。但有时实际的分类情况不是那么理想，所以只能说越接近这种情况，我们则认为效果越好。</p><p> 量化分类效果的方式有很多，比如信息增益（ID3）、信息增益率（C4.5）、基尼系数（CART）等等。</p><blockquote><p><strong>信息增益的度量标准：熵</strong></p><p> ID3算法的核心思想就是以信息增益度量属性选择，选择分裂后信息增益最大的属性进行分裂。</p><p> 什么是信息增益呢？为了精确地定义信息增益，我们先定义信息论中广泛使用的一个度量标准，称为<strong>熵</strong>（entropy），它刻画了任意样例集的纯度（purity）。给定包含关于某个目标概念的正反样例的样例集S，那么S相对这个布尔型分类的熵为：</p><blockquote><p><img src="http://hi.csdn.net/attachment/201201/8/0_1326017614WvVU.gif" alt></p><p> 上述公式中，p+代表正样例，比如在本文开头第二个例子中p+则意味着去打羽毛球，而p-则代表反样例，不去打球(在有关熵的所有计算中我们定义0log0为0)。</p><p> 举例来说，假设S是一个关于布尔概念的有14个样例的集合，它包括9个正例和5个反例（我们采用记号[9+，5-]来概括这样的数据样例），那么S相对于这个布尔样例的熵为：</p></blockquote><blockquote><p>Entropy（[9+，5-]）=-（9/14）log2（9/14）-（5/14）log2（5/14）=0.940。</p><p> So，根据上述这个公式，我们可以得到：</p></blockquote><ul><li>如果S的所有成员属于同一类，则Entropy(S)=0； </li><li>如果S的正反样例数量相等，则Entropy(S)=1； </li><li>如果S的正反样例数量不等，则熵介于0，1之间 如下图所示：</li></ul><blockquote><p><img src="http://hi.csdn.net/attachment/201201/8/0_1326018003ADwJ.gif" alt></p><p> 看到没，通过Entropy的值，你就能评估当前分类树的分类效果好坏了。</p></blockquote><p> 更多细节如剪枝、过拟合、优缺点、可以参考此文《<a href="https://blog.csdn.net/v_july_v/article/details/7577684" target="_blank" rel="noopener">决策树学习</a>》。</p></blockquote><p> 所以，现在决策树的灵魂已经有了，即依靠某种指标进行树的分裂达到分类/回归的目的，总是希望纯度越高越好。</p><p>### </p><h3 id="2-回归树与集成学习"><a href="#2-回归树与集成学习" class="headerlink" title="2.回归树与集成学习"></a>2.回归树与集成学习</h3><p> 如果用一句话定义xgboost，很简单：Xgboost就是由很多CART树集成。但，什么是CART树？</p><blockquote><p>数据挖掘或机器学习中使用的决策树有两种主要类型：</p><ol><li>分类树分析是指预测结果是数据所属的类（比如某个电影去看还是不看） </li><li>回归树分析是指预测结果可以被认为是实数（例如房屋的价格，或患者在医院中的逗留时间） 而术语分类回归树（CART，Classification And Regression Tree）分析是用于指代上述两种树的总称，由Breiman等人首先提出。</li></ol><p> <strong>2.1 回归树</strong><br> 事实上，分类与回归是两个很接近的问题，分类的目标是根据已知样本的某些特征，判断一个新的样本属于哪种已知的样本类，它的结果是离散值。而回归的结果是连续的值。当然，本质是一样的，都是特征（feature）到结果/标签（label）之间的映射。</p></blockquote><p> 理清了什么是分类和回归之后，理解分类树和回归树就不难了。</p><p> 分类树的样本输出（即响应值）是类的形式，比如判断这个救命药是真的还是假的，周末去看电影《风语咒》还是不去。而回归树的样本输出是数值的形式，比如给某人发放房屋贷款的数额就是具体的数值，可以是0到300万元之间的任意值。</p><p> 所以，对于回归树，你没法再用分类树那套信息增益、信息增益率、基尼系数来判定树的节点分裂了，你需要采取新的方式评估效果，包括预测误差（常用的有均方误差、对数误差等）。而且节点不再是类别，是数值（预测值），那么怎么确定呢？有的是节点内样本均值，有的是最优化算出来的比如Xgboost。</p><blockquote><p>CART回归树是假设树为二叉树，通过不断将特征进行分裂。比如当前树结点是基于第j个特征值进行分裂的，设该特征值小于s的样本划分为左子树，大于s的样本划分为右子树。</p><p> <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/1-3.png" alt></p><p> 而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为：</p><p> <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/2-3.png" alt></p><p> 因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数：</p><p> <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/3-3.png" alt></p><p> 所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。</p><p> <strong>2.2 boosting集成学习</strong></p></blockquote><p> 所谓集成学习，是指构建多个分类器（弱分类器）对数据集进行预测，然后用某种策略将多个分类器预测的结果集成起来，作为最终预测结果。通俗比喻就是“三个臭皮匠赛过诸葛亮”，或一个公司董事会上的各董事投票决策，它要求每个弱分类器具备一定的“准确性”，分类器之间具备“差异性”。</p><p> 集成学习根据各个弱分类器之间有无依赖关系，分为Boosting和Bagging两大流派：</p><ol><li>Boosting流派，各分类器之间有依赖关系，必须串行，比如Adaboost、GBDT(Gradient Boosting Decision Tree)、Xgboost </li><li>Bagging流派，各分类器之间没有依赖关系，可各自并行，比如随机森林（Random Forest） 而著名的Adaboost作为boosting流派中最具代表性的一种方法，本博客曾详细介绍它。</li></ol><blockquote><p>AdaBoost，是英文”Adaptive Boosting”（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</p><p> 具体说来，整个Adaboost 迭代算法就3步：</p><ol><li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。 </li><li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。 </li><li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。<br>而另一种boosting方法GBDT（Gradient Boost Decision Tree)，则与AdaBoost不同，GBDT每一次的计算是都为了减少上一次的残差，进而在残差减少（负梯度）的方向上建立一个新的模型。</li></ol></blockquote><p> boosting集成学习由多个相关联的决策树联合决策，什么叫相关联？举个例子</p><ol><li>有一个样本[数据-&gt;标签]是：[(2，4，5)-&gt; 4] </li><li>第一棵决策树用这个样本训练的预测为3.3 </li><li>那么第二棵决策树训练时的输入，这个样本就变成了：[(2，4，5)-&gt; 0.7] </li><li><p>也就是说，下一棵决策树输入样本会与前面决策树的训练和预测相关 很快你会意识到，Xgboost为何也是一个boosting的集成学习了。</p><p>而一个回归树形成的关键点在于：</p></li></ol><ul><li>分裂点依据什么来划分（如前面说的均方误差最小，loss）； </li><li>分类后的节点预测值是多少（如前面说，有一种是将叶子节点下各样本实际值得均值作为叶子节点预测误差，或者计算所得） 至于另一类集成学习方法，比如Random Forest（随机森林）算法，各个决策树是独立的、每个决策树在样本堆里随机选一批样本，随机选一批特征进行独立训练，各个决策树之间没有啥关系。本文暂不展开介绍。</li></ul><h3 id="3-GBDT"><a href="#3-GBDT" class="headerlink" title="3.GBDT"></a>3.GBDT</h3><p> 说到Xgboost，不得不先从GBDT(Gradient Boosting Decision Tree)说起。因为xgboost本质上还是一个GBDT，但是力争把速度和效率发挥到极致，所以叫X (Extreme) GBoosted。包括前面说过，两者都是boosting方法。</p><p> GBDT的原理很简单，就是所有弱分类器的结果相加等于预测值，然后下一个弱分类器去拟合误差函数对预测值的梯度/残差(这个梯度/残差就是预测值与真实值之间的误差)。当然了，它里面的弱分类器的表现形式就是各棵树。如图所示：Y = Y1 + Y2 + Y3。</p><p> <img src="https://img-blog.csdn.net/20180804144218395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 举一个非常简单的例子，比如我今年30岁了，但计算机或者模型GBDT并不知道我今年多少岁，那GBDT咋办呢？</p><ol><li>它会在第一个弱分类器（或第一棵树中）随便用一个年龄比如20岁来拟合，然后发现误差有10岁； </li><li>接下来在第二棵树中，用6岁去拟合剩下的损失，发现差距还有4岁； </li><li>接着在第三棵树中用3岁拟合剩下的差距，发现差距只有1岁了； </li><li><p>最后在第四课树中用1岁拟合剩下的残差，完美。 最终，四棵树的结论加起来，就是真实年龄30岁。实际工程中，gbdt是计算负梯度，用负梯度近似残差。</p><p>注意，为何gbdt可以用用负梯度近似残差呢？</p><p>回归任务下，GBDT 在每一轮的迭代时对每个样本都会有一个预测值，此时的损失函数为均方差损失函数，</p><p><img src="https://img-blog.csdnimg.cn/20190310003539352.gif" alt></p><p>那此时的负梯度是这样计算的</p><p><img src="https://img-blog.csdnimg.cn/20190310003450668.gif" alt></p><p>所以，当损失函数选用均方损失函数是时，每一次拟合的值就是（真实值 - 当前模型预测的值），即残差。此时的变量是<img src="https://img-blog.csdnimg.cn/20190310003909104.gif" alt>，即“当前预测模型的值”，也就是对它求负梯度。</p></li></ol><blockquote><p>另外，这里还得再啰嗦一下，上面预测年龄的第一个步骤中的“随便”二字看似随便，其实深入思考一下一点都不随便，你会发现大部分做预测的模型，基本都是这么个常规套路，先随便用一个值去预测，然后对比预测值与真实值的差距，最后不断调整 缩小差距。所以会出来一系列目标函数：确定目标，和损失函数：缩小误差。</p><p> 再进一步思考，你会发现这完全符合人类做预测的普遍常识、普遍做法，当对一个事物不太了解时，一开始也是根据经验尝试、初探，直到逼近某种意义上的接近或者完全吻合。</p><p> 还是年龄预测的例子。</p></blockquote><p> 简单起见，假定训练集只有4个人：A,B,C,D，他们的年龄分别是14,16,24,26。其中A、B分别是高一和高三学生；C,D分别是应届毕业生和工作两年的员工。</p><p> 所以，现在的问题就是我们要预测这4个人的年龄，咋下手？很简单，先随便用一个年龄比如20岁去拟合他们，然后根据实际情况不断调整。</p><p> 如果是用一棵传统的回归决策树来训练，会得到如下图所示结果：</p><p> <img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153148112917172596.png" alt><br> 现在我们使用GBDT来做这件事，由于数据太少，我们限定叶子节点做多有两个，即每棵树都只有一个分枝，并且限定只学两棵树。</p><p> 我们会得到如下图所示结果：</p><p> <img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153148115267426581.png" alt><br> 在第一棵树分枝和图1一样，由于A,B年龄较为相近，C,D年龄较为相近，他们被分为左右两拨，每拨用平均年龄作为预测值。</p><ul><li>此时计算残差（<strong>残差的意思就是：A的实际值 - A的预测值 = A的残差</strong>），所以A的残差就是实际值14 - 预测值15 = 残差值-1。 </li><li><p>注意，A的预测值是指前面所有树累加的和，这里前面只有一棵树所以直接是15，如果还有树则需要都累加起来作为A的预测值。 </p><blockquote><p>残差在数理统计中是指实际观察值与估计值（拟合值）之间的差。“残差”蕴含了有关模型基本假设的重要信息。如果回归模型正确的话， 我们可以将残差看作误差的观测值。</p><p>进而得到A,B,C,D的残差分别为-1,1，-1,1。</p></blockquote><p>然后拿它们的残差-1、1、-1、1代替A B C D的原值，到第二棵树去学习，第二棵树只有两个值1和-1，直接分成两个节点，即A和C分在左边，B和D分在右边，经过计算（比如A，实际值-1 - 预测值-1 = 残差0，比如C，实际值-1 - 预测值-1 = 0），此时所有人的残差都是0。</p><p>残差值都为0，相当于第二棵树的预测值和它们的实际值相等，则只需把第二棵树的结论累加到第一棵树上就能得到真实年龄了，即每个人都得到了真实的预测值。</p><p>换句话说，现在A,B,C,D的预测值都和真实年龄一致了。Perfect！<br>A: 14岁高一学生，购物较少，经常问学长问题，预测年龄A = 15 – 1 = 14<br>B: 16岁高三学生，购物较少，经常被学弟问问题，预测年龄B = 15 + 1 = 16</p><p>C: 24岁应届毕业生，购物较多，经常问师兄问题，预测年龄C = 25 – 1 = 24<br>D: 26岁工作两年员工，购物较多，经常被师弟问问题，预测年龄D = 25 + 1 = 26</p><p>所以，GBDT需要将多棵树的得分累加得到最终的预测得分，且每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差。</p></li></ul><h3 id="4-Xgboost"><a href="#4-Xgboost" class="headerlink" title="4.Xgboost"></a>4.Xgboost</h3><p> <strong>4.1 xgboost树的定义</strong></p><p> 本节的示意图基本引用自xgboost原作者陈天奇的讲义PPT中。</p><p> 举个例子，我们要预测一家人对电子游戏的喜好程度，考虑到年轻和年老相比，年轻更可能喜欢电子游戏，以及男性和女性相比，男性更喜欢电子游戏，故先根据年龄大小区分小孩和大人，然后再通过性别区分开是男是女，逐一给各人在电子游戏喜好程度上打分，如下图所示。</p><blockquote><p><img src="https://img-blog.csdn.net/20180804174128743?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 就这样，训练出了2棵树tree1和tree2，类似之前gbdt的原理，两棵树的结论累加起来便是最终的结论，所以小孩的预测分数就是两棵树中小孩所落到的结点的分数相加：2 + 0.9 = 2.9。爷爷的预测分数同理：-1 + （-0.9）= -1.9。具体如下图所示</p></blockquote><blockquote><p><img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/5-2.png" alt></p><p> 恩，你可能要拍案而起了，惊呼，这不是跟上文介绍的gbdt乃异曲同工么？</p></blockquote><p> 事实上，如果不考虑工程实现、解决问题上的一些差异，xgboost与gbdt比较大的不同就是目标函数的定义。xgboost的目标函数如下图所示：</p><p> <img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase6415314827826172363.png" alt></p><p> 其中</p><ul><li>红色箭头所指向的L 即为损失函数（比如平方损失函数：<img src="https://img-blog.csdnimg.cn/20190115001152242.gif" alt>，或logistic损失函数：<img src="https://img-blog.csdn.net/20180805010528463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>） </li><li>红色方框所框起来的是正则项（包括L1正则、L2正则） </li><li>红色圆圈所圈起来的为常数项 </li><li><p>对于<img src="https://private.codecogs.com/gif.latex?f%28x%29" alt="f(x)">，xgboost利用泰勒展开三项，做一个近似 我们可以很清晰地看到，最终的目标函数只依赖于每个数据点在误差函数上的一阶导数和二阶导数。</p><p>额，峰回路转，突然丢这么大一个公式，不少人可能瞬间就懵了。没事，下面咱们来拆解下这个目标函数，并一一剖析每个公式、每个符号、每个下标的含义。</p><p><strong>4.2 xgboost目标函数</strong></p><p>xgboost的核心算法思想不难，基本就是</p></li></ul><ol><li><p>不断地添加树，<strong>不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差</strong>。 <img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/4-2.png" alt></p><p> 注：w_q(x)为叶子节点q的分数，<img src="https://img-blog.csdn.net/20180806215950729?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>对应了所有K棵回归树（regression tree）的集合，而f(x)为其中一棵回归树。</p></li></ol><ol start="3"><li>当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数 </li><li><p>最后只需要将每棵树对应的分数加起来就是该样本的预测值。 显然，我们的目标是要使得树群的预测值<img src="https://img-blog.csdn.net/2018080921415487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>尽量接近真实值<img src="https://private.codecogs.com/gif.latex?y_%7Bi%7D" alt="y_{i}">，而且有尽量大的泛化能力。</p><p>所以，从数学角度看这是一个泛函最优化问题，故把目标函数简化如下：</p><p><img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155669134287033.png" alt></p><p>如你所见，这个目标函数分为两部分：损失函数和正则化项。且<strong>损失函数揭示训练误差</strong>（即预测分数和真实分数的差距）<strong>，正则化定义复杂度。</strong></p><p>对于上式而言，<img src="https://img-blog.csdn.net/2018080921415487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>是整个累加模型的输出，正则化项<img src="https://img-blog.csdnimg.cn/20190309164745107.png" alt>是则表示树的复杂度的函数，值越小复杂度越低，泛化能力越强，其表达式为</p><p><img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155674940294423.png" alt></p><p>T表示叶子节点的个数，w表示叶子节点的分数。直观上看，目标要求预测误差尽量小，且叶子节点T尽量少（γ控制叶子结点的个数），节点数值w尽量不极端（λ控制叶子节点的分数不会过大），防止过拟合。</p></li></ol><blockquote><p>插一句，一般的目标函数都包含下面两项</p><p> <img src="https://img-blog.csdn.net/20180805010136131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 其中，误差/损失函数鼓励我们的模型尽量去拟合训练数据，使得最后的模型会有比较少的 bias。而正则化项则鼓励更加简单的模型。因为当模型简单之后，有限数据拟合出来结果的随机性比较小，不容易过拟合，使得最后模型的预测更加稳定。</p><p> <strong>4.2.1 模型学习与训练误差</strong></p></blockquote><p> 具体来说，目标函数第一部分中的 <img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 表示第<img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>个样本，<img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> (<img src="https://img-blog.csdn.net/2018080921415487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> − <img src="https://private.codecogs.com/gif.latex?y_%7Bi%7D" alt="y_{i}">) 表示第 <img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 个样本的预测误差，我们的目标当然是误差越小越好。</p><p> 类似之前GBDT的套路，xgboost也是需要将多棵树的得分累加得到最终的预测得分（每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差）。</p><p> <img src="http://i.imgur.com/hPRke6w.png" alt></p><p> 但，我们如何选择每一轮加入什么<img src="https://private.codecogs.com/gif.latex?f" alt="f">呢？答案是非常直接的，选取一个<img src="https://img-blog.csdn.net/20180805124812416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 来使得我们的目标函数尽量最大地降低。</p><blockquote><p><img src="https://img-blog.csdn.net/20180805012146417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 再强调一下，考虑到<strong>第t轮的模型预测值**</strong> <img src="https://img-blog.csdnimg.cn/20190116224720643.png" alt> = 前t-1轮的模型预测<img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt> + <img src="https://img-blog.csdnimg.cn/20190116225031205.png" alt>，因此误差函数记为：<strong><img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> </strong>( <strong><img src="https://img-blog.csdn.net/20180805124717659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></strong>, <img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt>+ <img src="https://img-blog.csdnimg.cn/20190116225031205.png" alt> )**，后面一项为正则化项。</p></blockquote><p> 对于这个误差函数的式子而言，在第t步，<img src="https://img-blog.csdn.net/20180805124717659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>是真实值，即已知，<strong><img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt></strong>可由上一步第t-1步中的<img src="https://img-blog.csdnimg.cn/20190307212807817.gif" alt>加上<img src="https://img-blog.csdnimg.cn/20190115131437590.gif" alt>计算所得，某种意义上也算已知值，故模型学习的是<img src="https://img-blog.csdn.net/20180805124812416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>。</p><p> 上面那个Obj的公式表达的可能有些过于抽象，我们可以考虑当<img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 是平方误差的情况（相当于<img src="https://img-blog.csdnimg.cn/20190115001152242.gif" alt>），这个时候我们的目标可以被写成下面这样的二次函数（图中画圈的部分表示的就是预测值和真实值之间的残差）：</p><blockquote><p><img src="https://img-blog.csdn.net/20180805012522806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> 更加一般的，损失函数不是二次函数咋办？利用泰勒展开，不是二次的想办法近似为二次（如你所见，定义了一阶导<img src="https://private.codecogs.com/gif.latex?g" alt="g">和二阶导<img src="https://private.codecogs.com/gif.latex?h" alt="h">）。</p></blockquote><blockquote><p><img src="http://i.imgur.com/4UggIum.png" alt></p><p> 恩恩，注意了！不少人可能就会在这里卡壳，网上也很少有文章解释清楚，在和七月在线AI lab陈博士讨论之后，发现这里面最关键的其实就是把泰勒二阶展开各项和xgboost 目标函数的对应关系搞清楚，相当于我们可以利用泰勒二阶展开去做目标函数的近似。</p></blockquote><p> 首先，这是泰勒二阶展开<img src="https://img-blog.csdnimg.cn/20190114211855366.png" alt></p><p> 对应到xgboost的目标函数里头</p><p> <img src="https://img-blog.csdnimg.cn/2019011421570463.png" alt></p><p> 忽略损失函数<img src="https://img-blog.csdn.net/20180805124216303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> 中的<img src="https://img-blog.csdnimg.cn/20190114224146584.gif" alt>（别忘了上面说的“ 在第t步，<img src="https://img-blog.csdn.net/20180805124717659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>是真实值，即已知 ”，不影响后续目标函数对<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799905263888750.png" alt>的偏导计算），做下一一对应：</p><ul><li>泰勒二阶展开f 里的x对应目标函数里的<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799905263888750.png" alt>， </li><li>f 里<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64155197699632731742.png" alt>的对应目标函数的<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799902222028087.png" alt>， </li><li><p>从而f 对x求导数时，对应为目标函数对<img src="https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64154799905263888750.png" alt>求偏导 得到：</p><p><img src="https://img-blog.csdnimg.cn/20190114224457972.png" alt></p><p>其中，<img src="https://img-blog.csdnimg.cn/20190114224646298.png" alt>，<img src="https://img-blog.csdnimg.cn/2019011422465540.png" alt></p><p>呜呼，透了！不过，这个转化过程中的关键泰勒二次展开到底是哪来的呢？</p></li></ul><blockquote><p>在数学中，泰勒公式（英语：Taylor’s Formula）是一个用函数在某点的信息描述其附近取值的公式。这个公式来自于微积分的泰勒定理（Taylor’s theorem），泰勒定理描述了一个可微函数，如果函数足够光滑的话，在已知函数在某一点的各阶导数值的情况之下，泰勒公式可以用这些导数值做系数构建一个多项式来近似函数在这一点的邻域中的值，这个多项式称为泰勒多项式（Taylor polynomial）。</p><p> 相当于告诉我们可由利用泰勒多项式的某些次项做原函数的近似。</p><p> 泰勒定理：<br> 设 n 是一个正整数。如果定义在一个包含 a 的区间上的函数 f 在 a 点处 n+1 次可导，那么对于这个区间上的任意 x，都有：</p><p> <img src="https://img-blog.csdnimg.cn/20190114235057740.png" alt></p><p> 其中的多项式称为函数在a 处的泰勒展开式，剩余的<img src="https://img-blog.csdnimg.cn/20190114234926647.png" alt>是泰勒公式的余项，是<img src="https://img-blog.csdnimg.cn/20190114234943527.png" alt>的高阶无穷小。</p><p> 接下来，考虑到我们的第t 颗回归树是根据前面的t-1颗回归树的残差得来的，相当于t-1颗树的值<strong><img src="https://img-blog.csdnimg.cn/20190116224929746.png" alt></strong>是已知的。换句话说，<img src="https://img-blog.csdnimg.cn/20190116004713489.png" alt>对目标函数的优化不影响，可以直接去掉，且常数项也可以移除，从而得到如下一个比较统一的目标函数。</p></blockquote><blockquote><p><img src="http://i.imgur.com/quPhp1K.png" alt></p><p> 这时，目标函数只依赖于每个数据点在误差函数上的一阶导数<img src="https://private.codecogs.com/gif.latex?g" alt="g">和二阶导数<img src="https://private.codecogs.com/gif.latex?h" alt="h">（相信你已经看出xgboost和gbdt的不同了，目标函数保留了泰勒展开的二次项）。</p></blockquote><p> 总的指导原则如就职Google的读者crab6789所说：</p><blockquote><p>实质是把样本分配到叶子结点会对应一个obj，优化过程就是obj优化。也就是分裂节点到叶子不同的组合，不同的组合对应不同obj，所有的优化围绕这个思想展开。</p><p> 到目前为止我们讨论了目标函数中的第一个部分：训练误差。接下来我们讨论目标函数的第二个部分：正则项，即如何定义树的复杂度。</p></blockquote><p> <strong>4.2.2 正则项：树的复杂度</strong></p><p> 首先，梳理下几个规则</p><ul><li>用叶子节点集合以及叶子节点得分表示  </li><li>每个样本都落在一个叶子节点上  </li><li>q(x)表示样本x在某个叶子节点上，wq(x)是该节点的打分，即该样本的模型预测值 所以当我们把树成<strong>结构部分q</strong>和<strong>叶子权重部分w后，</strong>结构函数q把输入映射到叶子的索引号上面去，而w给定了每个索引号对应的叶子分数是什么。</li></ul><blockquote><p><img src="http://i.imgur.com/P5QtOgo.png" alt></p><p> 另外，如下图所示，xgboost对树的复杂度包含了两个部分：</p></blockquote><ol><li>一个是树里面叶子节点的个数T </li><li><p>一个是树上叶子节点的得分w的L2模平方（对w进行L2正则化，相当于针对每个叶结点的得分增加L2平滑，目的是为了避免过拟合） </p><blockquote><p><img src="https://img-blog.csdn.net/20170228153006200" alt></p><p>在这种新的定义下，我们可以把之前的目标函数进行如下变形（另，别忘了：<img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155674940294423.png" alt>）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20181208010713981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92,size_16,color_FFFFFF,t_70" alt></p><p>其中<img src="https://img-blog.csdn.net/20180804185718100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>被定义为每个叶节点 j 上面样本下标的集合 <img src="https://img-blog.csdn.net/20160421105402974" alt>，g是一阶导数，h是二阶导数。这一步是由于xgboost目标函数第二部分加了两个正则项，一个是叶子节点个数(T),一个是叶子节点的分数(w)。</p><p>从而，加了正则项的目标函数里就出现了两种累加</p></li></ol><ul><li>一种是<img src="https://img-blog.csdn.net/2018080512504384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> - &gt; n（样本数） </li><li><p>一种是<img src="https://img-blog.csdn.net/20180805125138736?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt> -&gt; T（叶子节点数） 这一个目标包含了T个相互独立的单变量二次函数。</p><p>理解这个推导的关键在哪呢？在和AI lab陈博士讨论之后，其实就在于理解这个定义：<img src="https://img-blog.csdn.net/20180804185718100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>被定义为每个叶节点 j 上面样本下标的集合 <img src="https://img-blog.csdn.net/20160421105402974" alt>，这个定义里的q(xi)要表达的是：每个样本值xi 都能通过函数q(xi)映射到树上的某个叶子节点，从而通过这个定义把两种累加统一到了一起。</p><p>接着，我们可以定义</p><p><img src="https://img-blog.csdn.net/20160421105610771" alt></p><p>最终公式可以化简为</p><p><img src="https://img-blog.csdn.net/20160421105711217" alt></p><p>通过对<img src="https://img-blog.csdn.net/20160421105932533" alt>求导等于0，可以得到</p><p><img src="https://img-blog.csdn.net/20160421110031784" alt></p><p>然后把<img src="https://img-blog.csdn.net/20160421105932533" alt>最优解代入得到：</p><p><img src="https://img-blog.csdn.net/20160421110139754" alt></p><p><strong>4.3 打分函数计算</strong></p><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)<img src="https://img-blog.csdn.net/20160421110535150" alt></p><p><strong>4.3.1 分裂节点</strong></p><p>很有意思的一个事是，我们从头到尾了解了xgboost如何优化、如何计算，但树到底长啥样，我们却一直没看到。很显然，一棵树的生成是由一个节点一分为二，然后不断分裂最终形成为整棵树。那么树怎么分裂的就成为了接下来我们要探讨的关键。</p><p>对于一个叶子节点如何进行分裂，xgboost作者在其原始论文中给出了两种分裂节点的方法</p><p>（1）枚举所有不同树结构的贪心法</p><p>现在的情况是只要知道树的结构，就能得到一个该结构下的最好分数，那如何确定树的结构呢？</p><p>一个想当然的方法是：不断地枚举不同树的结构，然后利用打分函数来寻找出一个最优结构的树，接着加入到模型中，不断重复这样的操作。而再一想，你会意识到要枚举的状态太多了，基本属于无穷种，那咋办呢？</p><p>我们试下贪心法，从树深度0开始，每一节点都遍历所有的特征，比如年龄、性别等等，然后对于某个特征，<strong>先按照该特征里的值进行排序，然后线性扫描该特征进而确定最好的分割点</strong>，最后对所有特征进行分割后，我们选择所谓的增益Gain最高的那个特征，而Gain如何计算呢？</p><p>还记得4.2节最后，我们得到的计算式子吧？</p><p><img src="https://img-blog.csdn.net/20160421110139754" alt></p><p>换句话说，目标函数中的G/(H+λ)部分，表示着每一个叶子节点对当前模型损失的贡献程度，融合一下，得到Gain的计算表达式，如下所示：</p></li></ul><blockquote><p><img src="https://img-blog.csdn.net/20160421110908655" alt></p><p> 第一个值得注意的事情是“对于某个特征，先按照该特征里的值进行排序”，这里举个例子。</p></blockquote><p> 比如设置一个值a，然后枚举所有x &lt; a、a &lt; x这样的条件（<strong>x代表某个特征比如年龄age，把age从小到大排序：假定从左至右依次增大，则比a小的放在左边，比a大的放在右边</strong>），对于某个特定的分割a，我们要计算a左边和右边的导数和。</p><p> 比如总共五个人，按年龄排好序后，一开始我们总共有如下4种划分方法：</p><ol><li>把第一个人和后面四个人划分开 </li><li>把前两个人和后面三个人划分开 </li><li>把前三个人和后面两个人划分开 </li><li>把前面四个人和后面一个人划分开 接下来，把上面4种划分方法全都各自计算一下Gain，看哪种划分方法得到的Gain值最大则选取哪种划分方法，经过计算，发现把第2种划分方法“前面两个人和后面三个人划分开”得到的Gain值最大，意味着在一分为二这个第一层层面上这种划分方法是最合适的。</li></ol><blockquote><p><img src="https://img-blog.csdn.net/20160421111024891" alt></p><p> 换句话说，对于所有的特征x，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和GL和GR。然后用计算Gain的公式计算每个分割方案的分数就可以了。</p></blockquote><p> 然后后续则依然按照这种划分方法继续第二层、第三层、第四层、第N层的分裂。</p><p> 第二个值得注意的事情就是引入分割不一定会使得情况变好，所以我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值γ 的时候，则忽略这个分割。</p><p> 换句话说，当引入某项分割，结果分割之后得到的分数 - 不分割得到的分数得到的值太小（比如小于我们的最低期望阀值γ），但却因此得到的复杂度过高，则相当于得不偿失，不如不分割。即做某个动作带来的好处比因此带来的坏处大不了太多，则为避免复杂 多一事不如少一事的态度，不如不做。</p><p> 相当于在我们发现“分”还不如“不分”的情况下后（得到的增益太小，小到小于阈值γ），会有2个叶子节点存在同一棵子树上的情况。</p><p> 下面是论文中的算法</p><blockquote><p><img src="https://img-blog.csdn.net/20170228144201588" alt></p><p> （2）近似算法</p></blockquote><p> 主要针对数据太大，不能直接进行计算</p><blockquote><p><img src="https://img-blog.csdn.net/20170228144525979" alt></p><p> 就职于Google的读者crab6789点评：</p></blockquote><blockquote><p>把样本从根分配到叶子结点，就是个排列组合。不同的组合对应的cost不同。求最好的组合你就要try，一味穷举是不可能的，所以才出来贪婪法。不看从头到尾 就看当下节点怎么分配最好。这才有了那个exact greddy方法，后来还想加速才有了histogram的做法。</p><p> <strong>4.4 小结：Boosted Tree Algorithm </strong></p></blockquote><p> 总结一下，如图所示</p><p> <img src="http://i.imgur.com/L7PhJwO.png" alt></p><p> 咱们来再次回顾整个过程。</p><p> 如果某个样本label数值为4，那么第一个回归树预测3，第二个预测为1； 另外一组回归树，一个预测2，一个预测2，那么倾向后一种，为什么呢？前一种情况，第一棵树学的太多，太接近4，也就意味着有较大的过拟合的风险。</p><p> OK，听起来很美好，可是怎么实现呢，上面这个目标函数跟实际的参数怎么联系起来，记得我们说过，回归树的参数：</p><ol><li>选取哪个feature分裂节点呢 </li><li><p>节点的预测值（总不能靠取平均值这么粗暴不讲道理的方式吧，好歹高级一点） 最终的策略就是：贪心 + 最优化（对的，二次最优化） 。</p><p>通俗解释贪心策略：就是决策时刻按照当前目标最优化决定，说白了就是眼前利益最大化决定，“目光短浅”策略。</p><p>这里是怎么用贪心策略的呢，刚开始你有一群样本，放在第一个节点，这时候T=1，w多少呢，不知道，是求出来的，这时候所有样本的预测值都是w,带入样本的label数值，此时loss function变为</p><p><img src="http://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64153155689536706939.png" alt></p></li></ol><ul><li>如果这里的l(w−yi)误差表示用的是平方误差，那么上述函数就是一个关于w的二次函数求最小值，取最小值的点就是这个节点的预测值，最小的函数值为最小损失函数。 </li><li>本质上来讲，这就是一个二次函数最优化问题！但要是损失函数不是二次函数咋办？泰勒展开，不是二次的想办法近似为二次。 接着来，接下来要选个feature分裂成两个节点，变成一棵弱小的树苗，那么需要：</li></ul><ol><li>确定分裂用的feature，how？最简单的是粗暴的枚举/穷举（嗯，够粗暴），然后选择loss function效果最好的那个； </li><li><p>如何确立节点的w以及最小的loss function，大声告诉我怎么做？对，二次函数的求最值（计算二次的最值一般都有固定套路，即导数等于0的点） 。所以，选择一个feature分裂，计算loss function最小值，然后再选一个feature分裂，又得到一个loss function最小值，你枚举完，找一个效果最好的，把树给分裂，就得到了小树苗。 在分裂的时候，你可以注意到，每次节点分裂，loss function被影响的只有这个节点的样本，因而每次分裂，计算分裂的增益（loss function的降低量）只需要关注打算分裂的那个节点的样本。</p><p>总而言之，XGBoost使用了和CART回归树一样的想法，利用贪婪算法，遍历所有特征的所有特征划分点，不同的是使用的目标函数不一样。具体做法就是分裂后的目标函数值比单子叶子节点的目标函数的增益，同时为了限制树生长过深，还加了个阈值，只有当增益大于该阈值才进行分裂。</p><p>以下便为设定的阈值</p></li></ol><blockquote><p><img src="http://www.tensorflownews.com/wp-content/uploads/2018/07/15.png" alt></p><p> 从而继续分裂，形成一棵树，再形成一棵树，每次在上一次的预测基础上取最优进一步分裂/建树，是不是贪心策略？</p></blockquote><p> 凡是这种循环迭代的方式必定有停止条件，什么时候停止呢？简言之，设置树的最大深度、当样本权重和小于设定阈值时停止生长以防止过拟合。具体而言，则</p><ol><li>当引入的分裂带来的增益小于设定阀值的时候，我们可以忽略掉这个分裂，所以并不是每一次分裂loss function整体都会增加的，有点预剪枝的意思，阈值参数为<img src="https://img-blog.csdn.net/20180805130912894?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfSlVMWV92/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>（即正则项里叶子节点数T的系数）；  </li><li>当树达到最大深度时则停止建立决策树，设置一个超参数max_depth，避免树太深导致学习局部样本，从而过拟合；  </li><li>当样本权重和小于设定阈值时则停止建树。什么意思呢，即涉及到一个超参数-最小的样本权重和min_child_weight，和GBM的 min_child_leaf 参数类似，但不完全一样。大意就是一个叶子节点样本太少了，也终止同样是防止过拟合；  </li><li>貌似看到过有树的最大数量的… </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分内容转载于&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/81410574&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/v_JULY_v/article/details/81410574&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手推GBDT和常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/08/gbdt/"/>
    <id>http://www.cygao.xyz/2019/09/08/gbdt/</id>
    <published>2019-09-08T09:48:01.000Z</published>
    <updated>2019-09-09T11:45:05.373Z</updated>
    
    <content type="html"><![CDATA[<p>主要是手推算法。<br><a id="more"></a></p><h2 id="手推GBDT"><a href="#手推GBDT" class="headerlink" title="手推GBDT"></a>手推GBDT</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/gbdt.jpg" alt></div> <h2 id="GBDT中的CART回归树每个叶子结点的输出值是什么"><a href="#GBDT中的CART回归树每个叶子结点的输出值是什么" class="headerlink" title="GBDT中的CART回归树每个叶子结点的输出值是什么"></a>GBDT中的CART回归树每个叶子结点的输出值是什么</h2><ol><li>对于分类树，其输出变量的众数就是分类结果。</li><li>对于回归树，其输出变量的平均值就是预测结果。​</li></ol><h2 id="GDBT的GB是什么意思，如何体现？"><a href="#GDBT的GB是什么意思，如何体现？" class="headerlink" title="GDBT的GB是什么意思，如何体现？"></a>GDBT的GB是什么意思，如何体现？</h2><p><strong>Gradient Boosting</strong><br>Boosting是一种可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴，</p><p>Gradient Boosting是一种实现Boosting的方法，它的主要思想是，每一次建立模型，是在之前建立模型损失函数的梯度下降方向。损失函数描述的是模型的不靠谱程度，损失函数越大，说明模型越容易出错。如果我们的模型能够让损失函数持续的下降，说明我们的模型在不停的改进，而最好的方式就是让损失函数在其梯度的方向下降。</p><h2 id="介绍一下GBDT的原理和推导"><a href="#介绍一下GBDT的原理和推导" class="headerlink" title="介绍一下GBDT的原理和推导"></a>介绍一下GBDT的原理和推导</h2><p>见手推GBDT</p><h2 id="GBDT是回归树还是分类树"><a href="#GBDT是回归树还是分类树" class="headerlink" title="GBDT是回归树还是分类树"></a>GBDT是回归树还是分类树</h2><p>CART决策树既可以用于分类也可以用于回归，决策树分为分类树和回归树，分类树的衡量标准是最大熵，回归树的衡量标准是最小化均方差，所以<strong>GBDT中的树都是回归树，不是分类树</strong>.<br><strong>回归树！！！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是手推算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>手推LR（Logistic Regression）逻辑斯蒂回归及常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/08/lr/"/>
    <id>http://www.cygao.xyz/2019/09/08/lr/</id>
    <published>2019-09-08T03:11:48.000Z</published>
    <updated>2019-09-08T03:43:33.283Z</updated>
    
    <content type="html"><![CDATA[<p>概念，公式推导，常见问题。</p><a id="more"></a><h2 id="1、逻辑斯蒂回归的概念"><a href="#1、逻辑斯蒂回归的概念" class="headerlink" title="1、逻辑斯蒂回归的概念"></a>1、逻辑斯蒂回归的概念</h2><p>算法的名字叫做逻辑斯蒂回归（我也不知道为什么这么翻译）但其实它是一种分类模型，一定不能把它和线性回归混为一谈。简单说一下分类和回归之间的区别：</p><ul><li>分类：给定一个数据，根据给出的训练集训练模型并推断出它所对应的类别（+1，-1），是一种定性的输出，也叫作离散变量预测。</li><li>回归：给定一个数据，根据给出的训练集训练模型并推断出该数据下的输出值是多少，此时输出的是一个真实的数值，是一种定量的输出，也叫作连续变量预测。</li></ul><h3 id="具体概念"><a href="#具体概念" class="headerlink" title="具体概念"></a>具体概念</h3><p>LR模型其实仅在线性回归的基础上，套用了一个逻辑函数（sigmoid）。逻辑回归是一个非线性的二分类模型，主要是计算在某个样本特征下事件发生的概率，但是他本质上是一个线性回归模型，因为除去sigmoid映射函数外，其他步骤算法都是线性回归的。</p><h2 id="2、手推LR"><a href="#2、手推LR" class="headerlink" title="2、手推LR"></a>2、手推LR</h2><p>图片转载自 <a href="https://blog.csdn.net/SweetSeven_/article/details/94620627" target="_blank" rel="noopener">https://blog.csdn.net/SweetSeven_/article/details/94620627</a></p><div align="center"><br><img width="700" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/lr1.png"><br></div> <h2 id="3、LR怎么加入非线性"><a href="#3、LR怎么加入非线性" class="headerlink" title="3、LR怎么加入非线性"></a>3、LR怎么加入非线性</h2><p>套用了一个逻辑函数（sigmoid），逻辑回归是一个非线性的二分类模型。</p><h2 id="4、LR的LOSS"><a href="#4、LR的LOSS" class="headerlink" title="4、LR的LOSS"></a>4、LR的LOSS</h2><p>上述图片中的J(θ)。</p><h2 id="5、极大似然的概念"><a href="#5、极大似然的概念" class="headerlink" title="5、极大似然的概念"></a>5、极大似然的概念</h2><p>先验概率是<strong>知因求果</strong>，后验概率是<strong>知果求因</strong>，极大似然是<strong>知果求最可能的原因</strong>,就是在参数θ的可能取值范围内，选取使L(θ)达到最大的参数值θ，作为参数θ的估计值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概念，公式推导，常见问题。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="检测算法" scheme="http://www.cygao.xyz/tags/%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>手推SVM及常见面试问题</title>
    <link href="http://www.cygao.xyz/2019/09/07/svm/"/>
    <id>http://www.cygao.xyz/2019/09/07/svm/</id>
    <published>2019-09-07T11:45:39.000Z</published>
    <updated>2019-09-07T13:07:13.062Z</updated>
    
    <content type="html"><![CDATA[<p>面试必备<br><a id="more"></a></p><h2 id="1、手推SVM"><a href="#1、手推SVM" class="headerlink" title="1、手推SVM"></a>1、手推SVM</h2><p>差不多这个程度应该够了。</p><div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm1.jpg"></div>  <div align="center"><br><img width="500" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm2.jpg"></div>  <h2 id="2、SVM为什么叫支持向量机"><a href="#2、SVM为什么叫支持向量机" class="headerlink" title="2、SVM为什么叫支持向量机"></a>2、SVM为什么叫支持向量机</h2><p>这个名字是强调了此类学习器的关键是如何从支持向量构建出解；同时也暗示了其复杂度主要与支持向量的数目有关。</p><h2 id="3、SVM的损失函数（求导省略了）"><a href="#3、SVM的损失函数（求导省略了）" class="headerlink" title="3、SVM的损失函数（求导省略了）"></a>3、SVM的损失函数（求导省略了）</h2><div align="center"><br><img width="400" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm4.png"><br></div> <h2 id="4、核函数了解哪些，为什么要用核函数"><a href="#4、核函数了解哪些，为什么要用核函数" class="headerlink" title="4、核函数了解哪些，为什么要用核函数"></a>4、核函数了解哪些，为什么要用核函数</h2><p>当样本在原始空间线性不可分时，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。</p><div align="center"><br><img width="400" src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/svm3.jpg"><br></div> <ol><li><p>线性核，主要用于线性可分的情况，我们可以看到特征空间到输入空间的维度是一样的，其参数少速度快，对于线性可分数据，其分类效果很理想，因此我们通常首先尝试用线性核函数来做分类，看看效果如何，如果不行再换别的。</p></li><li><p>多项式核函数可以实现将低维的输入空间映射到高纬的特征空间，但是多项式核函数的参数多，当多项式的阶数比较高的时候，核矩阵的元素值将趋于无穷大或者无穷小，计算复杂度会大到无法计算。</p></li><li><p>高斯（RBF）核函数 是一种局部性强的核函数，其可以将一个样本映射到一个更高维的空间内，该核函数是应用最广的一个，无论大样本还是小样本都有比较好的性能，而且其相对于多项式核函数参数要少，因此大多数情况下在不知道用什么核函数的时候，优先使用高斯核函数。</p></li><li><p>采用sigmoid核函数，支持向量机实现的就是一种多层神经网络。<br>因此，在选用核函数的时候，如果我们对我们的数据有一定的先验知识，就利用先验来选择符合数据分布的核函数；如果不知道的话，通常使用交叉验证的方法，来试用不同的核函数，误差最下的即为效果最好的核函数，或者也可以将多个核函数结合起来，形成混合核函数。在吴恩达的课上，也曾经给出过一系列的选择核函数的方法.</p></li></ol><p><strong><em>如果特征的数量大到和样本数量差不多，则选用LR或者线性核的SVM；<br>如果特征的数量小，样本的数量正常，则选用SVM+高斯核函数；<br>如果特征的数量小，而样本的数量很大，则需要手工添加一些特征从而变成第一种情况。</em></strong></p><h2 id="5、为什么要将求解SVM的原始问题转换为其对偶问题？"><a href="#5、为什么要将求解SVM的原始问题转换为其对偶问题？" class="headerlink" title="5、为什么要将求解SVM的原始问题转换为其对偶问题？"></a>5、为什么要将求解SVM的原始问题转换为其对偶问题？</h2><ol><li>是对偶问题往往更易求解（当我们寻找约束存在时的最优点的时候，约束的存在虽然减小了需要搜寻的范围，但是却使问题变得更加复杂。为了使问题变得易于处理，<strong>把目标函数和约束全部融入一个新的函数，即拉格朗日函数，再通过这个函数来寻找最优点。</strong>）</li><li>自然引入核函数，进而推广到非线性分类问题。</li></ol><h2 id="6、SVM为什么可以处理非线性问题"><a href="#6、SVM为什么可以处理非线性问题" class="headerlink" title="6、SVM为什么可以处理非线性问题"></a>6、SVM为什么可以处理非线性问题</h2><p>非线性的话通过核函数将其隐射到高维空间，在高维空间非线性问题转化为线性问题。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>周志华的<br>《机器学习》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试必备&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>K-means原理及常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/06/kmeans/"/>
    <id>http://www.cygao.xyz/2019/09/06/kmeans/</id>
    <published>2019-09-06T00:33:55.000Z</published>
    <updated>2019-09-06T00:49:46.113Z</updated>
    
    <content type="html"><![CDATA[<p>主要关注伪代码，k怎么选择，初始点怎么选择，原理及优缺点。</p><a id="more"></a><h2 id="原理和流程"><a href="#原理和流程" class="headerlink" title="原理和流程"></a>原理和流程</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p> 对给定的<strong>无标记</strong>的样本数据集，事先确定<strong>聚类簇数K</strong>，让簇内的样本尽可能紧密分布在一起，使簇间的距离尽可能大。K-Means作为无监督的聚类算法，其类似于全自动分类，簇内越相似，聚类效果越好，实现较简单，聚类效果好，因此被广泛使用。用以下的效果图更能直观地看出其过程：<br> <img src="https://img-blog.csdnimg.cn/20190815155230514.gif" alt></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>随即确定K个初始点作为质心（这里如何确定k将在下面给出解释）  </li><li>将数据集中的每个点分配到一个簇中，即为每个点找距离其最近的质心，并将其分配给之心所对应的簇  </li><li>簇分好后，计算每个簇所有点的平均值，将平均值作为对应簇新的质心  </li><li><p>循环2、3步骤，直到质心不变</p><p><strong>伪代码是：</strong></p></li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建k个点作为起始质心（经常是随机选择）</span><br><span class="line">当任意一个点的簇分配结果发生改变时</span><br><span class="line">对数据集中的每个数据点</span><br><span class="line">对每个质心</span><br><span class="line">计算质心和数据点之间的距离</span><br><span class="line">将数据点分配到距离其最近的簇</span><br><span class="line">对每一个簇，计算簇中所有点的均值并将均值作为质心</span><br></pre></td></tr></table></figure><p> 上面“最近”质心，意味着需要进行<strong>某种距离</strong>的计算，即下文要介绍的K-means中常用的到中心距离的度量有哪些？</p><h2 id="K-means中常用的到中心距离的度量"><a href="#K-means中常用的到中心距离的度量" class="headerlink" title="K-means中常用的到中心距离的度量"></a>K-means中常用的到中心距离的度量</h2><p> 这里最常用的有以下两种</p><p> <strong>1、曼哈顿距离</strong><br> <img src="https://img-blog.csdnimg.cn/20190815155442301.png" alt><br> <strong>2、欧几里得距离</strong>（别称“欧式距离”）<br> <img src="https://img-blog.csdnimg.cn/2019081515485016.png" alt></p><h2 id="K-means中的k值如何选取-了解一下"><a href="#K-means中的k值如何选取-了解一下" class="headerlink" title="K-means中的k值如何选取(了解一下)"></a>K-means中的k值如何选取(了解一下)</h2><ul><li>手肘法</li><li>轮廓系数法</li></ul><h2 id="面试常见问题回答"><a href="#面试常见问题回答" class="headerlink" title="面试常见问题回答"></a>面试常见问题回答</h2><h3 id="1、K-means算法中初始点的选择对最终结果有影响吗？"><a href="#1、K-means算法中初始点的选择对最终结果有影响吗？" class="headerlink" title="1、K-means算法中初始点的选择对最终结果有影响吗？"></a>1、K-means算法中初始点的选择对最终结果有影响吗？</h3><p> 会有影响的，不同的初始值结果可能不一样</p><h3 id="2、K-means聚类中每个类别中心的初始点如何选择？"><a href="#2、K-means聚类中每个类别中心的初始点如何选择？" class="headerlink" title="2、K-means聚类中每个类别中心的初始点如何选择？"></a>2、K-means聚类中每个类别中心的初始点如何选择？</h3><p> （1）这k个点的距离尽可能远  </p><p> （2）可以对数据先进行<strong>层次聚类</strong>，得到K个簇之后，从每个类簇中选择一个点，该点可以是该类簇的中心点，或者是距离类簇中心点最近的那个点。</p><h3 id="3、K-means中空聚类的处理"><a href="#3、K-means中空聚类的处理" class="headerlink" title="3、K-means中空聚类的处理"></a>3、K-means中空聚类的处理</h3><p>（1）选择一个距离当前任何质心最远的点。这将消除当前对总平方误差影响最大的点。<br> （2）从具有最大SSE的簇中选择一个替补的质心，这将分裂簇并降低聚类的总SSE。如果有多个空簇，则该过程重复多次。<br> （3）如果噪点或者孤立点过多，考虑更换算法，如<strong>密度聚类</strong>。</p><h3 id="4、K-means是否会一直陷入选择质心的循环停不下来？-（1）迭代次数设置"><a href="#4、K-means是否会一直陷入选择质心的循环停不下来？-（1）迭代次数设置" class="headerlink" title="4、K-means是否会一直陷入选择质心的循环停不下来？ （1）迭代次数设置"></a>4、K-means是否会一直陷入选择质心的循环停不下来？ （1）迭代次数设置</h3><p> （2）设定收敛判断距离</p><h3 id="5、如何快速收敛数据量超大的K-means？-相关解释可以去这个博客稍做了解"><a href="#5、如何快速收敛数据量超大的K-means？-相关解释可以去这个博客稍做了解" class="headerlink" title="5、如何快速收敛数据量超大的K-means？ 相关解释可以去这个博客稍做了解"></a>5、如何快速收敛数据量超大的K-means？ 相关解释可以去这个博客稍做了解</h3><p> <a href="https://blog.csdn.net/sunnyxidian/article/details/89630815" target="_blank" rel="noopener">https://blog.csdn.net/sunnyxidian/article/details/89630815</a></p><h3 id="6、K-means算法的优点和缺点是什么？-K-Means的主要优点："><a href="#6、K-means算法的优点和缺点是什么？-K-Means的主要优点：" class="headerlink" title="6、K-means算法的优点和缺点是什么？ K-Means的主要优点："></a>6、K-means算法的优点和缺点是什么？ K-Means的<strong>主要优点</strong>：</h3><p> （1）原理简单，容易实现<br> （2）可解释度较强</p><h3 id="7、-K-Means的主要缺点："><a href="#7、-K-Means的主要缺点：" class="headerlink" title="7、 K-Means的主要缺点："></a>7、 K-Means的<strong>主要缺点</strong>：</h3><p> （1）K值很难确定<br> （2）局部最优<br> （3）对噪音和异常点敏感<br> （4）需样本存在均值（限定数据种类）<br> （5）聚类效果依赖于聚类中心的初始化<br> （6）对于非凸数据集或类别规模差异太大的数据效果不好</p><hr><p>参考 <a href="https://blog.csdn.net/WangZixuan1111/article/details/98970139" target="_blank" rel="noopener">https://blog.csdn.net/WangZixuan1111/article/details/98970139</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要关注伪代码，k怎么选择，初始点怎么选择，原理及优缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="聚类算法" scheme="http://www.cygao.xyz/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>L1正则&amp;L2正则常见问题</title>
    <link href="http://www.cygao.xyz/2019/09/05/l1l2/"/>
    <id>http://www.cygao.xyz/2019/09/05/l1l2/</id>
    <published>2019-09-05T13:01:50.000Z</published>
    <updated>2019-09-05T13:23:22.929Z</updated>
    
    <content type="html"><![CDATA[<p>L1正则&amp;L2正则常考题目及解答。<br><a id="more"></a></p><ol><li>过拟合的解决方式有哪些，l1和l2正则化都有哪些不同，各自有什么优缺点(爱奇艺)</li><li>L1和L2正则化来避免过拟合是大家都知道的事情，而且我们都知道L1正则化可以得到稀疏解，L2正则化可以得到平滑解，这是为什么呢？</li><li>L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。（美团）</li><li>L1和L2的区别，以及各自的使用场景（头条）</li></ol><h2 id="什么是L1正则-amp-L2正则？"><a href="#什么是L1正则-amp-L2正则？" class="headerlink" title="什么是L1正则&amp;L2正则？"></a>什么是L1正则&amp;L2正则？</h2><p>L1正则即将参数的绝对值之和加入到损失函数中，以二元线性回归为例，损失函数变为：</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l11.png" alt></div><br>L2正则即将参数的平方之和加入到损失函数中，以二元线性回归为例，损失函数变为：<br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l12.png" alt></div> <h2 id="L1正则-amp-L2正则的区别是什么？"><a href="#L1正则-amp-L2正则的区别是什么？" class="headerlink" title="L1正则&amp;L2正则的区别是什么？"></a>L1正则&amp;L2正则的区别是什么？</h2><ol><li>L1正则化是指在损失函数中加入权值向量w的绝对值之和，即各个元素的绝对值之和，L2正则化指在损失函数中加入权值向量w的平方和。</li><li>L1的功能是使权重稀疏，而L2的功能是使权重平滑。</li></ol><h2 id="L1正则为什么可以得到稀疏解？"><a href="#L1正则为什么可以得到稀疏解？" class="headerlink" title="L1正则为什么可以得到稀疏解？"></a>L1正则为什么可以得到稀疏解？</h2><h3 id="解空间形状"><a href="#解空间形状" class="headerlink" title="解空间形状"></a>解空间形状</h3><p>L2正则化相当于为参数定义了一个圆形的解空间，而L1正则化相当于为参数定义了一个菱形的解空间。L1“棱角分明”的解空间显然更容易与目标函数等高线在脚点碰撞。从而产生稀疏解。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/l13.jpg" alt></div> <p>其中变量 w 是动态参数，如果我们调节 w 就会得到一系列的圆，这也是你在上图中看到这么多圆线的原因，上图中其实假设了 w 参数只有二维，这样方便在图中表示，与此同时 L 的图像是一个旋转 90 度的矩形，图像中二者交点的位置就是可能出现最优解的地方，你会发现二者相交出现极大可能的位置就是顶点处，矩形顶点的地方肯定是由其中一个 w 为 0 的，w 为 0 则表示其中一个特征并不是我们需要的特征可以忽略不计，这就说明了 L1 会产生稀疏解的原因。</p><h2 id="L2为什么可以解决过拟合"><a href="#L2为什么可以解决过拟合" class="headerlink" title="L2为什么可以解决过拟合"></a>L2为什么可以解决过拟合</h2><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数 w 都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。若某个 w 参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果 w 参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。L2正则化就是可以使权重平滑。</p><h2 id="L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验"><a href="#L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验" class="headerlink" title="L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验"></a>L1正则化相当于对模型参数w引入了拉普拉斯先验，L2正则化相当于引入了高斯先验</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;L1正则&amp;amp;L2正则常考题目及解答。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简单粗暴的BP图示及公式,CNN的BP及权值共享</title>
    <link href="http://www.cygao.xyz/2019/09/05/bp/"/>
    <id>http://www.cygao.xyz/2019/09/05/bp/</id>
    <published>2019-09-05T12:20:06.000Z</published>
    <updated>2019-09-09T12:14:50.074Z</updated>
    
    <content type="html"><![CDATA[<p>权值共享:同一层的每个感受野被卷积时，卷积参数都是相同的。<br>来源是Introduction to Deep Learning MIT 6.S191；<a href="https://blog.csdn.net/login_sonata/article/details/77488383" target="_blank" rel="noopener">https://blog.csdn.net/login_sonata/article/details/77488383</a>   </p><a id="more"></a><h2 id="BP"><a href="#BP" class="headerlink" title="BP"></a>BP</h2><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp1.png" alt></div> <div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp2.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp3.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp4.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp5.png" alt></div><br><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/bp6.png" alt></div> <h1 id="卷积神经网络的反向传播："><a href="#卷积神经网络的反向传播：" class="headerlink" title="卷积神经网络的反向传播："></a>卷积神经网络的反向传播：</h1><p> 首先回顾一下一般的前馈神经网络的反向传播：<br> <img src="https://img-blog.csdn.net/20170824170432450" alt="这里写图片描述"><br> 详细内容可参看：<a href="http://blog.csdn.net/login_sonata/article/details/76737482" target="_blank" rel="noopener">神经网络基础和反向传播推导</a></p><h2 id="1，CNN的前向传播"><a href="#1，CNN的前向传播" class="headerlink" title="1，CNN的前向传播"></a>1，CNN的前向传播</h2><p> a）对于卷积层，卷积核与输入矩阵对应位置求积再求和，作为输出矩阵对应位置的值。如果输入矩阵inputX为M<em>N大小，卷积核为a</em>b大小，那么输出Y为（M-a+1）*（N-b+1）大小。<br> <img src="https://img-blog.csdn.net/20170824180524581" alt="这里写图片描述"><br> b）对于池化层，按照池化标准把输入张量缩小。<br> c）对于全连接层，按照普通网络的前向传播计算。</p><h2 id="2，CNN反向传播的不同之处："><a href="#2，CNN反向传播的不同之处：" class="headerlink" title="2，CNN反向传播的不同之处："></a>2，CNN反向传播的不同之处：</h2><p> 首先要注意的是，一般神经网络中每一层输入输出a,z都只是一个向量，<strong>而CNN中的a,z是一个三维张量</strong>，即由若干个输入的子矩阵组成。其次：</p><ol start="2"><li><strong>池化层没有激活函数</strong>。这个问题倒比较好解决，我们可以令池化层的激活函数为σ(z)=z，即激活后就是自己本身。这样池化层激活函数的导数为1。 </li><li>池化层在前向传播的时候，对输入进行了压缩，那么我们向前反向推导上一层的误差时，<strong>需要做upsample处理</strong>。 </li><li>卷积层是通过张量卷积，或者说<strong>若干个矩阵卷积求和而得到当前层的输出</strong>，这和一般的网络直接进行矩阵乘法得到当前层的输出不同。这样在卷积层反向传播的时候，上一层误差的递推计算方法肯定有所不同。 </li><li>对于卷积层，由于W使用的运算是卷积，那么由该层误差推导出该层的所有卷积核的W,b的方式也不同。  由于卷积层可以有多个卷积核，各个卷积核的处理方法是完全相同且独立的，为了简化算法公式的复杂度，我们下面提到卷积核都是卷积层中若干卷积核中的一个。接下来看具体的CNN反向传播步骤。</li></ol><h2 id="3，已知池化层的误差，反向推导上一隐藏层的误差"><a href="#3，已知池化层的误差，反向推导上一隐藏层的误差" class="headerlink" title="3，已知池化层的误差，反向推导上一隐藏层的误差"></a>3，已知池化层的误差，反向推导上一隐藏层的误差</h2><p> 在前向传播时，池化层我们会用MAX或者Average对输入进行池化，池化的区域大小已知。现在我们反过来，要从缩小后区域的误差，还原前一层较大区域的误差。这个过程叫做upsample。假设我们的池化区域大小是2x2。第l层误差的第k个子矩阵δlk为:<br> <img src="https://img-blog.csdn.net/20170824182603912" alt="这里写图片描述"><br> 如果池化区域表示为a*a大小，那么我们把上述矩阵上下左右各扩展a-1行和列进行<strong>还原</strong>：<br> <img src="https://img-blog.csdn.net/20170824181456863" alt="这里写图片描述"><br> 如果是MAX，假设我们之前在前向传播时记录的最大值位置分别是左上，右下，右上，左下，则转换后的矩阵为：<br> <img src="https://img-blog.csdn.net/20170824183635544" alt="这里写图片描述"><br> 如果是Average，则进行平均，转换后的矩阵为：<br> <img src="https://img-blog.csdn.net/20170824183714077" alt="这里写图片描述"><br> 上边这个矩阵就是误差矩阵经过upsample之后的矩阵，那么，由后一层误差推导出前一层误差的公式为：<br> <img src="https://img-blog.csdn.net/20170826144238437" alt="这里写图片描述"><br> 上式和普通网络的反向推导误差很类似：<br> <img src="https://img-blog.csdn.net/20170826145756406" alt="这里写图片描述"><br> 可以看到，只有第一项不同。</p><h2 id="4，已知卷积层的误差，反向推导上一隐藏层的误差"><a href="#4，已知卷积层的误差，反向推导上一隐藏层的误差" class="headerlink" title="4，已知卷积层的误差，反向推导上一隐藏层的误差"></a>4，已知卷积层的误差，反向推导上一隐藏层的误差</h2><p> 公式如下：<br> <img src="https://img-blog.csdn.net/20170826150333441" alt="这里写图片描述"><br> 我们再看一次普通网络的反向推导误差的公式：<br> <img src="https://img-blog.csdn.net/20170826145756406" alt="这里写图片描述"><br> 可以看到区别在于，下一层的权重w的转置操作，变成了旋转180度的操作，也就是上下翻转一次，左右再翻转一次，这其实就是“卷积”一词的意义（我们可简单理解为数学上的trick），可参考下图，Q是下一层的误差，周围补0方便计算，W是180度翻转后的卷积核，P是W和Q做卷积的结果：<br> <img src="https://img-blog.csdn.net/20170826151721741" alt="这里写图片描述"></p><h2 id="5，已知卷积层的误差，推导该层的W-b的梯度"><a href="#5，已知卷积层的误差，推导该层的W-b的梯度" class="headerlink" title="5，已知卷积层的误差，推导该层的W,b的梯度"></a>5，已知卷积层的误差，推导该层的W,b的梯度</h2><p> 经过以上各步骤，我们已经算出每一层的误差了，那么：<br> a）对于全连接层，可以按照普通网络的反向传播算法求该层W,b的梯度。<br> b）对于池化层，它并没有W,b,也不用求W,b的梯度。<br> c）只有卷积层的W,b需要求出，先看w：<br> <img src="https://img-blog.csdn.net/20170826154408701" alt="这里写图片描述"><br> 再对比一下普通网络的求w梯度的公式，发现区别在于，对前一层的输出做翻转180度的操作：<br> <img src="https://img-blog.csdn.net/20170826154512559" alt="这里写图片描述"><br> 而对于b,则稍微有些特殊，因为在CNN中，误差δ是三维张量，而b只是一个向量，不能像普通网络中那样直接和误差δ相等。通常的做法是将误差δ的各个子矩阵的项分别求和，得到一个误差向量，即为b的梯度：<br> <img src="https://img-blog.csdn.net/20170826155032222" alt="这里写图片描述"> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权值共享:同一层的每个感受野被卷积时，卷积参数都是相同的。&lt;br&gt;来源是Introduction to Deep Learning MIT 6.S191；&lt;a href=&quot;https://blog.csdn.net/login_sonata/article/details/77488383&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/login_sonata/article/details/77488383&lt;/a&gt;   &lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://www.cygao.xyz/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="深度学习" scheme="http://www.cygao.xyz/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>主成分分析PCA原理和执行步骤</title>
    <link href="http://www.cygao.xyz/2019/09/05/pca/"/>
    <id>http://www.cygao.xyz/2019/09/05/pca/</id>
    <published>2019-09-05T02:27:21.000Z</published>
    <updated>2019-09-05T11:41:04.569Z</updated>
    
    <content type="html"><![CDATA[<p>主成分分析（PCA）特征选择算法简介，包含适用场景。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PCA全称Principal Component Analysis，即主成分分析，是一种常用的数据降维方法。它可以通过<strong>线性变换</strong>将原始数据变换为一组各维度<strong>线性无关</strong>的表示，以此来提取数据的<strong>主要线性分量</strong>。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>我们在处理实际问题的时候，进行特征提取过程中，提取的特征维数太多经常会导致特征匹配时过于复杂，消耗计算资源。</p><hr><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><hr><ol><li>线性变换=&gt;新特征轴可由原始特征轴线性变换表征</li><li>线性无关=&gt;构建的特征轴是正交的</li><li>主要线性分量（或者说是主成分）=&gt;方差加大的方向</li><li>PCA算法的求解就是找到主要线性分量及其表征方式的过程</li></ol><hr><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>假设有m个样例，n维特征</p><ol><li>对每一维特征进行零均值化，即减去均值</li><li>再求特征协方差矩阵</li><li>求改协方差矩阵的特征值和特征向量</li><li>将特征值按照从大到小的顺序排序，并选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</li><li>将样本点投影到选取的特征向量上，假设有m个样例，n维特征，零均值化后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为:</li></ol><div align="center"><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/pca.png" alt></div> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主成分分析（PCA）特征选择算法简介，包含适用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>NMS算法（NonMaximumSuppression）</title>
    <link href="http://www.cygao.xyz/2019/09/05/nms/"/>
    <id>http://www.cygao.xyz/2019/09/05/nms/</id>
    <published>2019-09-05T01:58:02.000Z</published>
    <updated>2019-09-05T12:34:12.670Z</updated>
    
    <content type="html"><![CDATA[<p>NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。</p><a id="more"></a><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><hr><p>非极大值抑制（NMS）顾名思义就是抑制不是极大值的元素，搜索局部的极大值。这个局部代表的是一个邻域，邻域有两个参数可变，一是邻域的维数，二是邻域的大小。这里不讨论通用的NMS算法，而是用于在目标检测中用于提取分数最高的窗口的。<br>例如在行人检测中，滑动窗口经提取特征，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si ,  1&lt;=i&lt;=N。</p><ol><li><p>建造一个存放待处理候选框的集合H，初始化为包含全部N个框；建造一个存放最优框的集合M，初始化为空集。</p></li><li><p>将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；</p></li><li><p>遍历集合 H 中的框，分别与框m计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m重叠，将此框从集合 H 中去除。</p></li><li><p>回到第2步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p></li></ol><h3 id="需要优化的参数"><a href="#需要优化的参数" class="headerlink" title="需要优化的参数"></a>需要优化的参数</h3><p>IoU 的阈值是一个可优化的参数，一般范围为0~0.5，可以使用交叉验证来选择最优的参数。</p><hr><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">py_cpu_nms</span><span class="hljs-params">(dets, thresh)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""Pure Python NMS baseline."""</span></span><br><span class="line">    <span class="hljs-comment">#x1、y1、x2、y2、以及score赋值</span></span><br><span class="line">    x1 = dets[:, <span class="hljs-number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="hljs-number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="hljs-number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="hljs-number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="hljs-number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">#每一个检测框的面积</span></span><br><span class="line">    areas = (x2 - x1 + <span class="hljs-number">1</span>) * (y2 - y1 + <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-comment">#按照score置信度降序排序</span></span><br><span class="line">    order = scores.argsort()[::<span class="hljs-number">-1</span>]</span><br><span class="line"></span><br><span class="line">    keep = [] <span class="hljs-comment">#保留的结果框集合</span></span><br><span class="line">    <span class="hljs-keyword">while</span> order.size &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        i = order[<span class="hljs-number">0</span>]</span><br><span class="line">        keep.append(i) <span class="hljs-comment">#保留该类剩余box中得分最高的一个</span></span><br><span class="line">        <span class="hljs-comment">#得到相交区域,左上及右下</span></span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="hljs-number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="hljs-number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#计算相交的面积,不重叠时面积为0</span></span><br><span class="line">        w = np.maximum(<span class="hljs-number">0.0</span>, xx2 - xx1 + <span class="hljs-number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="hljs-number">0.0</span>, yy2 - yy1 + <span class="hljs-number">1</span>)</span><br><span class="line">        inter = w * h</span><br><span class="line">        <span class="hljs-comment">#计算IoU：重叠面积 /（面积1+面积2-重叠面积）</span></span><br><span class="line">        ovr = inter / (areas[i] + areas[order[<span class="hljs-number">1</span>:]] - inter)</span><br><span class="line">        <span class="hljs-comment">#保留IoU小于阈值的box</span></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="hljs-number">0</span>]</span><br><span class="line">        order = order[inds + <span class="hljs-number">1</span>] <span class="hljs-comment">#因为ovr数组的长度比order数组少一个,所以这里要将所有下标后移一位</span></span><br><span class="line">       </span><br><span class="line">    <span class="hljs-keyword">return</span> keep</span><br><span class="line">`</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NMS算法原理及其python代码实现,其中也包含了IOU交并比的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="http://www.cygao.xyz/categories/interview/"/>
    
    
      <category term="机器学习" scheme="http://www.cygao.xyz/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="检测算法" scheme="http://www.cygao.xyz/tags/%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法面试通关40讲总结</title>
    <link href="http://www.cygao.xyz/2019/08/22/algorithm40/"/>
    <id>http://www.cygao.xyz/2019/08/22/algorithm40/</id>
    <published>2019-08-22T02:43:23.000Z</published>
    <updated>2019-09-02T01:53:04.951Z</updated>
    
    <content type="html"><![CDATA[<p>知识图谱的形式总结极客时间的算法面试通关40讲课程<br><a id="more"></a></p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/algorithm.jpg" alt></div> <div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/algorithm2.jpg" alt></div> <p>转载自链接：<a href="https://blog.csdn.net/xushuanglu_csdn/article/details/87165984" target="_blank" rel="noopener">https://blog.csdn.net/xushuanglu_csdn/article/details/87165984</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知识图谱的形式总结极客时间的算法面试通关40讲课程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="基本算法" scheme="http://www.cygao.xyz/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【python】冒泡，选择，插入，希尔，快速，归并排序的实现及图解</title>
    <link href="http://www.cygao.xyz/2019/08/13/sort/"/>
    <id>http://www.cygao.xyz/2019/08/13/sort/</id>
    <published>2019-08-13T04:54:16.000Z</published>
    <updated>2019-09-02T01:52:52.105Z</updated>
    
    <content type="html"><![CDATA[<p>总结基本的排序算法。<br><a id="more"></a></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>冒泡排序</strong>（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了<strong>最后一个</strong>。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  </li></ul><p>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示： </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort1.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>):</span><br><span class="line">        count = <span class="hljs-number">0</span>  <span class="hljs-comment">#利用count进行优化，如果中间有一次不交换了，则证明已经排序完毕</span></span><br><span class="line">        <span class="hljs-comment"># j表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>-j):</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[i] &gt; alist[i+<span class="hljs-number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="hljs-number">1</span>] = alist[i+<span class="hljs-number">1</span>], alist[i]</span><br><span class="line">                count+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）需要加上count进行判断。</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定<h2 id="冒泡排序的演示"><a href="#冒泡排序的演示" class="headerlink" title="冒泡排序的演示"></a>冒泡排序的演示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort2.gif" alt></div> </li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="hljs-comment"># 需要进行n-1次选择操作</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>):</span><br><span class="line">        <span class="hljs-comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="hljs-comment"># 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, n):</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="hljs-comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n2)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定（考虑升序每次选择最大的情况）</li></ul><h2 id="选择排序的演示"><a href="#选择排序的演示" class="headerlink" title="选择排序的演示"></a>选择排序的演示</h2><p>红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort3.gif" alt></div> <h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(alist)):</span><br><span class="line">        <span class="hljs-comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        j = i</span><br><span class="line">        <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> alist[j] &lt; alist[j<span class="hljs-number">-1</span>]:</span><br><span class="line">                alist[j], alist[j<span class="hljs-number">-1</span>] = alist[j<span class="hljs-number">-1</span>], alist[j]</span><br><span class="line">                j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）每次都直接break，跳出循环</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定</li></ul><h2 id="插入排序的演示"><a href="#插入排序的演示" class="headerlink" title="插入排序的演示"></a>插入排序的演示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort4.gif" alt></div><br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/sort5.gif" alt></div> <h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>希尔排序</strong>(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><blockquote><p>python2和python3里的整除分别对应 <strong>/</strong> 和 <strong>//</strong>。</p></blockquote><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="hljs-comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-keyword">while</span> gap &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="hljs-comment"># 插入排序</span></span><br><span class="line">            <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> alist[j-gap] &gt; alist[j]:</span><br><span class="line">                    alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                    j -= gap</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><h2 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n2)</li><li>稳定想：不稳定</li></ul><h2 id="希尔排序的图示"><a href="#希尔排序的图示" class="headerlink" title="希尔排序的图示"></a>希尔排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/shellsort.png" alt></div> <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序</strong>（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(alist, start, end)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""快速排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 递归的退出条件</span></span><br><span class="line">    <span class="hljs-keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="hljs-comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="hljs-keyword">while</span> low &lt; high <span class="hljs-keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="hljs-comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low<span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="hljs-number">1</span>, end)</span><br><span class="line"></span><br><span class="line">alist = [<span class="hljs-number">54</span>,<span class="hljs-number">26</span>,<span class="hljs-number">93</span>,<span class="hljs-number">17</span>,<span class="hljs-number">77</span>,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">20</span>]</span><br><span class="line">quick_sort(alist,<span class="hljs-number">0</span>,len(alist)<span class="hljs-number">-1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p><h2 id="快速排序的图示"><a href="#快速排序的图示" class="headerlink" title="快速排序的图示"></a>快速排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/quicksort.jpg" alt></div> <h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>归并排序</strong>是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p><p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(alist)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) &lt;= <span class="hljs-number">1</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> alist</span><br><span class="line">    <span class="hljs-comment"># 二分分解</span></span><br><span class="line">    num = len(alist)/<span class="hljs-number">2</span></span><br><span class="line">    left = merge_sort(alist[:num])</span><br><span class="line">    right = merge_sort(alist[num:])</span><br><span class="line">    <span class="hljs-comment"># 合并</span></span><br><span class="line">    <span class="hljs-keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right)</span>:</span></span><br><span class="line">    <span class="hljs-string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    <span class="hljs-comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="hljs-keyword">while</span> l&lt;len(left) <span class="hljs-keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="hljs-keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="hljs-number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="hljs-keyword">return</span> result</span><br><span class="line"></span><br><span class="line">alist = [<span class="hljs-number">54</span>,<span class="hljs-number">26</span>,<span class="hljs-number">93</span>,<span class="hljs-number">17</span>,<span class="hljs-number">77</span>,<span class="hljs-number">31</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>,<span class="hljs-number">20</span>]</span><br><span class="line">sorted_alist = mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(nlogn)</li><li>稳定性：稳定</li></ul><h2 id="归并排序的图示"><a href="#归并排序的图示" class="headerlink" title="归并排序的图示"></a>归并排序的图示</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/mergesort.gif" alt></div> <h1 id="常见排序算法效率比较"><a href="#常见排序算法效率比较" class="headerlink" title="常见排序算法效率比较"></a>常见排序算法效率比较</h1><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/compare.png" alt></div> <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找</p><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(alist, item)</span>:</span></span><br><span class="line">      first = <span class="hljs-number">0</span></span><br><span class="line">      last = len(alist)<span class="hljs-number">-1</span></span><br><span class="line">      <span class="hljs-keyword">while</span> first&lt;=last:</span><br><span class="line">          midpoint = (first + last)/<span class="hljs-number">2</span></span><br><span class="line">          <span class="hljs-keyword">if</span> alist[midpoint] == item:</span><br><span class="line">              <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">          <span class="hljs-keyword">elif</span> item &lt; alist[midpoint]:</span><br><span class="line">              last = midpoint<span class="hljs-number">-1</span></span><br><span class="line">          <span class="hljs-keyword">else</span>:</span><br><span class="line">              first = midpoint+<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">testlist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">13</span>))</span><br></pre></td></tr></table></figure><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(alist, item)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> len(alist) == <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        midpoint = len(alist)//<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">if</span> alist[midpoint]==item:</span><br><span class="line">          <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">          <span class="hljs-keyword">if</span> item&lt;alist[midpoint]:</span><br><span class="line">            <span class="hljs-keyword">return</span> binary_search(alist[:midpoint],item)</span><br><span class="line">          <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> binary_search(alist[midpoint+<span class="hljs-number">1</span>:],item)</span><br><span class="line"></span><br><span class="line">testlist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="hljs-number">13</span>))</span><br></pre></td></tr></table></figure><h2 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>最优时间复杂度：O(1)</li><li>最坏时间复杂度：O(logn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结基本的排序算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="基本算法" scheme="http://www.cygao.xyz/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【python】 多种链表的实现及python中“=”的解读</title>
    <link href="http://www.cygao.xyz/2019/08/12/linked%20list/"/>
    <id>http://www.cygao.xyz/2019/08/12/linked list/</id>
    <published>2019-08-12T08:54:16.000Z</published>
    <updated>2019-09-02T01:52:29.519Z</updated>
    
    <content type="html"><![CDATA[<p>python中“=”的正确、简单好记的理解以及python链表的实现。<br><a id="more"></a></p><h1 id="python中“-”的理解"><a href="#python中“-”的理解" class="headerlink" title="python中“=”的理解"></a>python中“=”的理解</h1><p>python并不像是c/c++，c++中新建一个变量，比如<code>int a = 3</code>，此时必须申明变量的类型，找一块内存空间存储3，这个内存空间的别名是a，占4个字节且a只能存整数。</p><p>python中并不需要申明类型，<code>a  = 10</code>这种隐式申明的的原因是，a是另外一个内存，保存的是一个地址，地址指向什么就代表a是什么。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def C():</span><br><span class="line">    pass</span><br><span class="line">a = C</span><br></pre></td></tr></table></figure></p><p>a可以重新指向一个方法，类或是对象中的元素都行。所以 <strong>=</strong> 只能代表把指向更改，指向了什么。</p><h1 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleNode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单链表的结点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># _item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="hljs-comment"># _next是下一个节点的标识</span></span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><h1 id="单链表的实现及部分操作"><a href="#单链表的实现及部分操作" class="headerlink" title="单链表的实现及部分操作"></a>单链表的实现及部分操作</h1><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleLinkList</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.__head = <span class="hljs-literal">None</span> </span><br><span class="line">        <span class="hljs-comment">#__双下划线代表私有变量/方法</span></span><br><span class="line">        <span class="hljs-comment">#_但下划线代表保护变量/方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.__head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""链表长度"""</span></span><br><span class="line">        <span class="hljs-comment"># cur初始时指向头节点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 尾节点指向None，当未到达尾部时</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment"># 将cur后移一个节点</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            print(cur.item,end=<span class="hljs-string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line"> ```       </span><br><span class="line"><span class="hljs-comment">## 头部添加元素 </span></span><br><span class="line">```python</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部添加元素"""</span></span><br><span class="line">        <span class="hljs-comment"># 先创建一个保存item值的节点</span></span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        <span class="hljs-comment"># 将新节点的链接域next指向头节点，即_head指向的位置</span></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        <span class="hljs-comment"># 将链表的头_head指向新节点</span></span><br><span class="line">        self.__head = node</span><br></pre></td></tr></table></figure><h2 id="尾部添加元素"><a href="#尾部添加元素" class="headerlink" title="尾部添加元素"></a>尾部添加元素</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""尾部添加元素"""</span></span><br><span class="line">    node = SingleNode(item)</span><br><span class="line">    <span class="hljs-comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">        self.__head = node</span><br><span class="line">    <span class="hljs-comment"># 若不为空，则找到尾部，将尾节点的next指向新节点</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != <span class="hljs-literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br></pre></td></tr></table></figure><h2 id="指定位置添加元素"><a href="#指定位置添加元素" class="headerlink" title="指定位置添加元素"></a>指定位置添加元素</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link1.png" alt></div><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""指定位置添加元素"""</span></span><br><span class="line">    <span class="hljs-comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">    <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">        self.add(item)</span><br><span class="line">    <span class="hljs-comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">        self.append(item)</span><br><span class="line">    <span class="hljs-comment"># 找到指定位置</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">        pre = self.__head</span><br><span class="line">        <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="hljs-comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">        node.next = pre.next</span><br><span class="line">        <span class="hljs-comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">        pre.next = node</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link2.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""删除节点"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    pre = <span class="hljs-literal">None</span></span><br><span class="line">    <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-comment"># 找到了指定元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-comment"># 如果第一个就是删除的节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre:</span><br><span class="line">                <span class="hljs-comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                self.__head = cur.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 继续按链表后移节点</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br></pre></td></tr></table></figure><h2 id="查找节点是否存在"><a href="#查找节点是否存在" class="headerlink" title="查找节点是否存在"></a>查找节点是否存在</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self,item)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""链表查找节点是否存在，并返回True或者False"""</span></span><br><span class="line">    cur = self.__head</span><br><span class="line">    <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><h1 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h1><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。<br>链表与顺序表的各种操作复杂度如下所示：</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link3.png" alt></div> <p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p><h1 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h1><p>单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link4.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""节点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinCycLinkedlist</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""单向循环链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""返回链表的长度"""</span></span><br><span class="line">        <span class="hljs-comment"># 如果链表为空，返回长度0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment">#添加的节点指向_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="hljs-comment"># 移到链表尾部，将尾部节点的next指向node</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment">#_head指向添加node的</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""尾部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 移到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将尾节点指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment"># 将node指向头节点_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""删除一个节点"""</span></span><br><span class="line">        <span class="hljs-comment"># 若链表为空，则直接返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        <span class="hljs-comment"># 将cur指向头节点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 若头节点的元素就是要查找的元素item</span></span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-comment"># 如果链表不止一个节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> cur.next != self._head:</span><br><span class="line">                <span class="hljs-comment"># 先找到尾节点，将尾节点的next指向第二个节点</span></span><br><span class="line">                <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="hljs-comment"># cur指向了尾节点</span></span><br><span class="line">                cur.next = self._head.next</span><br><span class="line">                self._head = self._head.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment"># 链表只有一个节点</span></span><br><span class="line">                self._head = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="hljs-comment"># 第一个节点不是要删除的</span></span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">                <span class="hljs-comment"># 找到了要删除的元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="hljs-comment"># 删除</span></span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="hljs-keyword">return</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># cur 指向尾节点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-comment"># 尾部删除</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""查找节点是否存在"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    ll = SinCycLinkedlist()</span><br><span class="line">    ll.add(<span class="hljs-number">1</span>)</span><br><span class="line">    ll.add(<span class="hljs-number">2</span>)</span><br><span class="line">    ll.append(<span class="hljs-number">3</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">3</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">7</span>)</span><br><span class="line">    ll.remove(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。  </p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/link5.png" alt></div> <figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""双向链表节点"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="hljs-literal">None</span></span><br><span class="line">        self.prev = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkList</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-string">"""双向链表"""</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._head == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""返回链表的长度"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">travel</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""遍历链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">print</span> cur.item,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""头部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="hljs-comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head.prev = node</span><br><span class="line">            <span class="hljs-comment"># 将_head 指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""尾部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment"># 移动到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">while</span> cur.next != <span class="hljs-literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="hljs-comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""查找元素是否存在"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pos &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="hljs-keyword">elif</span> pos &gt; (self.length()<span class="hljs-number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="hljs-keyword">while</span> count &lt; (pos<span class="hljs-number">-1</span>):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line">            <span class="hljs-comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">            node.next = cur.next</span><br><span class="line">            <span class="hljs-comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            <span class="hljs-comment"># 将cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(self, item)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""删除元素"""</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="hljs-comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                <span class="hljs-keyword">if</span> cur.next == <span class="hljs-literal">None</span>:</span><br><span class="line">                    <span class="hljs-comment"># 如果链表只有这一个节点</span></span><br><span class="line">                    self._head = <span class="hljs-literal">None</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                    cur.next.prev = <span class="hljs-literal">None</span></span><br><span class="line">                    <span class="hljs-comment"># 将_head指向第二个节点</span></span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                <span class="hljs-keyword">return</span></span><br><span class="line">            <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="hljs-comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="hljs-comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                cur = cur.next</span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="hljs-number">1</span>)</span><br><span class="line">    ll.add(<span class="hljs-number">2</span>)</span><br><span class="line">    ll.append(<span class="hljs-number">3</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">    ll.insert(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">3</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> ll.search(<span class="hljs-number">4</span>)</span><br><span class="line">    ll.remove(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中“=”的正确、简单好记的理解以及python链表的实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 list的基本实现</title>
    <link href="http://www.cygao.xyz/2019/08/12/list/"/>
    <id>http://www.cygao.xyz/2019/08/12/list/</id>
    <published>2019-08-12T08:26:12.000Z</published>
    <updated>2019-09-02T01:52:33.732Z</updated>
    
    <content type="html"><![CDATA[<p>总结python在list中的原理和实现。<br><a id="more"></a></p><h1 id="python中list的基本实现技术"><a href="#python中list的基本实现技术" class="headerlink" title="python中list的基本实现技术"></a>python中list的基本实现技术</h1><h2 id="元素外置的顺序表"><a href="#元素外置的顺序表" class="headerlink" title="元素外置的顺序表"></a>元素外置的顺序表</h2><p>python中的list可以存放不同类型的数据，比如int，char，float等等，这些数据元素大小不同，所以得用到外置顺序表。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="hljs-number">1</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-number">2.2</span>]</span><br></pre></td></tr></table></figure></p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list1.png" alt></div>  <blockquote><p>Loc(li) = Loc(l0) + c*i </p></blockquote><p>元素的大小不统一，则须采用如图的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。<br>如图这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p><h2 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h2><p>一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list2.png" alt></div><br>python中的list主要采用分离式结构，如图<br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/list3.png" alt></div>  <p>表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。这样在进行扩充的时候，数据的迁移，不用迁徙表头，指针指向的地址改变就行。</p><h2 id="list的数据扩充"><a href="#list的数据扩充" class="headerlink" title="list的数据扩充"></a>list的数据扩充</h2><p>在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结python在list中的原理和实现。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈的应用，括号匹配问题，中缀、后缀表达式</title>
    <link href="http://www.cygao.xyz/2019/08/12/stack/"/>
    <id>http://www.cygao.xyz/2019/08/12/stack/</id>
    <published>2019-08-12T04:54:16.000Z</published>
    <updated>2019-08-29T13:46:32.268Z</updated>
    
    <content type="html"><![CDATA[<p>主要是中缀、后缀表达式的转换。<br><a id="more"></a></p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.符号匹配<br>2.计算机表达式的转换<br>3.CPU内部栈主要是用来进行子程序调用和返回<br>4.进制转换  </p><h3 id="1-括号匹配问题"><a href="#1-括号匹配问题" class="headerlink" title="1.括号匹配问题"></a>1.括号匹配问题</h3><p>大多数计算机语言中都需要检测括号是否匹配，那么如何实现符号成对检测？  </p><p><strong>算法思路</strong>：</p><ul><li>从第一个字符开始扫描</li><li>当遇见普通字符时忽略，</li><li>当遇见左符号时压入栈中</li><li>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</li><li>匹配成功：继续读入下一个字符</li><li>匹配失败：立即停止，并报错</li><li>结束：<br>成功: 所有字符扫描完毕，且栈为空<br>失败：匹配失败或所有字符扫描完毕但栈非空</li></ul><h3 id="2-计算机表达式转换"><a href="#2-计算机表达式转换" class="headerlink" title="2.计算机表达式转换"></a>2.计算机表达式转换</h3><p>计算机的本质工作就是做数学运算，那计算机可以读入字符串<br>“9 + (3 - 1) * 5 + 8 / 2”并计算值吗？</p><p><strong>中缀表达式和后缀表达式</strong><br>后缀表达式（由波兰科学家在20世纪50年代提出）<br>将运算符放在数字后面 ===》 符合计算机运算<br>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯<br>实例<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 =&gt; 5 4 +    </span><br><span class="line">1 + 2 * 3 =&gt; 1 2 3 * +    </span><br><span class="line">8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * +</span><br></pre></td></tr></table></figure></p><p><strong>算法思路</strong><br>中缀转后缀：<br>遍历中缀表达式中的数字和符号</p><ul><li>对于数字：直接输出</li><li>对于符号：  </li></ul><p>（1）左括号：进栈<br>（2）运算符号：与栈顶符号进行优先级比较<br>若栈顶符号优先级低：此符号进栈<br>（默认栈顶若是左括号，左括号优先级最低）<br>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈<br>（3）右括号：将栈顶符号弹出并输出，直到匹配左括号   </p><ul><li>遍历结束：将栈中的所有符号弹出并输出</li></ul><blockquote><p><strong>计算机如何基于后缀表达式结算结果</strong><br>例如：8 3 1 – 5 * +</p></blockquote><ul><li>计算规则：  </li><li>遍历后缀表达式中的数字和符号  </li><li>对于数字：进栈  </li><li>对于符号：<br>（1）从栈中弹出右操作数<br>（2）从栈中弹出左操作数<br>根据符号进行运算<br>将运算结果压入栈中<br>遍历结束：栈中的唯一数字为计算结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是中缀、后缀表达式的转换。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【python】 timeit模块,list及dict操作复杂度</title>
    <link href="http://www.cygao.xyz/2019/08/12/python%20timeit/"/>
    <id>http://www.cygao.xyz/2019/08/12/python timeit/</id>
    <published>2019-08-12T01:01:55.000Z</published>
    <updated>2019-09-02T01:52:40.212Z</updated>
    
    <content type="html"><![CDATA[<p>简单减少一个性能分析的模块timeit，以及利用该模块测试list及dict的一些基本操作。<br><a id="more"></a></p><h1 id="Python内置类型性能分析"><a href="#Python内置类型性能分析" class="headerlink" title="Python内置类型性能分析"></a>Python内置类型性能分析</h1><h2 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h2><p>timeit模块可以用来测试一小段Python代码的执行速度。</p><h3 id="class-timeit-Timer-stmt-’pass’-setup-’pass’-timer"><a href="#class-timeit-Timer-stmt-’pass’-setup-’pass’-timer" class="headerlink" title="class timeit.Timer(stmt=’pass’, setup=’pass’ timer=)"></a>class timeit.Timer(stmt=’pass’, setup=’pass’ timer=<timer function>)</timer></h3><p>Timer是测量小段代码执行速度的类。</p><p>stmt参数是要测试的代码语句（statment）；</p><p>setup参数是运行代码时需要的设置；</p><p>timer参数是一个定时器函数，与平台有关。</p><h3 id="timeit-Timer-timeit-number-1000000"><a href="#timeit-Timer-timeit-number-1000000" class="headerlink" title="timeit.Timer.timeit(number=1000000)"></a>timeit.Timer.timeit(number=1000000)</h3><p>Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p><h2 id="比较list的操作复杂度"><a href="#比较list的操作复杂度" class="headerlink" title="比较list的操作复杂度"></a>比较list的操作复杂度</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):</span><br><span class="line">      l = l + [i] <span class="hljs-comment">#会先创建一个新的列表l + [i]再赋值到新的l上，效率很差。尽量使用l+=[i]，已在python内部优化了。 </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):</span><br><span class="line">      l.append(i)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>)]</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l = list(range(<span class="hljs-number">1000</span>))</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   l =[]</span><br><span class="line">   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):</span><br><span class="line">      l.extend([i]) <span class="hljs-comment"># 类似于 l+=[i]，是直接在列表l上操作</span></span><br><span class="line"><span class="hljs-keyword">from</span> timeit <span class="hljs-keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line">t1 = Timer(<span class="hljs-string">"test1()"</span>, <span class="hljs-string">"from __main__ import test1"</span>)</span><br><span class="line">print(<span class="hljs-string">"concat "</span>,t1.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t2 = Timer(<span class="hljs-string">"test2()"</span>, <span class="hljs-string">"from __main__ import test2"</span>)</span><br><span class="line">print(<span class="hljs-string">"append "</span>,t2.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t3 = Timer(<span class="hljs-string">"test3()"</span>, <span class="hljs-string">"from __main__ import test3"</span>)</span><br><span class="line">print(<span class="hljs-string">"comprehension "</span>,t3.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="hljs-string">"test4()"</span>, <span class="hljs-string">"from __main__ import test4"</span>)</span><br><span class="line">print(<span class="hljs-string">"list range "</span>,t4.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="hljs-string">"test5()"</span>, <span class="hljs-string">"from __main__ import test5"</span>)</span><br><span class="line">print(<span class="hljs-string">"extend "</span>,t5.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line"><span class="hljs-comment"># ('concat ', 1.7890608310699463, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('append ', 0.13796091079711914, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('comprehension ', 0.05671119689941406, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('list range ', 0.014147043228149414, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('extend ', 0.12147043228149414, 'seconds')</span></span><br></pre></td></tr></table></figure><blockquote><p>list range(迭代转化) &lt; comprehension(包含) &lt; extend &lt; append &lt; concat </p></blockquote><h3 id="pop操作比较"><a href="#pop操作比较" class="headerlink" title="pop操作比较"></a>pop操作比较</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="hljs-number">2000000</span>)</span><br><span class="line">pop_zero = Timer(<span class="hljs-string">"x.pop(0)"</span>,<span class="hljs-string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="hljs-string">"pop_zero "</span>,pop_zero.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line">x = range(<span class="hljs-number">2000000</span>)</span><br><span class="line">pop_end = Timer(<span class="hljs-string">"x.pop()"</span>,<span class="hljs-string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="hljs-string">"pop_end "</span>,pop_end.timeit(number=<span class="hljs-number">1000</span>), <span class="hljs-string">"seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># ('pop_zero ', 1.9101738929748535, 'seconds')</span></span><br><span class="line"><span class="hljs-comment"># ('pop_end ', 0.00023603439331054688, 'seconds')</span></span><br></pre></td></tr></table></figure><blockquote><p>测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素</p></blockquote><h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</span><br><span class="line">l1[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] = [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>] <span class="hljs-comment">#可以是任意长度</span></span><br><span class="line">&gt;&gt; l1 = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br></pre></td></tr></table></figure><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/python1.png" alt></div>  <div align="center">!<img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/python2.png" alt></div>  ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单减少一个性能分析的模块timeit，以及利用该模块测试list及dict的一些基本操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.cygao.xyz/categories/python/"/>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>python实现剑指offer1-31题</title>
    <link href="http://www.cygao.xyz/2019/07/25/jian%20offer/"/>
    <id>http://www.cygao.xyz/2019/07/25/jian offer/</id>
    <published>2019-07-25T05:23:45.000Z</published>
    <updated>2019-09-02T02:05:21.970Z</updated>
    
    <content type="html"><![CDATA[<p>详细地分析剑指offer1-31题的解题思路，代码及代码注释。<br><a id="more"></a></p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</strong></p><p>对列的添加       insert              append </p><p>队列的取值      列表[-1]            列表[0]</p><p>队列的删除       pop()            pop(0)</p><hr><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</strong></p><p>只允许在栈的栈顶来操作。</p><p>添加元素用append(push)，称作是进栈，入栈或者压栈</p><p>取值列表[-1]，因为它只能从栈顶来取值，相当于取列表的最后一个值，所以用索引-1.</p><p>删除元素pop()从后端开始删除。称作是出栈或者退栈。</p><hr><h2 id="1-两个栈实现一个队列：-本题考点-队列-栈"><a href="#1-两个栈实现一个队列：-本题考点-队列-栈" class="headerlink" title="1. 两个栈实现一个队列：[^本题考点 队列 栈]"></a>1. 两个栈实现一个队列：[^本题考点 队列 栈]</h2><p><strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</strong></p><p>……解析：</p><p>定义一个类，首先这个类要具备两个属性，一个是压栈，一个是出栈。</p><p>因为要两个栈来实现一个队列：进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p>那么如何用：两个栈实现一个队列？</p><p>栈： 先进后出</p><p>队列：先进先出</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianggezhan.png" alt></p><h4 id="如图所示："><a href="#如图所示：" class="headerlink" title="如图所示："></a>如图所示：</h4><p>队列从一头添加数据，从一头删除数据。</p><p>所以我们需要让两个栈</p><p>一个栈实现添加数据 </p><p>​    即：<code>self.acceptStack=[]</code>它拥有一个<code>push</code>的方法，用来作为队列的一端的添加数据 功能 用append来实现</p><p>​        <code>self.acceptStack.append(node)</code></p><p>另一个栈实现删除数据：</p><p>​    即：<code>self.outputStack = []</code>它拥有pop 的方法，用来作为队列的另一端的删除数据的功能 用pop 来实现</p><p>​    但是我们要实现的是队列的先进先出，也就意味着 如果说我们添加数据的栈中添加了一个数据，那么我们另一个删除数据的栈中，也要相应的删除这个数据，所以说这两个栈中的数据的顺序是相反的。</p><p>以上的需求我们通过，删除<code>acceptStack</code>栈中的数据，在<code>outputStack</code>中添加这个数据，那么先在<code>acceptStack</code>中删除的数据，就会进入到<code>outputStack</code>的栈底，后在<code>acceptStack</code>中删除的数据，会后进入<code>outputStack</code>，那么它就会先出来。</p><p>那么两个栈，这样来合作，就会实现队列的先进先出，如图：1 是先进的（栈1） 那么1 就会先出来（栈2）。</p><p>进而实现了 题目的需求。</p><p>在pop 的方法中，如果说 <code>self.outputStack</code>是空 没有数据，那么 就给它 while 循环我们的 作为添加数据的栈 </p><p><code>acceptStack</code>，删除这个栈中的内容，它会弹出，然后把它添加到 <code>栈2 outputStack</code>  中，它就会有数据，有数据的话就返回 （如果 调用了 删除 数据的这个方法的话）。如果说 做了循环，我们的<code>栈2 outputStack</code> 中还没有数据，就明 <code>acceptStack</code>中，没有数据压入，也就说明这个 队列 没有添加数据，也就不会有删除的数据，所以返回一个None。</p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#添加数据栈</span></span><br><span class="line">        self.acceptStack=[]</span><br><span class="line">        <span class="hljs-comment">#删除数据栈</span></span><br><span class="line">        self.outputStack = []</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#向添加数据的栈中添加数据</span></span><br><span class="line">        self.acceptStack.append(node)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#判断删除数据的栈中是否有数据，没有的话，就添加数据，添加数据时，要添加栈1 中删除的数据</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.outputStack:</span><br><span class="line">            <span class="hljs-keyword">while</span> self.acceptStack:</span><br><span class="line">            self.outputStack.append(self.acceptStack.pop())</span><br><span class="line">        <span class="hljs-comment">#如果有数据的话，就返回</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.outputStack:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.outputStack.pop()</span><br><span class="line">        <span class="hljs-comment">#如果没有数据，说明没有数据添加进去，也就不需要删除数据，所以返回none</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><h5 id="分析查找：首先快速的查找方法-有二分查找法，那么什么是二分查找法？"><a href="#分析查找：首先快速的查找方法-有二分查找法，那么什么是二分查找法？" class="headerlink" title="分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？"></a><strong>分析查找：首先快速的查找方法 有二分查找法，那么什么是二分查找法？</strong></h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找法什么情况下用。有序的数组中。首先 肯定是在有序的 数组中的！！！！！</span><br></pre></td></tr></table></figure><p>算法：二分法查找适用于数据量较大时，但是数据需要先排好顺序。主要思想是：（设查找的数组区间为array[low, high]）</p><p>（1）确定该区间的中间位置K（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。区域确定如下：a.array[k]&gt;T 由数组的有序性可知array[k,k+1,……,high]&gt;T;故新的区间为array[low,……，K-1]b.array[k]&lt;T 类似上面查找区间为array[k+1,……，high]。每一次查找与中间值比较，可以确定是否查找成功，不成功当前查找区间将缩小一半，递归查找即可。</p><p>时间复杂度为:<code>O(log2n)</code>。</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>1.最坏情况查找最后一个元素（或者第一个元素）Master定理T(n)=T(n/2)+O(1)所以T(n)=O(log2n)</p><p>2.最好情况查找中间元素O(1)查找的元素即为中间元素（奇数长度数列的正中间，偶数长度数列的中间靠左的元素）</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><ol><li>S(n)=n</li></ol><h5 id="二分法代码实现："><a href="#二分法代码实现：" class="headerlink" title="二分法代码实现："></a>二分法代码实现：</h5><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(array,target)</span>:</span></span><br><span class="line">    left= <span class="hljs-number">0</span></span><br><span class="line">    right= len(array)<span class="hljs-number">-1</span></span><br><span class="line">    <span class="hljs-keyword">while</span> left &lt;= right :</span><br><span class="line">        <span class="hljs-comment">#除法没有移位的快</span></span><br><span class="line">        <span class="hljs-comment"># mid = (left + right)//2</span></span><br><span class="line">        <span class="hljs-comment"># 101 = 5 =&gt; 10 = 2</span></span><br><span class="line">        <span class="hljs-comment">#1100 = 12 =&gt; 110 = 6</span></span><br><span class="line">        <span class="hljs-comment">#一下用了 向右 移一位， 那么上面是解释，它就相当于 除以2 。</span></span><br><span class="line">        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#如果中间的数等于我们要找的数，那么就返回。</span></span><br><span class="line">        <span class="hljs-keyword">if</span>  array[mid] == target:</span><br><span class="line">            <span class="hljs-keyword">return</span> mid</span><br><span class="line">        <span class="hljs-comment">#如果说中间的数 &lt; 目标的数，那么就说明，我们要找的数在右侧，所以左侧取值的索引需要改变为中间的索引+1；</span></span><br><span class="line">        <span class="hljs-keyword">elif</span> array[mid]&lt; target:</span><br><span class="line">            left = mid + <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#如果说中间的数 &gt; 目标的数，那么就说明，我们要找的数在左侧，所以左侧取值的索引需要改变为中间的索引-1； 因为越往左索引值越小</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            right = mid<span class="hljs-number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br></pre></td></tr></table></figure><p>把数组内的数据一分为二，然后计算出中间数据的 索引值。</p><p>数组中 最左侧的  索引为 0  ；最右侧的索引为 len(array)-1，数组的长度 减 1 就是 最后一个数的索引。</p><p>先判断中间索引的所对应的数组中的数值，是否与我们要查找的数字 target 相等，如果相等那么就返回，如果不相等，那么就继续判断。如果说我们找到的 array[mid] 小于  target 这个数; 那么 就说明 我们要查找的数在右侧的一半数据中，那么这个时候我们就需要改变我们左边的索引值，不在从0 开始，而是从我们中间 mid 的下一个开始，left = mid + 1，继续查找。如果说我们找到的 array[mid]  大于 target 这个数 ，那么就说明我们要查找的数据在左侧，这个时候就需要改变右侧的索引，为 right = mid-1，越往左侧走，索引值越小。直到找的的数 与target 相等为止。</p><p>以上为二分法的原理。</p><hr><h2 id="2-旋转数组的最小数字-本题考点-查找"><a href="#2-旋转数组的最小数字-本题考点-查找" class="headerlink" title="2. 旋转数组的最小数字 [^本题考点 查找]"></a>2. 旋转数组的最小数字 [^本题考点 查找]</h2><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#最小值 一定比前面的要小</span></span><br><span class="line">        <span class="hljs-comment"># 二分法查找数据  找左右的方法是：</span></span><br><span class="line">        <span class="hljs-comment">#右边的值大于中值，就说明最小值在左边</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rotateArray:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        left = <span class="hljs-number">0</span></span><br><span class="line">        right = len(rotateArray) - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果说中间的数的上一个数 &gt; 中间数，那么就说明，我们要找的数就是这个中间的数，返回这个数。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> rotateArray[mid - <span class="hljs-number">1</span>] &gt; rotateArray[mid]:</span><br><span class="line">                <span class="hljs-keyword">return</span> rotateArray[mid]</span><br><span class="line">            <span class="hljs-comment">#如果说中间的数 &lt; 中间数的上一个数，那么就说明，我们要找的数在二分法的左侧，所以右侧取值的索引需要改变为中间的索引-1；因为越往左索引值越小</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">                right = mid - <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#否则就说明，我们要找的数在二分法的右侧，所以左侧取值的索引需要改变为中间的索引+1；因为越往右索引值越小</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                left = mid + <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><hr><h5 id="什么叫做数组？"><a href="#什么叫做数组？" class="headerlink" title="什么叫做数组？"></a>什么叫做数组？</h5><p><em>所谓数组，是有序的元素序列。 [1]  若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。 [1]  这些无序排列的同类数据元素的集合称为数组。</em></p><p>例如：</p><p>int (32 位)      int         int         这三个就会组成一个数组，类型相同的变量。<br>a(0)             a(1)          a(2)</p><p>数组与python中的 列表比较相似， 用索引去查找。<br>数组的长度是固定的，在初始化时就指定长度。列表是可以动态增加的。<br>数组还和元组比较像，元组是初始化后，长度指定了就不可以变。<br>但是元组在初始化时给的值，确定了以后就不可以变了。<br>所以可以理解为数组与list 列表很相似。</p><hr><h2 id="3-在二维数组中的查找-本题考点-查找"><a href="#3-在二维数组中的查找-本题考点-查找" class="headerlink" title="3.在二维数组中的查找[^本题考点 查找]"></a>3.在二维数组中的查找[^本题考点 <em>查找</em>]</h2><p><strong>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># array 二维列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Find</span><span class="hljs-params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># 1 2 3 4</span></span><br><span class="line">        <span class="hljs-comment"># 3 4 5 6</span></span><br><span class="line">        <span class="hljs-comment"># 4 6 8 10</span></span><br><span class="line">        <span class="hljs-comment"># 9 11 13 15</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度 o(n**n)</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># for i in range(len(array)):</span></span><br><span class="line">        <span class="hljs-comment">#     for j in range(len(array[i])):</span></span><br><span class="line">        <span class="hljs-comment">#         if target == array[i][j]:</span></span><br><span class="line">        <span class="hljs-comment">#             return True</span></span><br><span class="line">        <span class="hljs-comment"># return False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#时间复杂度</span></span><br><span class="line">        <span class="hljs-comment">#O（n)</span></span><br><span class="line">        <span class="hljs-comment">#这个二维数组的长度是多少，也就是说这个数组有几行；</span></span><br><span class="line">        row_count = len(array)</span><br><span class="line">        i = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#这个数组列数的索引值，就是我们数组取第一个数的个数，也就是有几列</span></span><br><span class="line">        column_count = len(array[<span class="hljs-number">0</span>])</span><br><span class="line">        <span class="hljs-comment">#给j 一个值，就是数组列数的值-1，即为j 的最大值。</span></span><br><span class="line">        j = len(array[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment">#循环，当i 小于我们行数的时候，并且j 也没有取到 0 那么就进入循环，去查找数据。</span></span><br><span class="line">        <span class="hljs-comment">#我们要取到每行的最后一个数，即对应的那一列的第一个数，来与我们的目标数来对比，这个数是这一行的最大数，是这一列的最小数。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> i &lt; row_count <span class="hljs-keyword">and</span> j &gt;= <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#根据两个索引下标可以取到 对应的在数组中的值</span></span><br><span class="line">            value = array[i][j]</span><br><span class="line">            <span class="hljs-comment">#如果说取到的值，刚好等于目标值，那么就说明我们找到了它，直接返回就好。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> value == target:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-comment">#如果说取到的值 &gt; 我们的目标值。那就说明它不在它所在的那一列里，因为这个数是那一列的最小值，这个时候就需要改变我们列的索引值，给它减-1，找前一列的数做比较</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> target &lt; value:</span><br><span class="line">                j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果说取到的值 &lt; 我们的目标值。那就说明它不在它所在的那一行里，因为这个数是那一行的最大值，这个时候就需要改变我们行的索引值，给它加+1，找下一行的数做比较</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                i += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-包含min-函数的栈-本题考点-栈"><a href="#4-包含min-函数的栈-本题考点-栈" class="headerlink" title="4.包含min 函数的栈[^本题考点 栈]"></a>4.包含min 函数的栈[^本题考点 <em>栈</em>]</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</strong></p><p>原理：用空间换时间，用时间换空间；增加空间来减少时间的消耗</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：考虑两个栈的长度相同，添加一个，另一个栈也会删除一个</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment">#给这个类一个初始的属性，有一个栈，另外有一个最小值的列表栈</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []</span><br><span class="line">    <span class="hljs-comment">#给栈中推进去数值，推进去元素node，添加函数</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="hljs-comment">#如果最小值列表里有值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue:</span><br><span class="line">            <span class="hljs-comment">#如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="hljs-comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.minValue[<span class="hljs-number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">             <span class="hljs-comment">#如果列表里面的最后一个值，小于node值，那么就说明node这个值大；那么就添加上次添加进来的那个小的值，与栈中的数据长度保持一致；</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                self.minValue.append(self.minValue[<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-comment">#如果最小值列表里面没有值，就在最小值列表里添加node</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">    <span class="hljs-comment">#给栈中做删除操作</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果说栈中是空值得话那么就返回none，说明没有在栈中压值进来，没有最小值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#栈的长度与最小值的栈的长度要相同，所以最小值列表也需要删除一个</span></span><br><span class="line">        self.minValue.pop()</span><br><span class="line">        <span class="hljs-comment">#有值得话，就需要删除一个，删除做pop 操作；返回我们删除的那个数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="hljs-comment">#栈顶 </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果栈里没有数值的话，就返回一个空</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#否则栈里有数，那么就返回栈顶的那个数</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]</span><br><span class="line">   <span class="hljs-comment">#取出最小值，那么就是我们minvalue 中的最后一个值为最小值</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#如果为空的话，就说明没有值，返回none</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.minValue[<span class="hljs-number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">#第二种方法：不考虑两个栈的长度必须要保持一致，那么在栈删除值的时候，判断一下删除的值，是不是与装最小值的栈里的最后一个最小值相同，如果相同就删掉，如果不同，就不删除。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minValue = []</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue:</span><br><span class="line">            <span class="hljs-comment">#如果最小值列表里的最后一个值 大于 node 这个值，说明node这个值小，</span></span><br><span class="line">            <span class="hljs-comment"># 那么就放进最小值列表中；</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.minValue[<span class="hljs-number">-1</span>] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">             <span class="hljs-comment">#最后一个值不大于node这个值得话；不做操作，不需要把它两个做的长度一致</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#删除的时候，做个判断，它是不是与栈里面的最后一个值，与我们最小值栈里的最后一个值相等，那么就删除双方的这个值</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack[<span class="hljs-number">-1</span>] == self.minValue[<span class="hljs-number">-1</span>]:</span><br><span class="line">            self.minValue.pop()</span><br><span class="line">            <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="hljs-comment">#如果不等的话，就只要删除栈 里最后一个值就可以</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> self.minValue == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.minValue[<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="5-替换空格-本题考点-字符串"><a href="#5-替换空格-本题考点-字符串" class="headerlink" title="5.替换空格[^本题考点 字符串]"></a>5.替换空格[^本题考点 <em>字符串</em>]</h2><p><strong>请实现一个函数，将一个字符串中的每个空格替换成<code>“%20”</code>。例如，当字符串为<code>We Are Happy</code>.则经过替换之后的字符串为<code>We%20Are%20Happy</code>。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># s 源字符串</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">    <span class="hljs-comment">#第一种：python中自带的一个替换的函数</span></span><br><span class="line">        <span class="hljs-comment"># return s.replace(' ','%20')</span></span><br><span class="line">        <span class="hljs-comment">#第二种遍历来替换字符串中的空格</span></span><br><span class="line">        strlen = len(s)</span><br><span class="line">        <span class="hljs-comment">#借助第三方的列表来实现时间的节省。</span></span><br><span class="line">        aaa = []</span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(strlen):</span><br><span class="line">            <span class="hljs-comment">#如果是空格的话那就替换为%20.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">" "</span>:</span><br><span class="line">            <span class="hljs-comment">#if s[i] isspace:</span></span><br><span class="line">                aaa.append(<span class="hljs-string">"%"</span>)</span><br><span class="line">                aaa.append(<span class="hljs-string">"2"</span>)</span><br><span class="line">                aaa.append(<span class="hljs-string">"0"</span>)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                aaa.append(s[i])</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.join(aaa)</span><br></pre></td></tr></table></figure><hr><h2 id="6-斐波那契数列"><a href="#6-斐波那契数列" class="headerlink" title="6.斐波那契数列"></a>6.斐波那契数列</h2><p><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：下面是使用了for循环，</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># 如果是按照递归来写的话， 时间复杂度就是随着n的变化 增长率是 2^n</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-string">''' 递归实现</span></span><br><span class="line"><span class="hljs-string">        # n = 0 f(0) = 0</span></span><br><span class="line"><span class="hljs-string">        if n == 0:</span></span><br><span class="line"><span class="hljs-string">            return 0</span></span><br><span class="line"><span class="hljs-string">        # n = 1 f(1) = 1</span></span><br><span class="line"><span class="hljs-string">        if n == 1:</span></span><br><span class="line"><span class="hljs-string">            return 1</span></span><br><span class="line"><span class="hljs-string">        # if n &gt; 1  f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="hljs-string">        if n &gt; 1:</span></span><br><span class="line"><span class="hljs-string">            num = self.Fibonacci(n-1) + self.Fibonacci(n-2)</span></span><br><span class="line"><span class="hljs-string">            return num</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">        return None</span></span><br><span class="line"><span class="hljs-string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># n = 0 f(0) = 0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># n = 1 f(1) = 1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        b = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># if n &gt; 1  f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">        <span class="hljs-comment"># h = a + b</span></span><br><span class="line">        <span class="hljs-comment"># 当 n = 2 h = 0 + 1</span></span><br><span class="line">        ret = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#三个变量，互相转换 来实现</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>):</span><br><span class="line">            ret = a + b</span><br><span class="line">            b = a</span><br><span class="line">            a = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"><span class="hljs-comment">#第二种方法：相对来说比较简便，简单来讲，就是取出这个列表的最后两项求和，就是列表的第三项，时间复杂度比较小，空间复杂度为 n</span></span><br><span class="line"></span><br><span class="line"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#初始列表值 为 0 1 第三项为 0+1 = 1；</span></span><br><span class="line">         res = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</span><br><span class="line">         <span class="hljs-comment">#临界条件为：第 n 项，所以就是 这个 列表的长度要小于等于 n；大于 n 就应该跳出这个循环。</span></span><br><span class="line">         <span class="hljs-keyword">while</span> len(res) &lt;= n:</span><br><span class="line">                <span class="hljs-comment">#取出列表的最后两项，然后求和，并添加到列表中。</span></span><br><span class="line">             res.append(res[<span class="hljs-number">-1</span>] + res[<span class="hljs-number">-2</span>])</span><br><span class="line">         <span class="hljs-keyword">return</span> res[n]</span><br></pre></td></tr></table></figure><hr><h2 id="7-青蛙跳台阶"><a href="#7-青蛙跳台阶" class="headerlink" title="7.青蛙跳台阶"></a>7.青蛙跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/qinwa.png" alt></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 (1)</span></span><br><span class="line"><span class="hljs-string">2 (11,2)</span></span><br><span class="line"><span class="hljs-string">3 (12,21,111)</span></span><br><span class="line"><span class="hljs-string">4 (1111,22,112,121,211)</span></span><br><span class="line"><span class="hljs-string">5 (11111,221,212,122,1121,2111,1112,1211)</span></span><br><span class="line"><span class="hljs-string">6 (111111,222,2211,1122,2112,1221,2121,1212,21111,12111,11211,11121,11112,)</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(self, number)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第一种方法：</span></span><br><span class="line">         res = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span><br><span class="line">         <span class="hljs-keyword">while</span> len(res) &lt;= number:</span><br><span class="line">             res.append(res[<span class="hljs-number">-1</span>] + res[<span class="hljs-number">-2</span>])</span><br><span class="line">         <span class="hljs-keyword">return</span> res[number]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         a = <span class="hljs-number">1</span></span><br><span class="line">         b = <span class="hljs-number">1</span></span><br><span class="line">         <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,number):</span><br><span class="line">             a,b = b,a+b</span><br><span class="line">         <span class="hljs-keyword">return</span> a</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number ==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number == <span class="hljs-number">2</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span></span><br><span class="line">        ret = <span class="hljs-number">0</span></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        b = <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,number+<span class="hljs-number">1</span>):</span><br><span class="line">            ret = a+b</span><br><span class="line">            a = b</span><br><span class="line">            b = ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h2 id="8-变态跳台阶"><a href="#8-变态跳台阶" class="headerlink" title="8.变态跳台阶"></a>8.变态跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 (1)</span></span><br><span class="line"><span class="hljs-string">2 (11,2)</span></span><br><span class="line"><span class="hljs-string">3 (111,21,3,12)</span></span><br><span class="line"><span class="hljs-string">4 (1111,22,13,31,211,112,121,4)</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">n  2^(n-1)</span></span><br><span class="line"><span class="hljs-string">f(n)  = f(n-1) + f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="hljs-string">f(n-1) = f(n-2) + .... + f(1)</span></span><br><span class="line"><span class="hljs-string">f(n) = 2f(n-1)  n &gt; 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">f(1) = 1 n = 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(self, number)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#第一种方法：</span></span><br><span class="line">        <span class="hljs-comment"># return pow(2,number-1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第二种方法：</span></span><br><span class="line">        <span class="hljs-comment"># return 2 ** (number - 1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#第三种方法：</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> number ==<span class="hljs-number">1</span> :</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        a = <span class="hljs-number">1</span></span><br><span class="line">        ret = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,number+<span class="hljs-number">1</span>):</span><br><span class="line">            a,ret = ret,<span class="hljs-number">2</span>*ret</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h2 id="9-调整数组顺序使奇数位于偶数前面-本题知识点-数组"><a href="#9-调整数组顺序使奇数位于偶数前面-本题知识点-数组" class="headerlink" title="9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 数组]"></a>9. 调整数组顺序使奇数位于偶数前面       [^本题知识点 <em>数组</em>]</h2><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(self, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度是o(n)</span></span><br><span class="line">        <span class="hljs-comment">#空间复杂度o(n)</span></span><br><span class="line">        <span class="hljs-comment"># ret = []</span></span><br><span class="line">        <span class="hljs-comment"># for i in array:</span></span><br><span class="line">        <span class="hljs-comment">#     if i % 2 == 1:</span></span><br><span class="line">        <span class="hljs-comment">#         ret.append(i)</span></span><br><span class="line">        <span class="hljs-comment"># for i in array:</span></span><br><span class="line">        <span class="hljs-comment">#     if i % 2 == 0:</span></span><br><span class="line">        <span class="hljs-comment">#         ret.append(i)</span></span><br><span class="line">        <span class="hljs-comment"># return ret</span></span><br><span class="line"><span class="hljs-comment">#用了冒泡排序的原理，判断奇偶数，如果一个是偶数而且下一个是奇数，那么两个就互换位置。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(array) - i - <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> array[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> array[j + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">                    array[j], array[j + <span class="hljs-number">1</span>] = array[j + <span class="hljs-number">1</span>], array[j]</span><br><span class="line">        <span class="hljs-keyword">return</span> array</span><br></pre></td></tr></table></figure><hr><h3 id="知识点：冒泡排序法"><a href="#知识点：冒泡排序法" class="headerlink" title="知识点：冒泡排序法"></a>知识点：冒泡排序法</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(array)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">#一共 需要 n 次 的循环，每一个都要找到没排好序的最大值。</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):</span><br><span class="line">        <span class="hljs-comment">#将没有排好序的数组 找最大值，并一直将最大值换到最顶端。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(array)-i<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-comment">#判断如果说一个数大于它下面的一个数，那么就两个数的位置互换。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> array[j] &gt; array[j+<span class="hljs-number">1</span>]:</span><br><span class="line">                array[j],array[j+<span class="hljs-number">1</span>] = array[j+<span class="hljs-number">1</span>],array[j]</span><br><span class="line">    <span class="hljs-keyword">return</span> array</span><br></pre></td></tr></table></figure><hr><h2 id="10-栈的压入，弹出序列-本题考点-栈"><a href="#10-栈的压入，弹出序列-本题考点-栈" class="headerlink" title="10.栈的压入，弹出序列  [^本题考点 栈]"></a>10.栈的压入，弹出序列  [^本题考点 <em>栈</em>]</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先要先有一个栈，列表</span></span><br><span class="line">        <span class="hljs-comment">#按照 pushV 的方式去压入栈，</span></span><br><span class="line">        <span class="hljs-comment"># 弹出的时候是需要循环判断是否需要弹出</span></span><br><span class="line">        <span class="hljs-comment">#判断是否需要弹出的时机，刚刚压入过后就判断</span></span><br><span class="line">        <span class="hljs-comment">#判断需要弹出的情况的条件，压入栈的顶部和弹出栈的顶部数据相等</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#先判断pushV 这个栈里是否为空，如果是空的话返回none，或者说这两个序列的长度不相同。那也返回none。</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pushV == [] <span class="hljs-keyword">or</span> len(pushV ) != len(popV):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"><span class="hljs-comment">#首先有个栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="hljs-comment">#定义一个变量，它作为弹出序列的索引存在。</span></span><br><span class="line">        index = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#遍历 pushV 的这个列表里的元素，并把它每个都添加进stack 这个列表中</span></span><br><span class="line">        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> pushV:</span><br><span class="line">            stack.append(item)</span><br><span class="line">            <span class="hljs-comment">#做判断 1，stack 里有元素 并且 stack里的最后一个元素 等于 popV 这个序列里 第一个元素，那么就进去这个循环，然后把stack里的这个元素删掉，这样下次还会添加新的元素，然后再和 popV 里的下一个元素 做判断，所以这个时候 index  这个索引值就要发生变化了，这个时候比较的是 它的下一个值。往右移动一位。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>] == popV[index]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                index += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        if stack == []:</span></span><br><span class="line"><span class="hljs-string">            return True</span></span><br><span class="line"><span class="hljs-string">        else:</span></span><br><span class="line"><span class="hljs-string">            return False</span></span><br><span class="line"><span class="hljs-string">            </span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-comment">#最后 直到 把 pushV 里的元素都遍历完，然后stack内的元素都比较完，并都删除完，就返回True，如果说 它不为空：说明 pushV 里有的元素 是popV 中所没有的，这个时候就说明他们不相等，那么这个情况，就需要返回 False。</span></span><br><span class="line">        <span class="hljs-comment">#以下代码与以上代码 共同实现的相同的功能，但是下面的代码相对来说等 “装B” 一点。节省代码空间。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> stack == [] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><hr><h4 id="知识点链表："><a href="#知识点链表：" class="headerlink" title="知识点链表："></a><code>知识点</code>链表：</h4><p>链表是一种物理<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83/8727749" target="_blank" rel="noopener">存储单元</a>上非连续、非顺序的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782" target="_blank" rel="noopener">存储结构</a>，<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313" target="_blank" rel="noopener">数据元素</a>的逻辑顺序是通过链表中的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">数据元素</a>的数据域，另一个是存储下一个结点地址的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>域。 相比于<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081" target="_blank" rel="noopener">线性表</a><a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/9845234" target="_blank" rel="noopener">顺序结构</a>，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiao.png" alt></p><p>数组 就是连续的 同一个类型的 元素，而且必须是固定的长度。</p><p>如果我们想要非固定的长度来存储数据。这个时候就出现了链表。</p><hr><h2 id="11-从栈尾到栈头打印链表-本题知识点-链表"><a href="#11-从栈尾到栈头打印链表-本题知识点-链表" class="headerlink" title="11. 从栈尾到栈头打印链表 [^本题知识点 链表]"></a>11. 从栈尾到栈头打印链表 [^本题知识点 <em>链表</em>]</h2><p><strong>输入一个链表，按链表值从尾到头的顺序返回一个<code>ArrayList</code>。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># pointer 指针 temporary临时数据;node 结点</span></span><br><span class="line">        <span class="hljs-comment">#给一个 arraylist 空列表，然后向这个里面压入数据，来输出 这个链表值 的一个从尾到头 的顺序值。</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="hljs-comment">#把 listNode 这个链表 传给一个 变量</span></span><br><span class="line">        pTemp = listNode</span><br><span class="line">        <span class="hljs-comment">#当这个变量 存在时 有值时：</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pTemp:</span><br><span class="line">            <span class="hljs-comment">#使用 insert 的原因是：insert 可以在指定位置之前插入元素，列表.insert(索引，值)</span></span><br><span class="line">            <span class="hljs-comment">#在空列表中起始位置，插入 pTemp的第一个值，然后 给pTemp 赋值 为 pTemp.next （下一个值） </span></span><br><span class="line">            ret.insert(<span class="hljs-number">0</span>, pTemp.val)</span><br><span class="line">            <span class="hljs-comment">#更改 指针，使指针指向下一个 元素</span></span><br><span class="line">            pTemp = pTemp.next</span><br><span class="line"><span class="hljs-comment">#最后返回我们 这个 插入值的 列表 </span></span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/congtou.png" alt></p><p>如图所示：打印出 3 2 1 即为我们的目标。</p><hr><h2 id="12-链表中的倒数第k个结点-本题考点-链表"><a href="#12-链表中的倒数第k个结点-本题考点-链表" class="headerlink" title="12.链表中的倒数第k个结点[^本题考点 链表]"></a>12.链表中的倒数第k个结点[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(self, head, k)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># k 如果 比我们的链表的长度还要大的话，我们直接返回None</span></span><br><span class="line">        <span class="hljs-comment"># k 如果小于链表的长度，我们可以定义两个变量，这两个变量中间间隔k</span></span><br><span class="line">        <span class="hljs-comment">#用两个指针做一个尺子，然后让尺子在跳跳，然后就会找到 第k 个结点</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#起始位置 第一个和第二个指针 都是从头开始的。</span></span><br><span class="line">        firstPoint = head</span><br><span class="line">        secondPoint = head</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#首先让一个指针先开始移动，那么就是遍历我们的k 值，让我们的 第一个指针移动 k 步。</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):</span><br><span class="line">            <span class="hljs-comment">#如果第一个指针为空的话，那么说明我们的k值为空，那么我们的这个链表就为空。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> firstPoint == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">            <span class="hljs-comment">#第一个指针 移动一步 </span></span><br><span class="line">            firstPoint = firstPoint.next</span><br><span class="line"><span class="hljs-comment">#当 第一个指针不为空的时候，</span></span><br><span class="line">        <span class="hljs-keyword">while</span> firstPoint != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-comment">#移动尺子，移动距离为  k 的长度， 直到 第一个指针点 为空的时候 ，就到了 这个链表的结尾，此时就返回 第二个指针 那么就为 倒数第 k 个结点。</span></span><br><span class="line">            firstPoint = firstPoint.next</span><br><span class="line">            secondPoint = secondPoint.next</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> secondPoint</span><br></pre></td></tr></table></figure><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiaozhong.png" alt></p><hr><p>如上图所示：分析过程，可以为两个结点的指针长度，也可以为三个结点的指针长度，也可以为k个结点的指针长度。</p><h2 id="13-反转链表-本题考点-链表"><a href="#13-反转链表-本题考点-链表" class="headerlink" title="13.反转链表[^本题考点 链表]"></a>13.反转链表[^本题考点 <em>链表</em>]</h2><p><strong>输入一个链表，反转链表后，输出新链表的表头。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"> pHead始终指向要反转的结点</span></span><br><span class="line"><span class="hljs-string">last 指向反转后的首结点</span></span><br><span class="line"><span class="hljs-string">每反转一个结点，</span></span><br><span class="line"><span class="hljs-string">把pHead结点的下一个结点指向last,</span></span><br><span class="line"><span class="hljs-string">last指向pHead成为反转后首结点,</span></span><br><span class="line"><span class="hljs-string">再把pHead向前移动一个结点直至None结束</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回ListNode</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#首先判断这个链表里是否只有一个结点，只有一个结点那么它就不需要发生变化，它第一个结点指向的指针就为 none</span></span><br><span class="line">        <span class="hljs-comment"># 这个时候就直接返回这个 pHead</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pHead <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> pHead.next:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead</span><br><span class="line">        <span class="hljs-comment">#首先要明白 反转过后，第一个数值的指针的结点指向的是none 也就是一个指向反转后的首结点 为none</span></span><br><span class="line">        last = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#当 要反转的结点 pHead 存在的时候</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pHead:</span><br><span class="line">            <span class="hljs-comment">#先找到第一个元素的结点指向的元素，赋值给一个临时变量</span></span><br><span class="line">            temp = pHead.next</span><br><span class="line">            <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">            本来一个元素的结点 是要指向它的下一个 元素的 .</span></span><br><span class="line"><span class="hljs-string">            反转后 就是  这个元素 要指向它的 上一个 元素 .</span></span><br><span class="line"><span class="hljs-string">            </span></span><br><span class="line"><span class="hljs-string">            """</span></span><br><span class="line">            <span class="hljs-comment">#然后第一次循环 把这第一个元素的结点 改为 none last 第一个值 是 none (此时还没有发生改变的last)</span></span><br><span class="line">            <span class="hljs-comment"># 之后循环 就是 每 反转一个结点 把pHead结点的下一个结点指向last,</span></span><br><span class="line">            pHead.next = last</span><br><span class="line">            <span class="hljs-comment">#下一步 是把 pHead 这个 元素的 赋值给last</span></span><br><span class="line">            <span class="hljs-comment"># last指向pHead成为反转后首结点,</span></span><br><span class="line">            last = pHead</span><br><span class="line">            <span class="hljs-comment"># 再把pHead向前移动一个结点直至None结束</span></span><br><span class="line">            pHead = temp</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> last</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">反转需要两步 ，第一步找到它的 结点，第二步改变结点就可以了；</span></span><br><span class="line"><span class="hljs-string">之后需要 把结点 赋值为 这个元素的 本身 ；</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">循环：</span></span><br><span class="line"><span class="hljs-string"> 找到 元素结点指向的元素，</span></span><br><span class="line"><span class="hljs-string">目标是 让元素结点指向的元素 改为 自己本身。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#第二种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">1 将现有的头换成尾，尾部的next为空</span></span><br><span class="line"><span class="hljs-string">2 将从第二个node开始，循环将next指向前一个</span></span><br><span class="line"><span class="hljs-string">3 需要一直有一个指针指向还没有反转的链表的头部</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回ListNode</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#判断是否为空值，没有元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#判断是否只有一个元素</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead.next == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead</span><br><span class="line"><span class="hljs-comment">#左边指针为 头 第一个 指针</span></span><br><span class="line">        leftPointer = pHead</span><br><span class="line">        <span class="hljs-comment">#中间 的指针 为 第二个指针</span></span><br><span class="line">        midPointer = pHead.next</span><br><span class="line">        <span class="hljs-comment">#右边的指针  为 指向 中间 指针后的 所有的元素 </span></span><br><span class="line">        rightPointer = midPointer.next</span><br><span class="line">        <span class="hljs-comment">#左边的指针为 起始 的 元素， 反转后 它的next 为 None；</span></span><br><span class="line">        leftPointer.next = <span class="hljs-literal">None</span></span><br><span class="line"><span class="hljs-comment">#循环，当我的右边的结点指向的 元素 一直存在的时候，那么就会一直循环，一直来反转结点。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> rightPointer:</span><br><span class="line">            <span class="hljs-comment">#中间指针指向的为上一个 元素 即 leftPointer</span></span><br><span class="line">            midPointer.next = leftPointer</span><br><span class="line">            <span class="hljs-comment">#三个指针开始往右移。每次移一个。</span></span><br><span class="line">            <span class="hljs-comment">#左边指针 往右移一个 就是中间指针的位置</span></span><br><span class="line">            leftPointer = midPointer</span><br><span class="line">            <span class="hljs-comment">#中间指针 往 右 移 一个，就时 右边指针的位置</span></span><br><span class="line">            midPointer = rightPointer</span><br><span class="line">            <span class="hljs-comment">#右边指针往右移 一个 ，就时 右边指针的下一个。</span></span><br><span class="line">            rightPointer = rightPointer.next</span><br><span class="line"><span class="hljs-comment">#当右指针 指向的为 空的时候 就会跳出循环，那么此时的最后一次循环的 中间的指针的 指向的 是此时的左 指针。</span></span><br><span class="line">        midPointer.next = leftPointer</span><br><span class="line">        <span class="hljs-comment">#最后返回中间的 这个指针，就是 最后一个 反转的指针的第一个，表头。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> midPointer</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/fanzhuan.png" alt></p><hr><h2 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14.复杂链表的复制"></a>14.复杂链表的复制</h2><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/复杂链表的复制.png" alt></p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class RandomListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.label = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-comment">#         self.random = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回 RandomListNode</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Clone</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#判断当pHead 为空值的时候 返回的是none</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 复制一个一样的node， 并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#把第一个 A 的值 赋给 node 为A‘</span></span><br><span class="line">            node = RandomListNode(pTmp.label)</span><br><span class="line">            <span class="hljs-comment">#此时 node A' 的结点指向的是 原来A 的结点指向的 值</span></span><br><span class="line">            node.next = pTmp.next</span><br><span class="line">            <span class="hljs-comment">#将原来A 的结点指向的值 改为 A’</span></span><br><span class="line">            pTmp.next = node</span><br><span class="line">            <span class="hljs-comment">#将 我们要操作的指针 向后移动 操作下一个 需要复制的元素，即为 A‘ 结点 指向的元素</span></span><br><span class="line">            pTmp = node.next</span><br><span class="line">        <span class="hljs-comment"># 实现新建的node的random的指向</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#如果现在操作的这个指针的元素，存在一个 random 的结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp.random:</span><br><span class="line">                <span class="hljs-comment">#那么 这个A 的结点指向的（A’）的random结点指向的 值 为 A 的random的结点指向的值，指向的结点(也就是它的下一个值)上图更清楚明白。</span></span><br><span class="line">                pTmp.next.random = pTmp.random.next</span><br><span class="line">            <span class="hljs-comment">#建好 这个元素的 random 的值，然后移动 指针 到下一个元素，来 建立 下一个 复制的元素的random 结点的指向。</span></span><br><span class="line">            <span class="hljs-comment">#当前元素 下一个的下一个 是复制的元素 是需要添加random 指向的元素。</span></span><br><span class="line">            pTmp = pTmp.next.next</span><br><span class="line">        <span class="hljs-comment"># 断开原来的node 和 新的node 之间的链接</span></span><br><span class="line">        <span class="hljs-comment">#最后 为断开 链接 的操作</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="hljs-comment">#复制的新链表的表头A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        <span class="hljs-comment">#复制的新链表的第一个值A’ 为 旧链表 A 的结点指向的 下一个值A‘</span></span><br><span class="line">        pNewTmp = pHead.next</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp:</span><br><span class="line">            <span class="hljs-comment">#print(pTmp.label)</span></span><br><span class="line">            <span class="hljs-comment">#将旧链表 A 的指向结点 改为  A‘ 的指向的下一个 的B。</span></span><br><span class="line">            pTmp.next = pTmp.next.next</span><br><span class="line">            <span class="hljs-comment">#如果新的 链表 的元素有指向的下一个的指针</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pNewTmp.next:</span><br><span class="line">                <span class="hljs-comment">#那么就把 这个元素的A’ 的结点指向 改为 A‘ 下一个 B 的下一个 的B’</span></span><br><span class="line">                pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                <span class="hljs-comment">#然后再 将 新链表的指针移 位，来断开下一个 链接，也就是 指针改为了 B‘ </span></span><br><span class="line">                pNewTmp = pNewTmp.next</span><br><span class="line">            <span class="hljs-comment">#上面新链表的元素指针改好了，再更改 下一个旧链表的 元素 也就是 上三行代码 之前改好的 A 的结点指向的B </span></span><br><span class="line">            pTmp = pTmp.next</span><br><span class="line">            <span class="hljs-comment">#如此循环下去，改变所有的 新链表，旧链表的指向。</span></span><br><span class="line">        <span class="hljs-comment">#最后返回这个复制好的新链表。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> newHead</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">#第二种方法：</span></span><br><span class="line">     <span class="hljs-keyword">import</span> copy</span><br><span class="line">         chead=copy.deepcopy(pHead)</span><br><span class="line">         <span class="hljs-keyword">return</span> chead</span><br></pre></td></tr></table></figure><hr><h2 id="15-两个链表之间的第一个公共结点"><a href="#15-两个链表之间的第一个公共结点" class="headerlink" title="15.两个链表之间的第一个公共结点"></a>15.两个链表之间的第一个公共结点</h2><p><strong>输入两个链表，找出它们的第一个公共结点</strong></p><p>如图：</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/liangge.png" alt></p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="hljs-comment">#当链表1 和链表2 同时存在的时候</span></span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp1 <span class="hljs-keyword">and</span> pTmp2:</span><br><span class="line">            <span class="hljs-comment">#当两个链表移动到值相同的时候，这个位置就是结点，直接返回pTmp1或pTmp2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp1 == pTmp2:</span><br><span class="line">                <span class="hljs-keyword">return</span> pTmp1</span><br><span class="line">            <span class="hljs-comment">#移动指针的位置，两个同时移动，</span></span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">            </span><br><span class="line">        <span class="hljs-comment">#第一个参数给比较短的那个链表的值</span></span><br><span class="line">        <span class="hljs-comment">#第二个参数给比较长的链表的值</span></span><br><span class="line">        <span class="hljs-comment">#第三个参数是比较短的那个链表头</span></span><br><span class="line">        <span class="hljs-comment">#第四个参数是比较长的那个链表头</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findEqual</span><span class="hljs-params">(longPointer, shorPointer, longHead, shortHead)</span>:</span></span><br><span class="line">            k = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment"># 寻找出链表长度之间的差值，让长的链表继续走，直到链表走完为止，走了多少步，就说明，两个链表之间的差值是多少。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> longPointer:</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">                k += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#然后：</span></span><br><span class="line">            <span class="hljs-comment"># 先让长的那个去走k步</span></span><br><span class="line">            longPointer = longHead</span><br><span class="line">            shortPointer = shortHead</span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line"><span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-keyword">while</span> longPointer != shortPointer:</span><br><span class="line">                longPointer = longPointer.next</span><br><span class="line">                shortPointer = shortPointer.next</span><br><span class="line">            <span class="hljs-keyword">return</span> shortPointer</span><br><span class="line"><span class="hljs-comment">#如果两个链表不一样的长度，那么假设是 第一个链表长度长，第二个链表已经走完了，结束了，那么第一个链表还没有走完，那么就调用我们封装好的函数，或者是看下面注释的代码。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp1:</span><br><span class="line">            <span class="hljs-keyword">return</span> findEqual(pTmp1,pTmp2,pHead1,pHead2)</span><br><span class="line">            <span class="hljs-comment"># k = 0</span></span><br><span class="line">            <span class="hljs-comment"># #寻找出链表长度之间的差值</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     k += 1</span></span><br><span class="line">            <span class="hljs-comment"># #先让长的那个去走k步</span></span><br><span class="line">            <span class="hljs-comment"># pTmp2 = pHead2</span></span><br><span class="line">            <span class="hljs-comment"># pTmp1 = pHead1</span></span><br><span class="line">            <span class="hljs-comment"># for  i in range(k):</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1=pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1 != pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment"># return pTmp1</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp2:</span><br><span class="line">            <span class="hljs-keyword">return</span> findEqual(pTmp1, pTmp2, pHead1, pHead2)</span><br><span class="line">            <span class="hljs-comment"># k = 0</span></span><br><span class="line">            <span class="hljs-comment"># # 寻找出链表长度之间的差值</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment">#     k += 1</span></span><br><span class="line">            <span class="hljs-comment"># # 先让长的那个去走k步</span></span><br><span class="line">            <span class="hljs-comment"># pTmp2 = pHead2</span></span><br><span class="line">            <span class="hljs-comment"># pTmp1 = pHead1</span></span><br><span class="line">            <span class="hljs-comment"># for i in range(k):</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment">#长的走k步之后，再让两个链表一起移动，直到两个链表移动的位置的值相等为止，那么这个点就是 两个链表的第一个公共结点。</span></span><br><span class="line">            <span class="hljs-comment"># while pTmp1 != pTmp2:</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp1 = pTmp1.next</span></span><br><span class="line">            <span class="hljs-comment">#     pTmp2 = pTmp2.next</span></span><br><span class="line">            <span class="hljs-comment"># return pTmp2</span></span><br></pre></td></tr></table></figure><hr><h2 id="16-合并两个排序的链表-本题考点-链表"><a href="#16-合并两个排序的链表-本题考点-链表" class="headerlink" title="16.合并两个排序的链表 [^本题考点  链表]"></a>16.合并两个排序的链表 [^本题考点  链表]</h2><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong></p><p>如图：为两个递增的链表</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/liang.png" alt></p><p>如下图，合并成一个单调不减链表</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/hecheng.png" alt></p><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#第一种方法：</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">比较两个链表的首结点，哪个小的的结点则合并到第三个链表尾结点，并向前移动一个结点。</span></span><br><span class="line"><span class="hljs-string">步骤一结果会有一个链表先遍历结束，或者没有</span></span><br><span class="line"><span class="hljs-string">第三个链表尾结点指向剩余未遍历结束的链表</span></span><br><span class="line"><span class="hljs-string">返回第三个链表首结点</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回合并后列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="hljs-number">0</span>)</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="hljs-keyword">while</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> pHead1.val &lt;= pHead2.val:</span><br><span class="line">                tmp.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                tmp.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="hljs-keyword">if</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            tmp.next = pHead2</span><br><span class="line">        <span class="hljs-keyword">elif</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">            tmp.next = pHead1</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next</span><br><span class="line">        </span><br><span class="line"><span class="hljs-comment">#第二种方法：</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回合并后列表</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先判断两个链表是不是为空。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead2</span><br><span class="line">        <span class="hljs-keyword">if</span> pHead2 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> pHead1</span><br><span class="line"><span class="hljs-comment">#比较两个链表当前指针的元素值的大小。小的那一方为新的一个表头。</span></span><br><span class="line">        newHead = pHead1 <span class="hljs-keyword">if</span> pHead1.val &lt; pHead2.val <span class="hljs-keyword">else</span> pHead2</span><br><span class="line"></span><br><span class="line">        pTmp1 = pHead1</span><br><span class="line">        pTmp2 = pHead2</span><br><span class="line">        <span class="hljs-comment">#判断 如果新表头 是 表1 的头的话 那么 新表头</span></span><br><span class="line">        <span class="hljs-keyword">if</span> newHead == pTmp1:</span><br><span class="line">            pTmp1 = pTmp1.next</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            pTmp2 = pTmp2.next</span><br><span class="line">        <span class="hljs-comment">#</span></span><br><span class="line">        previousPointer = newHead</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> pTmp1 <span class="hljs-keyword">and</span> pTmp2:</span><br><span class="line">            <span class="hljs-keyword">if</span> pTmp1.val &lt; pTmp2.val:</span><br><span class="line">                previousPointer.next = pTmp1</span><br><span class="line">                previousPointer = pTmp1</span><br><span class="line">                pTmp1 = pTmp1.next</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                previousPointer.next = pTmp2</span><br><span class="line">                previousPointer = pTmp2</span><br><span class="line">                pTmp2 = pTmp2.next</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pTmp1 == <span class="hljs-literal">None</span>:</span><br><span class="line">        </span><br><span class="line">            previousPointer.next = pTmp2</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            previousPointer.next = pTmp1</span><br><span class="line">            </span><br><span class="line">        <span class="hljs-keyword">return</span> newHead</span><br></pre></td></tr></table></figure><hr><h2 id="17-圆圈中最后剩下的数-本题考点-模拟"><a href="#17-圆圈中最后剩下的数-本题考点-模拟" class="headerlink" title="17.圆圈中最后剩下的数 [^本题考点 模拟]"></a>17.圆圈中最后剩下的数 [^本题考点 <em>模拟</em>]</h2><p><strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/xiao.png" alt></p><hr><p>思路分析：</p><p>这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。</p><p>链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).</p><p>链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).</p><p>这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。</p><p>链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)</p><p>  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。</p><p>但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：</p><p>(iii+m)%n    我们一共是 n 个值，从0-(n-1);</p><p>f(n-1) = iii</p><p>所以 f(n) = f `(n-1) = (iii+m)%n</p><p>所以 f(n) = (f(n-1)+m)</p><p>那么这个通项表达式我们就找到了，再去编写代码。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#通过推导公式可得 f(n) = (f(n-1)+m)%n</span></span><br><span class="line">        <span class="hljs-comment">#首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment">#只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        value = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#时间复杂度 o(n)</span></span><br><span class="line">        <span class="hljs-comment">#从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 </span></span><br><span class="line">        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-comment">#现在数到的 m-1 这个值 的索引。对应上上面的公式。</span></span><br><span class="line">            currentValue = (value+m) % index</span><br><span class="line">            <span class="hljs-comment">#把找到的这个下标值 赋值给 value</span></span><br><span class="line">            value = currentValue</span><br><span class="line">        <span class="hljs-comment">#返回编号</span></span><br><span class="line">        <span class="hljs-keyword">return</span> value</span><br></pre></td></tr></table></figure><hr><h2 id="18-链表中环的入口点-本题知识点-链表"><a href="#18-链表中环的入口点-本题知识点-链表" class="headerlink" title="18.链表中环的入口点 [^本题知识点  链表]"></a>18.链表中环的入口点 [^本题知识点  链表]</h2><p><strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/lianbiaozhonghuan.png" alt></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。</span></span><br><span class="line">        <span class="hljs-comment">#循环跳</span></span><br><span class="line">        <span class="hljs-comment">#要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pHead == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> </span><br><span class="line"><span class="hljs-comment">#定义两个指针，一个快的一个慢的。</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line">        slowPointer = pHead</span><br><span class="line"><span class="hljs-comment">#当快指针存在时，而且快指针的结点指向的下一个也存在</span></span><br><span class="line">        <span class="hljs-keyword">while</span> fastPointer <span class="hljs-keyword">and</span> fastPointer.next :</span><br><span class="line">            <span class="hljs-comment">#那么让快指针走两步</span></span><br><span class="line">            fastPointer = fastPointer.next.next</span><br><span class="line">            <span class="hljs-comment">#让慢指针走一步</span></span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">            <span class="hljs-comment">#如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break</span></span><br><span class="line">            <span class="hljs-keyword">if</span> fastPointer == slowPointer:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment">#如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> fastPointer == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> fastPointer.next == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度</span></span><br><span class="line">        <span class="hljs-comment">#假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 那么  L = s + d</span></span><br><span class="line">        <span class="hljs-comment">#假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少</span></span><br><span class="line">        <span class="hljs-comment"># fast 走的长度 就是 ( m + d ) * n + d + s = 2 L</span></span><br><span class="line">        <span class="hljs-comment">#带入 ( m + d ) * n + d + s = 2 （s + d ）</span></span><br><span class="line">        <span class="hljs-comment"># s = m + (n-1)(m+d)</span></span><br><span class="line"><span class="hljs-comment">#有环的话，那么就让快指针从头开始走，这次一次走一步，</span></span><br><span class="line">        fastPointer = pHead</span><br><span class="line"><span class="hljs-comment">#此时慢指针还在环里走着，没有走到结点</span></span><br><span class="line">        <span class="hljs-keyword">while</span> fastPointer != slowPointer:</span><br><span class="line">            fastPointer = fastPointer.next</span><br><span class="line">            slowPointer = slowPointer.next</span><br><span class="line">        <span class="hljs-comment">#当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> fastPointer</span><br></pre></td></tr></table></figure><p>定义：</p><p>假设 slow 走了 L 步，那么 fast 就走了 2L 步。</p><p> 我们 链表的头部 到 链表的环的入口结点处 的距离是 S</p><p>那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 </p><p>链表的环中，慢指针走过的距离是d，那么没走过的距离是M。</p><p>我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。</p><p>那么 L = s + d</p><p>2L = 2(s+d) = n*(m + d) + d + s</p><p>由上面公式 推导出 n(m+d) = s + d</p><p>得到：s = n(m+d) -d；</p><p>s = nm + (n-1)(d)<br>s = m + (n-1)(m+d)</p><hr><h2 id="19-二进制中的1的个数"><a href="#19-二进制中的1的个数" class="headerlink" title="19.二进制中的1的个数"></a>19.二进制中的1的个数</h2><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</strong></p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a><code>知识点:</code></h4><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>特性：</p><p>1、一个负整数（或原码）与其补数（或补码）相加，和为模。</p><p>2、对一个整数的补码再求补码，等于该整数自身。</p><p>3、补码的正零与负零表示方法相同</p><h4 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 ~"></a>按位取反 ~</h4><p>~，用法只有一个那就是按位取反，需要注意的是：</p><ul><li>~的按位取反，包括符号位</li><li>正数各位取反变为负数，显示时转化为其补码</li><li>负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位去反</li></ul><h5 id="1-5"><a href="#1-5" class="headerlink" title="1. ~5"></a>1. ~5</h5><p>5 的二进制为 0101，</p><p>~5</p><ul><li>（1）各位取反，1010</li><li>（2）变为负数，转化为其补码形式（符号位保持不变），各位取反 1（1101），再加1（1110），也即 -6</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~<span class="hljs-number">5</span></span><br><span class="line">&gt;&gt; <span class="hljs-number">-6</span></span><br></pre></td></tr></table></figure><h5 id="2-5"><a href="#2-5" class="headerlink" title="2. ~(-5)"></a>2. ~(-5)</h5><p>-5 因为是负数，存储时存储的是其补码：</p><ul><li>-5 的补码是：1011，</li><li>~(-5)将其各位取反（包括符号位），也即 0100（4）</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~(<span class="hljs-number">-5</span>)</span><br><span class="line">&gt;&gt; <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#第一种：</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#补码：正数不变，负数是它的正数的反码 + 1</span></span><br><span class="line">        <span class="hljs-comment"># -2 补码： -2 的 1 0000.。。000010，</span></span><br><span class="line">        <span class="hljs-comment">#                 1 1111.。。111101 + 1</span></span><br><span class="line">        <span class="hljs-comment">#-2 的补码就是    1 1111.。。111110</span></span><br><span class="line">        <span class="hljs-comment">#把输入的正数n转化为二进制的数，并把0b 替换掉，计算1的数量，如果输入的值不是正数的话</span></span><br><span class="line">        <span class="hljs-comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。</span></span><br><span class="line">        <span class="hljs-comment">#那么就是 2 的32 次方 然后 + n  这是在取一个负数的补码  就相当于  n &amp; 0xffffffff</span></span><br><span class="line">        <span class="hljs-comment">#然后计算 这个数里面 1 的 数量</span></span><br><span class="line">        <span class="hljs-keyword">return</span> bin(n).replace(<span class="hljs-string">"0b"</span>, <span class="hljs-string">""</span>).count(<span class="hljs-string">"1"</span>) <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> bin(<span class="hljs-number">2</span> ** <span class="hljs-number">32</span> + n).replace(<span class="hljs-string">"0b"</span>, <span class="hljs-string">""</span>).count(<span class="hljs-string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">#第二种：</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment"># 1 出现的次数为0 次</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#判断 这个数 n 是不是负数，如果是负数的话 求其补码：</span></span><br><span class="line">        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:</span><br><span class="line">            n = n &amp; <span class="hljs-number">0xffffffff</span></span><br><span class="line">        <span class="hljs-comment">#如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.</span></span><br><span class="line">        <span class="hljs-keyword">while</span> n:</span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line">            n = (n - <span class="hljs-number">1</span>) &amp; n</span><br><span class="line">        <span class="hljs-keyword">return</span> count</span><br><span class="line">    <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.</span></span><br><span class="line"><span class="hljs-string">    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。</span></span><br><span class="line"><span class="hljs-string">    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.</span></span><br><span class="line"><span class="hljs-string">    </span></span><br><span class="line"><span class="hljs-string">    """</span></span><br></pre></td></tr></table></figure><hr><h2 id="20-不用加减乘除做加法-本题考点-按位运算"><a href="#20-不用加减乘除做加法-本题考点-按位运算" class="headerlink" title="20.不用加减乘除做加法[^本题考点 按位运算]"></a>20.不用加减乘除做加法[^本题考点 <em>按位运算</em>]</h2><p><strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</strong></p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/buyong.png" alt></p><p>分析：</p><p>对于数字运算，如果说四则运算不能用的话，那么我们只能用位运算来做了。</p><p>我们以 5 + 17 为例 结果为 22，那么 22 的计算结果，我们可以分为三步 来进行：</p><p>​    第一步： 只做各位相加不进位  也就是说 没一位上的数字 相应的来相加 但是不进位，那么  5 + 7 为 12 </p><p>​    个位数 5 和 7 相加 不进位 是2  十位是0 和1  相加 为 1 </p><p>​    第二步： 5 + 7 中有进位，进位值 是10 ;</p><p>​    第三步： 把前面两个结果 加起来： 12 + 10 = 22</p><p>以上为我们用十进制计算的 策略，那么 我们用于位运算中是不是也合适，我们来举个栗子：</p><p>还是以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；</p><p>第一步：各位相加 但不进位： 101 + 10001 = 10110  不进位的话  结果为 10100 （最后一位两个数都是1，相加的结果需要进位，但是这一位不进位，意味着结果仍然是0）</p><p>第二步： 记下进位，它只在最后一位相加时产生了一个进位。</p><p>第三步： 把前面两个结果相加，得到的结果是 10110.</p><p><strong>那么现在我们把前面的 二进制的加法用位运算来替代的话</strong></p><p>第一步的 求 和 运算就是 不考虑 进位的话，对每一位来相加，0 和0 1 和1 的结果都是0,0+1，或者1+0 的结果 都是1；那么我们会看出它与我们学过的异或运算相同，就是相同为假，不同为真，所以叫 异  或  XOR 。</p><p>第二步： 对0 加 0、1加0、0加1 而言，都不会产生进位，只有1+1 的时候，会产生一个进位。此时 我们可以想象成两个数 先做了一个 位 与 &amp; 运算，然后再向 左移 一位。只有两个数是1 的时候，位与 &amp; 得到的结果是 1，其余的都是0。</p><p>第三步：把前面两个步骤的结果再相加，然后在继续判断是否有进位，直到没有进位为止，那么此时的相加的过程，依然是重复前面的两步，直到不产生进位为止。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Add</span><span class="hljs-params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#第一种代码：循环。简洁但是原理相同，那么我们以下面第二段代码为例；来解析。</span></span><br><span class="line">        <span class="hljs-comment"># while (num2):</span></span><br><span class="line">        <span class="hljs-comment">#     num1, num2 = (num1 ^ num2) &amp; 0xFFFFFFFF, ((num1 &amp; num2) &lt;&lt; 1) &amp; 0xFFFFFFFF</span></span><br><span class="line">        <span class="hljs-comment"># return num1 if num1 &lt;= 0x7FFFFFFF else ~(num1 ^ 0xFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#第二种代码：</span></span><br><span class="line">        <span class="hljs-comment">#首先两个数做 一个 异或 运算^ 那就是 在不进位的情况下，让两个相加 求和。</span></span><br><span class="line">        xorNum = num1 ^ num2</span><br><span class="line">        <span class="hljs-comment">#让两个数 做 位与 操作，然后再向 左 移 一位，得到它 向前进位的值。</span></span><br><span class="line">        andNum = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> andNum != <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#那么我们就继续上面的操作。但是这次的 数值 改为上次的两个结果，</span></span><br><span class="line">            <span class="hljs-comment">#一个 是异或的结果，一个是 与 操作 &amp; 以后 左移一位的 结果。</span></span><br><span class="line">            tmp1 = xorNum ^ andNum</span><br><span class="line">            tmp2 = (xorNum &amp; andNum) &lt;&lt; <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#因为如果这个数为负数的话，那么负数 左移 一位与正数 不同，负数 是数值变小，正数 数值变大</span></span><br><span class="line">            <span class="hljs-comment">#如果是正数的话那么这一步就 不变，如果是负数的话，这一步就对负数来起作用。</span></span><br><span class="line">            <span class="hljs-comment">#对于python来说  负数的 二进制 可能会有无数个1，我们用这个方法让它变成一个可数的数字长度。</span></span><br><span class="line">            tmp1 = tmp1 &amp; <span class="hljs-number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">            xorNum = tmp1</span><br><span class="line">            andNum = tmp2</span><br><span class="line">         <span class="hljs-comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。 0xffffffff </span></span><br><span class="line"><span class="hljs-comment"># ~(xorNum ^ 0xFFFFFFFF)  这个是 异或数  与  模 来 异或，最后 按位 取反 来求得 负数的补码。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> xorNum <span class="hljs-keyword">if</span> xorNum &lt;= <span class="hljs-number">0x7ffffff</span> <span class="hljs-keyword">else</span> ~(xorNum ^ <span class="hljs-number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure><h2 id="21-数组中出现次数超过一半的数字-本题考点-数组"><a href="#21-数组中出现次数超过一半的数字-本题考点-数组" class="headerlink" title="21.数组中出现次数超过一半的数字[^本题考点 数组]"></a>21.数组中出现次数超过一半的数字[^本题考点 数组]</h2><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</strong></p><p>  思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。<br>        首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。</p><p>我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#dict [key] = count</span></span><br><span class="line">        <span class="hljs-comment">#o(n) 空间复杂度为O(n)</span></span><br><span class="line">     <span class="hljs-comment">#第一种思路：建 一个字典，把数字作为键，数字出现的次数作为值，然后 遍历这个数组中的数，如果这个数作为键出现过，那么就让他的值加1，如果没有就把它添加到字典中。</span></span><br><span class="line">        numsCount = &#123;&#125;</span><br><span class="line">        numLen = len(numbers)</span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> numsCount:</span><br><span class="line">                numsCount[num] += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                numsCount[num] = <span class="hljs-number">1</span></span><br><span class="line">             <span class="hljs-comment">#如果说字典中某个键 大于 我们这个数组长度的一半，那么就返回这个键， 数组长度的一半 可以用 &gt;&gt; 1右移以为来实现，右移以为相当于 是除以2.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> numsCount[num] &gt; (numLen &gt;&gt; <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">return</span> num</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#想要空间复杂度为O（1），时间复杂度为o(n)</span></span><br><span class="line"><span class="hljs-comment">#第二种：</span></span><br><span class="line">        <span class="hljs-comment">#定义变量 上次出现的数字为0</span></span><br><span class="line">        last = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#上次出现的数字的数量为0 </span></span><br><span class="line">        lastCount = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment">#遍历数组中的数字</span></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">            <span class="hljs-comment">#如果说这个数字出现的次数为0了。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> lastCount == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-comment">#那么就把上次出现的数字，变为需要保存的那个数字。</span></span><br><span class="line">                last = num</span><br><span class="line">                <span class="hljs-comment">#并把次数设置为1 次，出现了这一次。</span></span><br><span class="line">                lastCount = <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.</span></span><br><span class="line">                <span class="hljs-keyword">if</span> num == last:</span><br><span class="line">                    lastCount += <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-comment">#如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    lastCount -= <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉</span></span><br><span class="line">        <span class="hljs-keyword">if</span> lastCount == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#否则的话，就说明 数组里面 留下了没有抵消掉的数</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-comment">#这种情况是last可能是大于一半的数字</span></span><br><span class="line">            <span class="hljs-comment">#这个时候把 记录数字次数的变量 计数 为0 </span></span><br><span class="line">            lastCount = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment">#遍历数组中的数</span></span><br><span class="line">            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">                <span class="hljs-comment">#如果这个数与我们记录的数相等的话</span></span><br><span class="line">                <span class="hljs-keyword">if</span> num == last:</span><br><span class="line">                    <span class="hljs-comment">#让这个计数加1</span></span><br><span class="line">                    lastCount += <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> lastCount &gt; (len(numbers)&gt;&gt; <span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">return</span> last</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="22-数组中只出现一次的数字-数组"><a href="#22-数组中只出现一次的数字-数组" class="headerlink" title="22.数组中只出现一次的数字[^数组]"></a>22.数组中只出现一次的数字[^数组]</h2><p><strong>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</strong></p><p>思路：其他数字出现的次数都是偶数次，那么我们就可以用到异或的一个性质，那就是 任何一个数字异或它自己都等于0.，也就是说如果我们 从头到尾 异或 数组中的每个数字，那么最终的结果刚好是那个 只出现一次的数字，因为那些成对出现的数字都已经全部抵消掉了。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(self, array)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#如果两个数相同那么两个数的异或操作为0</span></span><br><span class="line">        <span class="hljs-comment">#数组的长度如果小于2，那么就就不会有数字出现了偶数次。</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(array) &lt; <span class="hljs-number">2</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#变量赋值 两个数的异或为none</span></span><br><span class="line">        twoNumXor = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#遍历 数组中的数字</span></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:</span><br><span class="line">            <span class="hljs-comment">#判断 如果 两个数的数字异或的结果为0 的话，</span></span><br><span class="line">            <span class="hljs-keyword">if</span> twoNumXor == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-comment">#那么 此时就让 两个数异或中的一个数 为此时遍历出来的那个数。</span></span><br><span class="line">                twoNumXor = num</span><br><span class="line">            <span class="hljs-comment">#如果数 这个数不为 空 的话</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#那么就让这个 两个数异或的结果的值 （或者当 异或的值为空的时候，我们赋给的值 与 此时遍历数组中的数得到的 num 来异或。</span></span><br><span class="line">                twoNumXor = twoNumXor ^ num</span><br><span class="line">        <span class="hljs-comment">#变量  计数 为 0 </span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#当异或的 结果 为偶数时</span></span><br><span class="line">        <span class="hljs-keyword">while</span> twoNumXor % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> :</span><br><span class="line">            <span class="hljs-comment">#那么我们就给它 除以2 ，每除一次2 就记录一次，直到 结果不为 奇数 为止。</span></span><br><span class="line">            twoNumXor  = twoNumXor &gt;&gt; <span class="hljs-number">1</span>  <span class="hljs-comment"># 右移以为 相当于 除以2</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#以上是用来计数  判断 这个 二进制数中 第一个1 是在哪一位上。</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">#我们在这个结果中 找到 第一个为1 的位的位置，记为 第 n 位，那么 现在我们以第n 位 是不是 1</span></span><br><span class="line">        </span><br><span class="line">        mask = <span class="hljs-number">1</span> &lt;&lt; count   <span class="hljs-comment">#向左 移 位 count 位。</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">#为标准 把原 数组中的数字分成两个子数组，第一个数组中每个数字的第n 位 都是1，而 第 二个子 数组中的 每个数字的第 n 位 都是 0.由于我们的分配的标准是 数字中的某一位是0 还是1 ，那么数字相同的数肯定被分到了 同一组，那么每个 子数组中 都会包含一个 只 出现一次的数字，而 其他数字都出现了两次，这个时候，分别把 子数组中的 所有的数 异或，那么 最后的结果 就是 那个 出现一次的数。</span></span><br><span class="line">        </span><br><span class="line">        firstNum = <span class="hljs-literal">None</span></span><br><span class="line">        secondNum = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:</span><br><span class="line">            <span class="hljs-keyword">if</span> mask &amp; num == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> firstNum == <span class="hljs-literal">None</span>:</span><br><span class="line">                    firstNum = num</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    firstNum = firstNum ^ num</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> secondNum == <span class="hljs-literal">None</span>:</span><br><span class="line">                    secondNum = num</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    secondNum = secondNum ^ num</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> firstNum,secondNum</span><br></pre></td></tr></table></figure><hr><h2 id="23-整数中1出现的次数-本题考点-数组"><a href="#23-整数中1出现的次数-本题考点-数组" class="headerlink" title="23.整数中1出现的次数[^本题考点 数组]"></a>23.整数中1出现的次数[^本题考点 数组]</h2><p><strong>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</strong></p><p> <img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/zhengshu.png" alt></p><hr><p>如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历 计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。</p><p>那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。</p><p><strong>若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ </strong></p><p>​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有</p><p><code>0-3458</code> 个数 那么就一共是 3459 中可能性。</p><p>​    <strong>那么十万位 后面 出现1 的情况有多少种 可能性 ？</strong></p><p>​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 <code>10^5</code>. </p><p>那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。</p><p>​    <strong>接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？</strong></p><p>如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共<code>34591</code>种情况，后面 是一共 4 位，那么就有        <code>10^4</code>种情况。</p><p>那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。</p><p>​    <strong>我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？</strong></p><p>如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是</p><p>3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有</p><p>3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。</p><p>分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(self, n)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-comment">#循环的出口是 highValue = 0</span></span><br><span class="line">        <span class="hljs-comment">#我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。</span></span><br><span class="line">        <span class="hljs-comment"># 一开始 精准度为1.高位低位中位 先赋值为1.</span></span><br><span class="line">        preceise = <span class="hljs-number">1</span></span><br><span class="line">        highValue = <span class="hljs-number">1</span></span><br><span class="line">        lowValue = <span class="hljs-number">1</span></span><br><span class="line">        midValue =<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#计数 后面的位数。</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#计数 1 的次数和</span></span><br><span class="line">        sumNum = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> highValue != <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-comment">#高位 先将这个数 除以10 得到高位</span></span><br><span class="line">            highValue = n // (preceise * <span class="hljs-number">10</span>)</span><br><span class="line">            <span class="hljs-comment">#中位 先将这个数  与 10 取余。</span></span><br><span class="line">            midValue = (n // preceise)%<span class="hljs-number">10</span></span><br><span class="line">            <span class="hljs-comment">#低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.</span></span><br><span class="line">            lowValue = n % preceise</span><br><span class="line">            <span class="hljs-comment">#每遍历一次 向右移一位，那么就是说 精准度要乘以10.</span></span><br><span class="line">            preceise *= <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-comment">#如果这个数是0 的话，</span></span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">if</span> midValue == <span class="hljs-number">0</span>:</span><br><span class="line">                <span class="hljs-comment">#那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，</span></span><br><span class="line">                num = (highValue)* pow(<span class="hljs-number">10</span>,count)</span><br><span class="line">            <span class="hljs-comment">#如果这个数 大于1 的话，</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> midValue &gt; <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-comment">#那么它 就是 最高位加1 乘以 10^后面的位数 次方，</span></span><br><span class="line">                num = (highValue+<span class="hljs-number">1</span>)*pow(<span class="hljs-number">10</span>,count)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-comment">#否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。</span></span><br><span class="line">                num = highValue*pow(<span class="hljs-number">10</span>,count)+(lowValue+<span class="hljs-number">1</span>)</span><br><span class="line">            <span class="hljs-comment">#最后 我们1 出现的 次数 就是这 三个 num 的和，。</span></span><br><span class="line">            sumNum += num</span><br><span class="line">            <span class="hljs-comment">#没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-comment">#最后返回这个  次数和。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> sumNum</span><br></pre></td></tr></table></figure><hr><h2 id="24-丑数"><a href="#24-丑数" class="headerlink" title="24.丑数"></a>24.丑数</h2><p><strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p><p>思路分析 第一种方法：所谓的一个数n 的因子，是指 n 能被m 整除，也就是 n%m == 0； 根据丑数 的定义，丑数只能被 2,3,5 整除，也就是说，如果一个数能被2 整除，能被3 整除，能被5 整除，如果最后的到的数是1.那么这个数就是丑数，否则就不是。 先搞清楚丑数的定义是什么？</p><p>因此按照这个思路我们就可以 写出下面的 代码。但是 这个代码 是逐个判断的每个整数是不是丑数的解法，它直观，但是不够高效，最大的问题是 一个不是丑数的数，我必须要计算 而且判断它是不是丑数。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(self, index)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#死循环，找丑数</span></span><br><span class="line">        <span class="hljs-comment">#判断一个数是不是丑数，先循环除以2，直到不能整除，</span></span><br><span class="line">        <span class="hljs-comment">#循环除以3 直到不能整除，循环除以5 直到不能整除</span></span><br><span class="line">        <span class="hljs-comment">#这时如果剩余的值是1  我们就说它是丑数</span></span><br><span class="line">        <span class="hljs-comment">#其他情况就都不是丑数</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isUglyNumber</span><span class="hljs-params">(num)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">3</span></span><br><span class="line">            <span class="hljs-keyword">while</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:</span><br><span class="line">                num = num //<span class="hljs-number">5</span></span><br><span class="line">            <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        count = <span class="hljs-number">0</span></span><br><span class="line">        num = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> isUglyNumber(num):</span><br><span class="line">                count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> count == index:</span><br><span class="line">                <span class="hljs-keyword">return</span> num</span><br><span class="line">            num += <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><p>第二种方法分析:</p><p>我们可以保存已经找到的丑数，然后 用空间环时间 来 找出丑数。</p><p>如何用空间换时间？</p><p>我们找一种，只需要计算丑数的办法,根据上面丑数的定义，我们可以知道，丑数应该是另一个丑数 乘以 2,3，或者5 的结果（1除外）。因此我们 可以创建一个 列表，里面的数字是排好序的 丑数，每个丑数都是前面的丑数乘以2,3，或者5得到的。</p><p>那么我们就可以在一个列表中，给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，第一个丑数为1，那么我们在这个列表的起始位置 设置三个指针，这三个指针代表的值  分别为2,3,5.又由于这个列表中的所有的丑数 是有序的，从小到大排列的，那么我们在每次 给一个丑数 乘以 2,3,5 以后要与前面的丑数比较大小，然后在根据大小值 来放入列表中。由于一开始第一个丑数是1，那么 1 <em> 2 得到的是2,1</em>3 得到的是3，1 乘以5 得到的是5，那么三个数中比较大小，最小的是 1 乘以2，那么 肯定第一个先放置的是2，然后是 2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，以此类推，那么现在的到的丑数的顺序就是1,2,3,4.。。。。。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(self, index)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#首先判断  要找的 丑数 是不是第0个 或者是负数，如果是的话，那么就返回0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index &lt;= <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#然后判断要找的丑数 是不是第一个，如果是第一个，那么就返回1.</span></span><br><span class="line">        <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#在丑数 这个列表中 给出第一个丑数是1</span></span><br><span class="line">        numbers = [<span class="hljs-number">1</span>]</span><br><span class="line">        <span class="hljs-comment">#在列表的 一开始  设置三个 指针，也就是 三个指针的 索引位置是0，</span></span><br><span class="line">        two, three, five = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment">#丑数的个数 起始为 1</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#循环 当丑数的个数不等于我们要找到 那第 index 个 丑数时，就循环，等于的时候就跳出循环。</span></span><br><span class="line">        <span class="hljs-keyword">while</span> count != index :</span><br><span class="line">            <span class="hljs-comment">#给列表中的 2,3,5 这三个指针所在位置的 丑数 分别 乘以2,3,5</span></span><br><span class="line">            n2, n3, n5 = numbers[two] * <span class="hljs-number">2</span>, numbers[three] * <span class="hljs-number">3</span>, numbers[five] * <span class="hljs-number">5</span></span><br><span class="line">            <span class="hljs-comment">#比较这三个丑数的大小</span></span><br><span class="line">            minValue = min(n2, n3, n5)</span><br><span class="line">            <span class="hljs-comment">#在丑数列表中，把三个中最小的那个 放进去。</span></span><br><span class="line">            numbers.append(minValue)</span><br><span class="line">            <span class="hljs-comment">#每放进去一个，丑数的数量就加1</span></span><br><span class="line">            count += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n2:</span><br><span class="line">                two += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果是 3 那个指针的话，那么3 这个指针就移一位。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n3:</span><br><span class="line">                three += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#如果是 5 那个指针的话，那么5这个指针就移一位。</span></span><br><span class="line">            <span class="hljs-keyword">if</span> minValue == n5:</span><br><span class="line">                five += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#最后输出这个丑数列表中的 最后一位，那么就是我们的计数的丑数的个数 -1，就是最后一个丑数的索引值。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> numbers[count<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="树的知识点："><a href="#树的知识点：" class="headerlink" title="树的知识点："></a>树的知识点：</h4><h5 id="什么叫做树？"><a href="#什么叫做树？" class="headerlink" title="什么叫做树？"></a>什么叫做树？</h5><p><strong>树状图</strong>是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">数据结构</a>，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88" target="_blank" rel="noopener">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><p>每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；</p><p>叶节点没有子节点，根节点没有父节点。</p><h5 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h5><p>每个节点最多含有两个子树的树称为二叉树。下图就是一个二叉树。</p><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点</p><p><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/ercha.png" alt></p><h5 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h5><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，<a href="https://baike.baidu.com/item/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">树的遍历</a>实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p><p>设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">treeNode</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="hljs-literal">None</span></span><br><span class="line">        self.right = <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#1. 深度优先</span></span><br><span class="line"><span class="hljs-comment">#2. 广度优先</span></span><br><span class="line"><span class="hljs-comment">#对于深度优先来说：</span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">1 先序遍历  先打印根 1,2,4,5,3,6,8,7</span></span><br><span class="line"><span class="hljs-string">2 中序遍历  先打印左侧的叶子节点 4，再输出 中节点  2 ；  4 2 5 1 6 8 3 7 </span></span><br><span class="line"><span class="hljs-string">3 先序遍历  输出顺序  4 5 2 8 6 7 3 1</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">注意：  先序   中序 后序  都是对应于根节点来说的，左右节点都是先左后右</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment">#递归</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    print(root.val)</span><br><span class="line">    preOrderRecusive(root.left)</span><br><span class="line">    preOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">midOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">    midOrderRecusive(root.left)</span><br><span class="line">    print(root.val)</span><br><span class="line">    midOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laterOrderRecusive</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">    laterOrderRecusive(root.left)</span><br><span class="line">    laterOrderRecusive(root.right)</span><br><span class="line">    print(root.val)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#非递归的形式 去遍历数</span></span><br><span class="line"><span class="hljs-comment">#递归和循环是可以互相转换的</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">1 先根遍历 先访问根节点，再访问左子节点，最后访问右子节点</span></span><br><span class="line"><span class="hljs-string">2 中根遍历 先访问左子节点，再访问根节点，最后访问右子节点</span></span><br><span class="line"><span class="hljs-string">3 后跟遍历 先访问左子节点，再访问右子节点，最后访问根节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line">            print(tmpNode.val)</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node  = stack.pop()</span><br><span class="line">        tmpNode = node.right</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line"></span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node  = stack.pop()</span><br><span class="line">        print(node.val)</span><br><span class="line">        tmpNode = node.right</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">laterOrder</span><span class="hljs-params">(root)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    tmpNode = root</span><br><span class="line">    <span class="hljs-keyword">while</span> tmpNode <span class="hljs-keyword">or</span> stack :</span><br><span class="line">        <span class="hljs-keyword">while</span> tmpNode:</span><br><span class="line">            stack.append(tmpNode)</span><br><span class="line">            tmpNode = tmpNode.left</span><br><span class="line">        node = stack[<span class="hljs-number">-1</span>]</span><br><span class="line">        tmpNode = node.right</span><br><span class="line">        <span class="hljs-keyword">if</span> node.right == <span class="hljs-literal">None</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            print(node.val)</span><br><span class="line">            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> node == stack[<span class="hljs-number">-1</span>].right:</span><br><span class="line">                node =  stack.pop()</span><br><span class="line">                print(node.val)</span><br></pre></td></tr></table></figure><h2 id="25-重建二叉树"><a href="#25-重建二叉树" class="headerlink" title="25.重建二叉树"></a>25.重建二叉树</h2><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> tin:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(pre) != len(tin):</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment"># 取出pre 的第一个值  就是根节点</span></span><br><span class="line">        root = pre[<span class="hljs-number">0</span>]</span><br><span class="line">        rootNode = TreeNode(root)</span><br><span class="line">        <span class="hljs-comment"># 找到在 tin  中序遍历中的根节点 所在的索引位置</span></span><br><span class="line">        pos = tin.index(root)</span><br><span class="line">        <span class="hljs-comment"># 中序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        tinLeft = tin[<span class="hljs-number">0</span>:pos]</span><br><span class="line">        tinRight = tin[pos + <span class="hljs-number">1</span>:]</span><br><span class="line">        <span class="hljs-comment"># 前序遍历的 列表的左右节点 分开 切片 成两个列表</span></span><br><span class="line">        preLeft = pre[<span class="hljs-number">1</span>:pos + <span class="hljs-number">1</span>]</span><br><span class="line">        preRight = pre[pos + <span class="hljs-number">1</span>:]</span><br><span class="line"></span><br><span class="line">        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        rightNode = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line"></span><br><span class="line">        rootNode.left = leftNode</span><br><span class="line">        rootNode.right = rightNode</span><br><span class="line">        <span class="hljs-keyword">return</span> rootNode</span><br></pre></td></tr></table></figure><hr><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasEqual</span><span class="hljs-params">(pRoot1, pRoot2)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                <span class="hljs-keyword">if</span> pRoot2.left == <span class="hljs-literal">None</span>:</span><br><span class="line">                    leftEqual = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    leftEqual = hasEqual(pRoot1.left, pRoot2.left)</span><br><span class="line">                <span class="hljs-keyword">if</span> pRoot2.right == <span class="hljs-literal">None</span>:</span><br><span class="line">                    rightEqual = <span class="hljs-literal">True</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    rightEqual = hasEqual(pRoot1.right, pRoot2.right)</span><br><span class="line">                <span class="hljs-keyword">return</span> leftEqual <span class="hljs-keyword">and</span> rightEqual</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">            ret = hasEqual(pRoot1, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> ret:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">if</span> ret:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">对于Python这道题，有些地方需要仔细考虑的。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">先说下算法实现思路：对于两棵二叉树来说，要判断B是不是A的子结构，首先第一步在树A中查找与B根节点的值一样的节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">通常对于查找树中某一个节点，我们都是采用递归的方法来遍历整棵树。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">第二步就是判断树A中以R为根节点的子树是不是和树B具有相同的结构。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">这里同样利用到了递归的方法，如果节点R的值和树的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">如果它们值是相同的，则递归的判断各自的左右节点的值是不是相同。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">递归的终止条件是我们达到了树A或者树B的叶节点。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">有地方要重点注意，DoesTree1haveTree2()函数中的两个 if 判断语句 不能颠倒顺序 。</span></span><br><span class="line"><span class="hljs-string">因为如果颠倒了顺序，会先判断pRoot1 是否为None, 其实这个时候，pRoot1 的节点已经遍历完成确认相等了，但是这个时候会返回 False，判断错误。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">有同学不相信的，可以去试试换个顺序，肯定不能AC。同时这个也是《剑指offer》书上没有写的，希望能引起大家的注意。</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        result = <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1 != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> pRoot2 != <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                result = self.DoesTree1haveTree2(pRoot1, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:</span><br><span class="line">                result = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:</span><br><span class="line">                result = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br><span class="line">    <span class="hljs-comment"># 用于递归判断树的每个节点是否相同</span></span><br><span class="line">    <span class="hljs-comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></span><br><span class="line">    <span class="hljs-comment"># 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DoesTree1haveTree2</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot2 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1 == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) <span class="hljs-keyword">and</span> self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure><hr><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><code>输入描述:</code></h5><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">        <span class="hljs-number">8</span></span><br><span class="line">       /  \</span><br><span class="line">      <span class="hljs-number">6</span>   <span class="hljs-number">10</span></span><br><span class="line">     / \  / \</span><br><span class="line">    <span class="hljs-number">5</span>  <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span></span><br><span class="line">    镜像二叉树</span><br><span class="line">        <span class="hljs-number">8</span></span><br><span class="line">       /  \</span><br><span class="line">      <span class="hljs-number">10</span>   <span class="hljs-number">6</span></span><br><span class="line">     / \  / \</span><br><span class="line">    <span class="hljs-number">11</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span>  <span class="hljs-number">5</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(self, root)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-comment">#处理根节点</span></span><br><span class="line">        root.left,root.right = root.right,root.left</span><br><span class="line">        self.Mirror(root.left)</span><br><span class="line">        self.Mirror(root.right)</span><br></pre></td></tr></table></figure><hr><h2 id="28-从上往下打印二叉树"><a href="#28-从上往下打印二叉树" class="headerlink" title="28.从上往下打印二叉树"></a>28.从上往下打印二叉树</h2><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(self, root)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line">        treeNodeTmp = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="hljs-keyword">while</span> treeNodeTmp:</span><br><span class="line">            tmpNode = treeNodeTmp[<span class="hljs-number">0</span>]</span><br><span class="line">            ret.append(tmpNode.val)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left:</span><br><span class="line">                treeNodeTmp.append(tmpNode.left)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.right:</span><br><span class="line">                treeNodeTmp.append(tmpNode.right)</span><br><span class="line">            <span class="hljs-keyword">del</span> treeNodeTmp[<span class="hljs-number">0</span>]</span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br></pre></td></tr></table></figure><hr><h2 id="29-二叉搜索树的后序遍历序列"><a href="#29-二叉搜索树的后序遍历序列" class="headerlink" title="29.二叉搜索树的后序遍历序列"></a>29.二叉搜索树的后序遍历序列</h2><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">python:后序遍历 的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，后面用递归分别判断前后两部分 是否 符合以上原则</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> len(sequence)==<span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        length=len(sequence)</span><br><span class="line">        root=sequence[length<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># 在二叉搜索 树中 左子树节点小于根节点</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length):</span><br><span class="line">            <span class="hljs-keyword">if</span> sequence[i]&gt;root:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-comment"># 二叉搜索树中右子树的节点都大于根节点</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j  <span class="hljs-keyword">in</span> range(i,length):</span><br><span class="line">            <span class="hljs-keyword">if</span> sequence[j]&lt;root:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-comment"># 判断左子树是否为二叉树</span></span><br><span class="line">        left=<span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span>  i&gt;<span class="hljs-number">0</span>:</span><br><span class="line">            left=self.VerifySquenceOfBST(sequence[<span class="hljs-number">0</span>:i])</span><br><span class="line">        <span class="hljs-comment"># 判断 右子树是否为二叉树</span></span><br><span class="line">        right=<span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">if</span> i&lt;length<span class="hljs-number">-1</span>:</span><br><span class="line">            right=self.VerifySquenceOfBST(sequence[i:<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-keyword">return</span> left <span class="hljs-keyword">and</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence == []:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        rootNum = sequence[<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">del</span> sequence[<span class="hljs-number">-1</span>]</span><br><span class="line">        index = <span class="hljs-literal">None</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(sequence)):</span><br><span class="line">            <span class="hljs-keyword">if</span> index == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> sequence[i] &gt; rootNum:</span><br><span class="line">                index = i</span><br><span class="line">            <span class="hljs-keyword">if</span> index != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> sequence[i] &lt; rootNum:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">if</span> sequence[:index] == []:</span><br><span class="line">            leftRet = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            leftRet = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        <span class="hljs-keyword">if</span> sequence[index:] == []:</span><br><span class="line">            rightRet = <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            rightRet = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> leftRet <span class="hljs-keyword">and</span> rightRet</span><br></pre></td></tr></table></figure><hr><h2 id="30-二叉树中和为某一值的路径"><a href="#30-二叉树中和为某一值的路径" class="headerlink" title="30.二叉树中和为某一值的路径"></a>30.二叉树中和为某一值的路径</h2><p><strong>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">递归先序遍历树， 把结点加入路径。</span></span><br><span class="line"><span class="hljs-string">若该结点是叶子结点则比较当前路径和是否等于期待和。</span></span><br><span class="line"><span class="hljs-string">弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点</span></span><br><span class="line"><span class="hljs-string"></span></span><br><span class="line"><span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        support = [root]</span><br><span class="line">        supportArrayList = [[root.val]]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">while</span> support:</span><br><span class="line">            tmpNode = support[<span class="hljs-number">0</span>]</span><br><span class="line">            tmpArrayList = supportArrayList[<span class="hljs-number">0</span>]</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> tmpNode.right == <span class="hljs-literal">None</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> sum(tmpArrayList) == expectNumber:</span><br><span class="line">                    ret.insert(<span class="hljs-number">0</span>, tmpArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.left:</span><br><span class="line">                support.append(tmpNode.left)</span><br><span class="line">                newTmpArrayList = copy.copy(tmpArrayList)</span><br><span class="line">                newTmpArrayList.append(tmpNode.left.val)</span><br><span class="line">                supportArrayList.append(newTmpArrayList)</span><br><span class="line">            <span class="hljs-keyword">if</span> tmpNode.right:</span><br><span class="line">                support.append(tmpNode.right)</span><br><span class="line">                newTmpArrayList = copy.copy(tmpArrayList)</span><br><span class="line">                newTmpArrayList.append(tmpNode.right.val)</span><br><span class="line">                supportArrayList.append(newTmpArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">del</span> supportArrayList[<span class="hljs-number">0</span>]</span><br><span class="line">            <span class="hljs-keyword">del</span> support[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:</span><br><span class="line">            <span class="hljs-keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPathMain</span><span class="hljs-params">(root, path, currentSum)</span>:</span></span><br><span class="line">            currentSum += root.val</span><br><span class="line"></span><br><span class="line">            path.append(root)</span><br><span class="line">            isLeaf = root.left == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right == <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> currentSum == expectNumber <span class="hljs-keyword">and</span> isLeaf:</span><br><span class="line">                onePath = []</span><br><span class="line">                <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> path:</span><br><span class="line">                    onePath.append(node.val)</span><br><span class="line">                result.append(onePath)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> currentSum &lt; expectNumber:</span><br><span class="line">                <span class="hljs-keyword">if</span> root.left:</span><br><span class="line">                    FindPathMain(root.left, path, currentSum)</span><br><span class="line">                <span class="hljs-keyword">if</span> root.right:</span><br><span class="line">                    FindPathMain(root.right, path, currentSum)</span><br><span class="line"></span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        FindPathMain(root, [], <span class="hljs-number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h2 id="31-二叉搜索树与双向链表"><a href="#31-二叉搜索树与双向链表" class="headerlink" title="31.二叉搜索树与双向链表"></a>31.二叉搜索树与双向链表</h2><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># class TreeNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.left = None</span></span><br><span class="line"><span class="hljs-comment">#         self.right = None</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Convert</span><span class="hljs-params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># write code here</span></span><br><span class="line">        <span class="hljs-keyword">if</span> pRootOfTree == <span class="hljs-literal">None</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_right</span><span class="hljs-params">(node)</span>:</span></span><br><span class="line">            <span class="hljs-keyword">while</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="hljs-keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        leftNode = self.Convert(pRootOfTree.left)</span><br><span class="line">        rightNode = self.Convert(pRootOfTree.right)</span><br><span class="line"></span><br><span class="line">        retNode = leftNode</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> leftNode:</span><br><span class="line">            leftNode = find_right(leftNode)</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            retNode = pRootOfTree</span><br><span class="line"></span><br><span class="line">        pRootOfTree.left = leftNode</span><br><span class="line">        pRootOfTree.right = rightNode</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">None</span>:</span><br><span class="line">            leftNode.right = pRootOfTree</span><br><span class="line">        <span class="hljs-keyword">if</span> rightNode != <span class="hljs-literal">None</span>:</span><br><span class="line">            rightNode.left = pRootOfTree</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> retNode</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详细地分析剑指offer1-31题的解题思路，代码及代码注释。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://www.cygao.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="http://www.cygao.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="刷题笔记" scheme="http://www.cygao.xyz/tags/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>markdown格式编写</title>
    <link href="http://www.cygao.xyz/2019/06/08/Joint/"/>
    <id>http://www.cygao.xyz/2019/06/08/Joint/</id>
    <published>2019-06-08T07:30:28.000Z</published>
    <updated>2019-08-29T13:42:07.019Z</updated>
    
    <content type="html"><![CDATA[<p>一些简易的格式备忘录<br><a id="more"></a></p><h1 id="markdown格式编写"><a href="#markdown格式编写" class="headerlink" title="markdown格式编写"></a>markdown格式编写</h1><h2 id="第一个标题"><a href="#第一个标题" class="headerlink" title="第一个标题"></a>第一个标题</h2><p>段落1 中间空一行</p><p>段落2</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote><p>使用“&gt;”和空格高亮</p><p>这是一段段落高亮</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="www.baidu.com">百度</a>  利用中括号小括号的格式</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="http://image.baidu.com/search/detail?ct=503316480&amp;z=undefined&amp;tn=baiduimagedetail&amp;ipn=d&amp;word=robomaster%E7%9B%B4%E6%92%AD&amp;step_word=&amp;ie=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;hd=undefined&amp;latest=undefined&amp;copyright=undefined&amp;cs=3125832727,3597497147&amp;os=1898171743,3878211660&amp;simid=3369673952,459146154&amp;pn=1&amp;rn=1&amp;di=20790&amp;ln=361&amp;fr=&amp;fmq=1565251372619_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=undefined&amp;height=undefined&amp;face=undefined&amp;is=0,0&amp;istype=0&amp;ist=&amp;jit=&amp;bdtype=0&amp;spn=0&amp;pi=0&amp;gsm=0&amp;objurl=http%3A%2F%2Fi.dyt8.cc%2F66%2Fab%2F0a%2Ff1%2F38%2F38%2F4d%2Fe5%2Fa2%2Fd2%2F4d%2F0d%2Fb8%2Fc7%2F62%2Ffb.jpg&amp;rpstart=0&amp;rpnum=0&amp;adpicid=0&amp;force=undefined" alt="风景"> 超链接前面+!</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>1</li><li>1</li><li>1 “*”</li></ul><ul><li>2</li><li>2</li><li>2 “-“</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>“1.”<br>2.<br>3.</li></ol><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><hr><p>“ *或是-” 大于3个</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些简易的格式备忘录&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【Person Search】 RCAA Relational Context-Aware Agents for Person Search</title>
    <link href="http://www.cygao.xyz/2018/12/09/RCAA%20Relational%20Context%20Aware%20Agents%20for%20Person%20Search/"/>
    <id>http://www.cygao.xyz/2018/12/09/RCAA Relational Context Aware Agents for Person Search/</id>
    <published>2018-12-09T10:27:11.000Z</published>
    <updated>2019-09-02T01:52:56.673Z</updated>
    
    <content type="html"><![CDATA[<p>论文：RCAA Relational Context-Aware Agents for Person Search<br>链接：<a href="http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html</a><br>代码地址：没有公开<br><a id="more"></a></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在本文中，我们通过训练relational context-aware agents来解决这个问题，这些agens从整个场景图像库中学习定位目标人物的操作。我们将相关的空间和时间上下文合并到框架中。具体地说，我们建议在依赖查询的关系网络中使用目标人员作为查询。agent通过同时考虑局部的视觉信息、关系上下文和时间上下文，以及目标人员，确定在每个时间步上要采取的最佳操作。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>时空背景可能会提供额外的重要信息，但对人的搜索仍然不够深入。空间语境已被证明在回答视觉问题等任务中是有用的。在整个场景图像中，目标人物依赖的物体之间的空间关系可能有助于更有辨别力的表示。此外，序列决策在目标检测中的成功应用也为人的识别提供了借鉴。多步推理的agent可以更好地定位目标人，同时考虑到目标人的时间行为和状态记忆。在这项工作中，我们提出了一个自顶向下的搜索策略，由一个时空上下文感知的代理提供支持，以解决上面讨论的限制和机会。具体地说，考虑到整个场景、它的本地图像特性和查询图像，我们利用一个依赖于目标-人的关系网络来提取对象之间的空间上下文。然后，我们的深度强化学习代理根据空间上下文及其时间动作和状态记忆，在每一个时间步选择最佳动作，以缩小目标人物的精确位置。整个框架不包含人员建议计算，并且是端到端可培训的。</p><p>贡献：    </p><ol><li>我们最早尝试将人的搜索问题作为一个决策过程来解决，并构建了第一个基于深度强化学习的人的搜索框架。</li><li>该模型采用端到端方式进行训练，不需要进行冗余和噪声的proposal Scomputing。有趣的是，我们的模型甚至比负载完美的proposal detector方法性能更好。</li><li>我们在训练过程中加入了相关的时空背景，从而引导模型产生更多的信息“经验”。 </li></ol><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><ul><li>Person re-id<br>pass  </li><li>pedestrian detection<br>pass    </li><li>Deep Reinforcement Learning<br>文献中讨论了两种广泛使用的DRL方法——Deep QNetworks(DQN)和策略policy gradient，具体的看论文吧。</li></ul><h1 id="3-Relational-Context-Aware-Agents"><a href="#3-Relational-Context-Aware-Agents" class="headerlink" title="3. Relational Context-Aware Agents"></a>3. Relational Context-Aware Agents</h1><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h2><p>行人搜索解决了从整个场景图像库中寻找目标人物的精确位置的问题。系统通过时空上下文感知agent确定的顺序操作动态定位目标行人。我们的代理接受空间和时间上下文、本地图像特征和查询图像作为输入，并预测要采取的最佳操作。通过预测动作将包围框从当前状态转换为下一个状态，并从下一个状态预测下一个动作。这个过程不断重复，直到达到最优结果。<div align="center"><br><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/RCAA1.png" alt></div></p><h2 id="3-2-Relational-Decision-Making"><a href="#3-2-Relational-Decision-Making" class="headerlink" title="3.2 Relational Decision Making"></a>3.2 Relational Decision Making</h2><p>该模型遵循马尔可夫决策过程(MDP)，适用于序列决策过程的建模。</p><ul><li>Action 存在移动，扩张和裁剪共14个操作。<div align="center"><br><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/RCAA2.png" alt></div></li><li>State</li><li>Reward<br>这个具体看懂得有一些强化学习得知识和MDP的相关知识。 <h2 id="3-3-Network-Structure"><a href="#3-3-Network-Structure" class="headerlink" title="3.3 Network Structure"></a>3.3 Network Structure</h2>我们使用ResNet-50进行特征提取，因为它在人的识别方面显示了极大的优越性。为了编码关系上下文信息，我们结合了一个关系网络(RN)，上文所述，来考虑图像中所有对对象之间的所有关系。  <h2 id="3-4-Training"><a href="#3-4-Training" class="headerlink" title="3.4 Training"></a>3.4 Training</h2>为了避免次优解决方案，我们使用了actor-critic (A3C) method，它在环境的多个实例上异步并行地执行多个agents。我们使用ADAM optimizer训练模型，中间还介绍了强化学习的损失函数和训练策略，不太懂不展开了。<h1 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h1></li></ul><p>相当高的表现，在两个数据集上，表现见下图，即使放在19年也是很有竞争力的表现了。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/RCAA3.png" alt></div><br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/RCAA4.png" alt></div><br><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/RCAA5.png" alt></div>   <h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文首先尝试解决人的搜索问题，建立了第一个基于深度强化学习的人的搜索框架。与以往依赖proposal learning的工作不同，我们的方法利用了关系上下文信息，并在联合框架中预先利用视觉信息和query。<br>在未来，我们计划在我们的框架中使用宽松的学习lenient learning，因为存储的转换可能会因为agents并行更新它们各自的策略而过时。</p><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>有点复杂的论文，需要有强化学习和一些机器学习的基础，与众多的利用以Faster R-CNN为行人检测器的论文不同，还有以前用proposal learning的传统检测器。总感觉和我之前认知的Person Search有些不同。</p><ul><li><p>我的理解包括跑的一些Person Search的代码：Testing的时候，query和gallery的图像是分批次进入的，query的特征和再和所有gallery检测出的行人特征（也是通过检测后的行人包围框的特征），进行特征对比（比如用余弦相似度或是欧式距离等等），如果detction时候没有检测出iou&gt;0.5的包围框，再怎么query对比都没意义。</p></li><li><p>这篇RCAA，看文章模型的structure，<strong>Our agent accepts the spatial and temporal context, the local image feature and the query image as input</strong>,<strong>When the training is finished, we fix the policy and value network for testing. A single agent is used to process each query for testing. For each query, we rank all the value V and retrieve the top ranked results.</strong> 看的像是test的时候同时可以输入query引导detectoring的过程，和之前的方法推理过程有点不太一样。如果有研究person search的同学可以评论一下，和我交流。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：RCAA Relational Context-Aware Agents for Person Search&lt;br&gt;链接：&lt;a href=&quot;http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://openaccess.thecvf.com/content_ECCV_2018/html/Xiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.html&lt;/a&gt;&lt;br&gt;代码地址：没有公开&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="行人搜索" scheme="http://www.cygao.xyz/categories/%E8%A1%8C%E4%BA%BA%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Person Search】 Person Search by Multi-Scale Matching</title>
    <link href="http://www.cygao.xyz/2018/11/28/Person%20Search%20by%20Multi-Scale%20Matching/"/>
    <id>http://www.cygao.xyz/2018/11/28/Person Search by Multi-Scale Matching/</id>
    <published>2018-11-28T03:23:45.000Z</published>
    <updated>2019-09-02T01:52:07.053Z</updated>
    
    <content type="html"><![CDATA[<p>论文：Person Search by Multi-Scale Matching<br>链接：<a href="http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html</a><br>代码地址：没有公开<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=863970833&auto=0&height=66"></iframe><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>研究了无约束场景图像中的人搜索问题。现有的检测方法多侧重于提高人的检测精度，以减轻自动检测噪声引起的配准误差、误检等带来的负面影响。与以往的研究相比，我们发现，通过改进现有的深度学习对象检测器(如Fast R-CNN)，可以实现足够的可重复责任人实例裁剪，而在人员搜索中尚未得到充分研究的多尺度匹配问题是一个更为严重的障碍。在这项工作中，我们提出了一种跨层次语义对齐(CLSA)的深度学习方法，能够在统一的端到端模型中学习更具鉴别性的身份特征表示，从而解决了这个多尺度的人搜索挑战。这是通过利用深度神经网络的网络内特征金字塔结构来实现的。这很好地消除了构建计算开销昂贵的图像金字塔和复杂的多分支网络体系结构的需要。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>行人搜索处理原始的未细化的检测与许多错误裁剪和未知程度的错位。这就产生了一个更具挑战性的匹配问题，尤其是在人的重新识别过程中。此外，自动检测的人员框通常在规模(分辨率)上比常规的差异更大。由于人与摄像机之间固有的无法控制的距离(图1(a))。因此，它本质上是一个多尺度匹配问题。然而，这一问题目前在人员搜索中研究不足。</p><p>贡献：    </p><ol><li>我们确定了人搜索中的多尺度匹配问题，这是文献中缺少的一个元素，但发现它对提高模型性能具有重要意义。</li><li>我们提出了一个跨层次语义对齐(CLSA)的深度学习方法来解决多尺度匹配的挑战。这是基于学习一个端到端的网络内特征金字塔表示，具有较强的鲁棒性，以应对可变尺度的自动检测人的边界框。</li><li>我们改进了Faster R-CNN模型，在不受控制的场景中实现更可靠的行人定位，从而提高了整体搜索性能。以及用实验证明了这一点。<div align="center"><br><img src="https://picture-1259281112.cos.ap-shanghai.myqcloud.com/CLSA1.png" alt></div>  </li></ol><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><ul><li>Person search<br>pass  </li><li>pedestrian detection<br>pass    </li></ul><h1 id="3-Cross-Level-Semantic-Alignment-for-Person-Search"><a href="#3-Cross-Level-Semantic-Alignment-for-Person-Search" class="headerlink" title="3. Cross-Level Semantic Alignment for Person Search"></a>3. Cross-Level Semantic Alignment for Person Search</h1><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/CLSA2.png" alt><br></div>  <h2 id="3-1-Person-Detection"><a href="#3-1-Person-Detection" class="headerlink" title="3.1 Person Detection"></a>3.1 Person Detection</h2><p>进一步提高检测性能和效率,我们介绍一些设计改进原模型。</p><ol><li>不是使用传统的RoI的利益(地区)池层,我们该地区农作物和调整功能映射到14×14像素,并进一步最大池他们7×7获得更好的效率</li><li>在ImageNet-1K上对backbone ResNet-50网络进行预训练后，我们将第一个构建块(前4层)固定在目标人物搜索数据的微调中。这允许保留从较大的源数据中学到的共享底层特性，同时使模型适应目标数据。</li><li>在非最大抑制(NMS)操作之前，我们保留并利用所有大小的proposals来降低在不受控制的场景中极端尺度下的误检率。在部署中，我们考虑所有的检测框得分都在0.5以上，而不是从每个场景图像中提取固定数量的框。这个很好理解。<h2 id="3-2-Multi-Scale-Matching-by-Cross-Level-Semantic-Alignment"><a href="#3-2-Multi-Scale-Matching-by-Cross-Level-Semantic-Alignment" class="headerlink" title="3.2 Multi-Scale Matching by Cross-Level Semantic Alignment"></a>3.2 Multi-Scale Matching by Cross-Level Semantic Alignment</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/CLSA3.png" alt></div></li></ol><p>有点复杂，具体可以见论文。</p><h1 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h1><h2 id="On-CUHK-SYSU"><a href="#On-CUHK-SYSU" class="headerlink" title="On CUHK-SYSU"></a>On CUHK-SYSU</h2><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/CLSA4.png" alt></div><h2 id="On-PRW"><a href="#On-PRW" class="headerlink" title="On PRW"></a>On PRW</h2><p>pass</p><h2 id="Further-Analysis-and-Discussions"><a href="#Further-Analysis-and-Discussions" class="headerlink" title="Further Analysis and Discussions"></a>Further Analysis and Discussions</h2><p>在re-id和detection的数据集上也做了一些实验。</p><div align="center"><img src="http://picture-1259281112.cos.ap-shanghai.myqcloud.com/CLSA5.png" alt></div>   <h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在本文中，我们提出了一种新的跨层次语义对齐(CLSA)深度学习框架，用于无约束场景图像中的人物搜索。与现有的以提高人的检测性能为核心的人的搜索方法相比，我们的实验表明，解决多尺度匹配问题对提高人的搜索结果更为重要。<br>为了解决这一研究不足的跨尺度人员搜索问题，我们提出了一种端到端的CLSA深度学习方法，通过构造网络内特征金字塔结构表示，利用语义对齐学习损失函数增强其表示能力。以使所有特征金字塔等级识别具有辨别力，从而导致更有效的分层表示，用于匹配具有大且无约束的尺度变化的人物图像。</p><h1 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h1><p>主要通过提升检测时候增加了多尺度匹配，通过特征金字塔，在re-id部分增加语义对齐，这个在re-id里也是常用手段，但是是跨层次的，相当于multi-scale的。最后结尾在一些image-based re-id数据集上也做了实验，比如market1501和cuhk03上，但是提升效果寥寥，88.9的top1在market1501上真的很一般。为啥能在person search上表现这么好，总之person search的坑很多，一些在detection上和re-id上能提升的，改进一些都可以在person search上有提高。但是这也提高了太多了把~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;论文：Person Search by Multi-Scale Matching&lt;br&gt;链接：&lt;a href=&quot;http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://openaccess.thecvf.com/content_ECCV_2018/html/Xu_Lan_Person_Search_by_ECCV_2018_paper.html&lt;/a&gt;&lt;br&gt;代码地址：没有公开&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="行人搜索" scheme="http://www.cygao.xyz/categories/%E8%A1%8C%E4%BA%BA%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="论文笔记" scheme="http://www.cygao.xyz/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
